
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/apriltag/AprilTagDetector.h>


#include <units_angle_type_caster.h>



#include <pybind11/operators.h>











#include <pybind11_typing.h>



#include <type_traits>


  using namespace frc;



struct rpybuild_AprilTagDetector_initializer {


  

  












  py::class_<typename frc::AprilTagDetector> cls_AprilTagDetector;

    

    
    
    py::class_<typename frc::AprilTagDetector::Config> cls_Config;

    

    
    
    
    py::class_<typename frc::AprilTagDetector::QuadThresholdParameters> cls_QuadThresholdParameters;

    

    
    
    
    py::class_<typename frc::AprilTagDetector::Results> cls_Results;

    

    
    
    

  py::module &m;

  
  rpybuild_AprilTagDetector_initializer(py::module &m) :

  

  

  

  
    cls_AprilTagDetector(m, "AprilTagDetector"),

  

  
  
    cls_Config(cls_AprilTagDetector, "Config"),

  

  
  
  
    cls_QuadThresholdParameters(cls_AprilTagDetector, "QuadThresholdParameters"),

  

  
  
  
    cls_Results(cls_AprilTagDetector, "_Results"),

  

  
  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  

    
    
  

    
    
  

    
    
  }

void finish() {





  {
  
  using Config [[maybe_unused]] = typename frc::AprilTagDetector::Config;
  
  using QuadThresholdParameters [[maybe_unused]] = typename frc::AprilTagDetector::QuadThresholdParameters;
  
  using Results [[maybe_unused]] = typename frc::AprilTagDetector::Results;
  
  
  


  

  cls_AprilTagDetector.doc() =
    "An AprilTag detector engine. This is expensive to set up and tear down, so\n"
"most use cases should only create one of these, add a family to it, set up\n"
"any other configuration, and repeatedly call Detect().";

  cls_AprilTagDetector
  
    
  .def(py::init<>(), release_gil()
  )
  
  
  
    
  .
def
("setConfig", &frc::AprilTagDetector::SetConfig,
      py::arg("config"), release_gil(), py::doc(
    "Sets detector configuration.\n"
"\n"
":param config: Configuration")
  )
  
  
  
    
  .
def
("getConfig", &frc::AprilTagDetector::GetConfig, release_gil(), py::doc(
    "Gets detector configuration.\n"
"\n"
":returns: Configuration")
  )
  
  
  
    
  .
def
("setQuadThresholdParameters", &frc::AprilTagDetector::SetQuadThresholdParameters,
      py::arg("params"), release_gil(), py::doc(
    "Sets quad threshold parameters.\n"
"\n"
":param params: Parameters")
  )
  
  
  
    
  .
def
("getQuadThresholdParameters", &frc::AprilTagDetector::GetQuadThresholdParameters, release_gil(), py::doc(
    "Gets quad threshold parameters.\n"
"\n"
":returns: Parameters")
  )
  
  
  
    
  .
def
("addFamily", &frc::AprilTagDetector::AddFamily,
      py::arg("fam"), py::arg("bitsCorrected") = 2, release_gil(), py::doc(
    "Adds a family of tags to be detected.\n"
"\n"
":param fam:           Family name, e.g. \"tag16h5\"\n"
":param bitsCorrected: Maximum number of bits to correct\n"
"\n"
":returns: False if family can't be found")
  )
  
  
  
    
  .
def
("removeFamily", &frc::AprilTagDetector::RemoveFamily,
      py::arg("fam"), release_gil(), py::doc(
    "Removes a family of tags from the detector.\n"
"\n"
":param fam: Family name, e.g. \"tag16h5\"")
  )
  
  
  
    
  .
def
("clearFamilies", &frc::AprilTagDetector::ClearFamilies, release_gil(), py::doc(
    "Unregister all families.")
  )
  
  
  .def("detect", [](AprilTagDetector *self, py::buffer img) {

  // validate the input image buffer
  auto buf = img.request();
  if (buf.ndim != 2) {
    throw py::value_error("buffer must only have two dimensions");
  } else if (buf.itemsize != 1) {
    throw py::value_error("buffer elements must be bytes");
  }

  // We are going to move the detection result into this shared_ptr
  // so that python can keep it alive. We don't expose the result directly
  // to the user because we'd have to pretend it's a list, and that would
  // be annoying. 
  std::shared_ptr<AprilTagDetector::Results> c_result;
  {
    py::gil_scoped_release unlock;
    c_result = std::make_shared<AprilTagDetector::Results>(std::move(self->Detect(buf.shape[1], buf.shape[0], (uint8_t*)buf.ptr)));
  }

  // This tells python about the shared_ptr, and it'll keep it alive as
  // long as the python reference is alive. When we call get(), we marked
  // the return value as reference_internal so python will keep the python
  // reference for the results object alive for as long as all of its
  // results that we put into the list are alive
  py::object py_result = py::cast(c_result);
  auto len = c_result->size();
  auto get = py_result.attr("get");
  py::typing::List<AprilTagDetection> l(len);
  for (size_t i = 0; i < len; i++) {
    l[i] = get(i);
  }
  return l;
}, py::arg("image"),
  R"doc(
    Detect tags from an 8-bit grayscale image with shape (height, width)

    :return: list of results
  )doc"
)
;

  


  

  cls_Config.doc() =
    "Detector configuration.";

  cls_Config
  
    .def(py::init<>(), release_gil())
  
    
  .def(py::self == py::self
  )
  
  
  
    .def_readwrite("numThreads", &frc::AprilTagDetector::Config::numThreads, py::doc(
    "How many threads should be used for computation. Default is\n"
"single-threaded operation (1 thread)."))
  
    .def_readwrite("quadDecimate", &frc::AprilTagDetector::Config::quadDecimate, py::doc(
    "Quad decimation. Detection of quads can be done on a lower-resolution\n"
"image, improving speed at a cost of pose accuracy and a slight decrease\n"
"in detection rate. Decoding the binary payload is still done at full\n"
"resolution. Default is 2.0."))
  
    .def_readwrite("quadSigma", &frc::AprilTagDetector::Config::quadSigma, py::doc(
    "What Gaussian blur should be applied to the segmented image (used for\n"
"quad detection). Very noisy images benefit from non-zero values (e.g.\n"
"0.8). Default is 0.0."))
  
    .def_readwrite("refineEdges", &frc::AprilTagDetector::Config::refineEdges, py::doc(
    "When true, the edges of the each quad are adjusted to \"snap to\" strong\n"
"gradients nearby. This is useful when decimation is employed, as it can\n"
"increase the quality of the initial quad estimate substantially.\n"
"Generally recommended to be on (true). Default is true.\n"
"\n"
"Very computationally inexpensive. Option is ignored if\n"
"quad_decimate = 1."))
  
    .def_readwrite("decodeSharpening", &frc::AprilTagDetector::Config::decodeSharpening, py::doc(
    "How much sharpening should be done to decoded images. This can help\n"
"decode small tags but may or may not help in odd lighting conditions or\n"
"low light conditions. Default is 0.25."))
  
    .def_readwrite("debug", &frc::AprilTagDetector::Config::debug, py::doc(
    "Debug mode. When true, the decoder writes a variety of debugging images\n"
"to the current working directory at various stages through the detection\n"
"process. This is slow and should *not* be used on space-limited systems\n"
"such as the RoboRIO. Default is disabled (false)."))
  ;

  


  
  

  cls_QuadThresholdParameters.doc() =
    "Quad threshold parameters.";

  cls_QuadThresholdParameters
  
    .def(py::init<>(), release_gil())
  
    
  .def(py::self == py::self
  )
  
  
  
    .def_readwrite("minClusterPixels", &frc::AprilTagDetector::QuadThresholdParameters::minClusterPixels, py::doc(
    "Threshold used to reject quads containing too few pixels. Default is 300\n"
"pixels."))
  
    .def_readwrite("maxNumMaxima", &frc::AprilTagDetector::QuadThresholdParameters::maxNumMaxima, py::doc(
    "How many corner candidates to consider when segmenting a group of pixels\n"
"into a quad. Default is 10."))
  
    .def_readwrite("criticalAngle", &frc::AprilTagDetector::QuadThresholdParameters::criticalAngle, py::doc(
    "Critical angle. The detector will reject quads where pairs of edges have\n"
"angles that are close to straight or close to 180 degrees. Zero means\n"
"that no quads are rejected. Default is 45 degrees."))
  
    .def_readwrite("maxLineFitMSE", &frc::AprilTagDetector::QuadThresholdParameters::maxLineFitMSE, py::doc(
    "When fitting lines to the contours, the maximum mean squared error\n"
"allowed. This is useful in rejecting contours that are far from being\n"
"quad shaped; rejecting these quads \"early\" saves expensive decoding\n"
"processing. Default is 10.0."))
  
    .def_readwrite("minWhiteBlackDiff", &frc::AprilTagDetector::QuadThresholdParameters::minWhiteBlackDiff, py::doc(
    "Minimum brightness offset. When we build our model of black & white\n"
"pixels, we add an extra check that the white model must be (overall)\n"
"brighter than the black model. How much brighter? (in pixel values,\n"
"[0,255]). Default is 5."))
  
    .def_readwrite("deglitch", &frc::AprilTagDetector::QuadThresholdParameters::deglitch, py::doc(
    "Whether the thresholded image be should be deglitched. Only useful for\n"
"very noisy images. Default is disabled (false)."))
  ;

  


  
  

  cls_Results.doc() =
    "Array of detection results. Each array element is a pointer to an\n"
"AprilTagDetection.";

  cls_Results
  // use the keepalive to keep the array of results around until
// the user deletes them
.def("get", [](const AprilTagDetector::Results &self, int i) {
  return self[i];
}, py::return_value_policy::reference_internal)
;

  


  
  }






}

}; // struct rpybuild_AprilTagDetector_initializer

static std::unique_ptr<rpybuild_AprilTagDetector_initializer> cls;

void begin_init_AprilTagDetector(py::module &m) {
  cls = std::make_unique<rpybuild_AprilTagDetector_initializer>(m);
}

void finish_init_AprilTagDetector() {
  cls->finish();
  cls.reset();
}