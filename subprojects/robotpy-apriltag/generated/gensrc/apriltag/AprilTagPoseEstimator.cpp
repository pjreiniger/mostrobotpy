
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/apriltag/AprilTagPoseEstimator.h>


#include <units_length_type_caster.h>

#include <wpi_span_type_caster.h>



#include <pybind11/operators.h>











#include <frc/apriltag/AprilTagDetection.h>



#include <type_traits>


  using namespace frc;





struct rpybuild_AprilTagPoseEstimator_initializer {


  

  












  py::class_<typename frc::AprilTagPoseEstimator> cls_AprilTagPoseEstimator;

    

    
    
    py::class_<typename frc::AprilTagPoseEstimator::Config> cls_Config;

    

    
    
    

  py::module &m;

  
  rpybuild_AprilTagPoseEstimator_initializer(py::module &m) :

  

  

  

  
    cls_AprilTagPoseEstimator(m, "AprilTagPoseEstimator"),

  

  
  
    cls_Config(cls_AprilTagPoseEstimator, "Config"),

  

  
  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  

    
    
  }

void finish() {





  {
  
  using Config [[maybe_unused]] = typename frc::AprilTagPoseEstimator::Config;
  
  
  


  

  cls_AprilTagPoseEstimator.doc() =
    "Pose estimators for AprilTag tags.";

  cls_AprilTagPoseEstimator
  
    
  .def(py::init<const Config&>(),
      py::arg("config"), release_gil()
    , py::keep_alive<1, 2>(), py::doc(
    "Creates estimator.\n"
"\n"
":param config: Configuration")
  )
  
  
  
    
  .
def
("setConfig", &frc::AprilTagPoseEstimator::SetConfig,
      py::arg("config"), release_gil(), py::doc(
    "Sets estimator configuration.\n"
"\n"
":param config: Configuration")
  )
  
  
  
    
  .
def
("getConfig", &frc::AprilTagPoseEstimator::GetConfig, release_gil(), py::doc(
    "Gets estimator configuration.\n"
"\n"
":returns: Configuration")
  )
  
  
  
    
  .
def
("estimateHomography", static_cast<Transform3d(frc::AprilTagPoseEstimator::*)(const AprilTagDetection&) const>(
        &frc::AprilTagPoseEstimator::EstimateHomography),
      py::arg("detection"), release_gil(), py::doc(
    "Estimates the pose of the tag using the homography method described in [1].\n"
"\n"
":param detection: Tag detection\n"
"\n"
":returns: Pose estimate")
  )
  
  
  
    
  .
def
("estimateHomography", static_cast<Transform3d(frc::AprilTagPoseEstimator::*)(std::span<const double, 9>) const>(
        &frc::AprilTagPoseEstimator::EstimateHomography),
      py::arg("homography"), release_gil(), py::doc(
    "Estimates the pose of the tag using the homography method described in [1].\n"
"\n"
":param homography: Homography 3x3 matrix data\n"
"\n"
":returns: Pose estimate")
  )
  
  
  
    
  .
def
("estimateOrthogonalIteration", static_cast<AprilTagPoseEstimate(frc::AprilTagPoseEstimator::*)(const AprilTagDetection&, int) const>(
        &frc::AprilTagPoseEstimator::EstimateOrthogonalIteration),
      py::arg("detection"), py::arg("nIters"), release_gil(), py::doc(
    "Estimates the pose of the tag. This returns one or two possible poses for\n"
"the tag, along with the object-space error of each.\n"
"\n"
"This uses the homography method described in [1] for the initial estimate.\n"
"Then Orthogonal Iteration [2] is used to refine this estimate. Then [3] is\n"
"used to find a potential second local minima and Orthogonal Iteration is\n"
"used to refine this second estimate.\n"
"\n"
"[1]: E. Olson, “Apriltag: A robust and flexible visual fiducial system,” in\n"
"2011 IEEE International Conference on Robotics and Automation,\n"
"May 2011, pp. 3400–3407.\n"
"[2]: Lu, G. D. Hager and E. Mjolsness, \"Fast and globally convergent pose\n"
"estimation from video images,\" in IEEE Transactions on Pattern\n"
"Analysis and Machine Intelligence, vol. 22, no. 6, pp. 610-622, June 2000.\n"
"doi: 10.1109/34.862199\n"
"[3]: Schweighofer and A. Pinz, \"Robust Pose Estimation from a Planar\n"
"Target,\" in IEEE Transactions on Pattern Analysis and Machine Intelligence,\n"
"vol. 28, no. 12, pp. 2024-2030, Dec. 2006. doi: 10.1109/TPAMI.2006.252\n"
"\n"
":param detection: Tag detection\n"
":param nIters:    Number of iterations\n"
"\n"
":returns: Initial and (possibly) second pose estimates")
  )
  
  
  
    
  .
def
("estimateOrthogonalIteration", static_cast<AprilTagPoseEstimate(frc::AprilTagPoseEstimator::*)(std::span<const double, 9>, std::span<const double, 8>, int) const>(
        &frc::AprilTagPoseEstimator::EstimateOrthogonalIteration),
      py::arg("homography"), py::arg("corners"), py::arg("nIters"), release_gil(), py::doc(
    "Estimates the pose of the tag. This returns one or two possible poses for\n"
"the tag, along with the object-space error of each.\n"
"\n"
":param homography: Homography 3x3 matrix data\n"
":param corners:    Corner point array (X and Y for each corner in order)\n"
":param nIters:     Number of iterations\n"
"\n"
":returns: Initial and (possibly) second pose estimates")
  )
  
  
  
    
  .
def
("estimate", static_cast<Transform3d(frc::AprilTagPoseEstimator::*)(const AprilTagDetection&) const>(
        &frc::AprilTagPoseEstimator::Estimate),
      py::arg("detection"), release_gil(), py::doc(
    "Estimates tag pose. This method is an easier to use interface to\n"
"EstimatePoseOrthogonalIteration(), running 50 iterations and returning the\n"
"pose with the lower object-space error.\n"
"\n"
":param detection: Tag detection\n"
"\n"
":returns: Pose estimate")
  )
  
  
  
    
  .
def
("estimate", static_cast<Transform3d(frc::AprilTagPoseEstimator::*)(std::span<const double, 9>, std::span<const double, 8>) const>(
        &frc::AprilTagPoseEstimator::Estimate),
      py::arg("homography"), py::arg("corners"), release_gil(), py::doc(
    "Estimates tag pose. This method is an easier to use interface to\n"
"EstimatePoseOrthogonalIteration(), running 50 iterations and returning the\n"
"pose with the lower object-space error.\n"
"\n"
":param homography: Homography 3x3 matrix data\n"
":param corners:    Corner point array (X and Y for each corner in order)\n"
"\n"
":returns: Pose estimate")
  )
  
  
  ;

  


  

  cls_Config.doc() =
    "Configuration for the pose estimator.";

  cls_Config
  
    
  .def(py::self == py::self
  )
  
  
  
    .def_readwrite("tagSize", &frc::AprilTagPoseEstimator::Config::tagSize, py::doc(
    "The tag size."))
  
    .def_readwrite("fx", &frc::AprilTagPoseEstimator::Config::fx, py::doc(
    "Camera horizontal focal length, in pixels."))
  
    .def_readwrite("fy", &frc::AprilTagPoseEstimator::Config::fy, py::doc(
    "Camera vertical focal length, in pixels."))
  
    .def_readwrite("cx", &frc::AprilTagPoseEstimator::Config::cx, py::doc(
    "Camera horizontal focal center, in pixels."))
  
    .def_readwrite("cy", &frc::AprilTagPoseEstimator::Config::cy, py::doc(
    "Camera vertical focal center, in pixels."))
  .def(py::init([](units::meter_t tagSize, double fx, double fy, double cx, double cy) { AprilTagPoseEstimator::Config cfg{tagSize, fx, fy, cx, cy}; return std::make_unique<AprilTagPoseEstimator::Config>(std::move(cfg)); }), py::arg("tagSize"), py::arg("fx"), py::arg("fy"), py::arg("cx"), py::arg("cy"));

  


  
  }






}

}; // struct rpybuild_AprilTagPoseEstimator_initializer

static std::unique_ptr<rpybuild_AprilTagPoseEstimator_initializer> cls;

void begin_init_AprilTagPoseEstimator(py::module &m) {
  cls = std::make_unique<rpybuild_AprilTagPoseEstimator_initializer>(m);
}

void finish_init_AprilTagPoseEstimator() {
  cls->finish();
  cls.reset();
}