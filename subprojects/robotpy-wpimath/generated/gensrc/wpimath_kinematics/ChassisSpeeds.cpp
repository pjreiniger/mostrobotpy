
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/kinematics/ChassisSpeeds.h>


#include <units_angular_velocity_type_caster.h>

#include <units_time_type_caster.h>

#include <units_velocity_type_caster.h>



#include <pybind11/operators.h>











#include <wpystruct.h>



#include <type_traits>


  using namespace frc;





struct rpybuild_ChassisSpeeds_initializer {


  

  












  py::class_<typename frc::ChassisSpeeds> cls_ChassisSpeeds;

    

    
    

  py::module &m;

  
  rpybuild_ChassisSpeeds_initializer(py::module &m) :

  

  

  

  
    cls_ChassisSpeeds(m, "ChassisSpeeds"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_ChassisSpeeds.doc() =
    "Represents the speed of a robot chassis. Although this struct contains\n"
"similar members compared to a Twist2d, they do NOT represent the same thing.\n"
"Whereas a Twist2d represents a change in pose w.r.t to the robot frame of\n"
"reference, a ChassisSpeeds struct represents a robot's velocity.\n"
"\n"
"A strictly non-holonomic drivetrain, such as a differential drive, should\n"
"never have a dy component because it can never move sideways. Holonomic\n"
"drivetrains such as swerve and mecanum will often have all three components.";

  cls_ChassisSpeeds
  
    
  .
def_static
("discretize", static_cast<ChassisSpeeds(*)(units::meters_per_second_t, units::meters_per_second_t, units::radians_per_second_t, units::second_t)>(
        &frc::ChassisSpeeds::Discretize),
      py::arg("vx"), py::arg("vy"), py::arg("omega"), py::arg("dt"), release_gil(), py::doc(
    "Disretizes a continuous-time chassis speed.\n"
"\n"
"This function converts a continuous-time chassis speed into a discrete-time\n"
"one such that when the discrete-time chassis speed is applied for one\n"
"timestep, the robot moves as if the velocity components are independent\n"
"(i.e., the robot moves v_x * dt along the x-axis, v_y * dt along the\n"
"y-axis, and omega * dt around the z-axis).\n"
"\n"
"This is useful for compensating for translational skew when translating and\n"
"rotating a swerve drivetrain.\n"
"\n"
":param vx:    Forward velocity.\n"
":param vy:    Sideways velocity.\n"
":param omega: Angular velocity.\n"
":param dt:    The duration of the timestep the speeds should be applied for.\n"
"\n"
":returns: Discretized ChassisSpeeds.")
  )
  
  
  
    
  .
def_static
("discretize", static_cast<ChassisSpeeds(*)(const ChassisSpeeds&, units::second_t)>(
        &frc::ChassisSpeeds::Discretize),
      py::arg("continuousSpeeds"), py::arg("dt"), release_gil(), py::doc(
    "Disretizes a continuous-time chassis speed.\n"
"\n"
"This function converts a continuous-time chassis speed into a discrete-time\n"
"one such that when the discrete-time chassis speed is applied for one\n"
"timestep, the robot moves as if the velocity components are independent\n"
"(i.e., the robot moves v_x * dt along the x-axis, v_y * dt along the\n"
"y-axis, and omega * dt around the z-axis).\n"
"\n"
"This is useful for compensating for translational skew when translating and\n"
"rotating a swerve drivetrain.\n"
"\n"
":param continuousSpeeds: The continuous speeds.\n"
":param dt:               The duration of the timestep the speeds should be applied for.\n"
"\n"
":returns: Discretized ChassisSpeeds.")
  )
  
  
  
    
  .
def_static
("fromFieldRelativeSpeeds", static_cast<ChassisSpeeds(*)(units::meters_per_second_t, units::meters_per_second_t, units::radians_per_second_t, const Rotation2d&)>(
        &frc::ChassisSpeeds::FromFieldRelativeSpeeds),
      py::arg("vx"), py::arg("vy"), py::arg("omega"), py::arg("robotAngle"), release_gil(), py::doc(
    "Converts a user provided field-relative set of speeds into a robot-relative\n"
"ChassisSpeeds object.\n"
"\n"
":param vx:         The component of speed in the x direction relative to the field.\n"
"                   Positive x is away from your alliance wall.\n"
":param vy:         The component of speed in the y direction relative to the field.\n"
"                   Positive y is to your left when standing behind the alliance wall.\n"
":param omega:      The angular rate of the robot.\n"
":param robotAngle: The angle of the robot as measured by a gyroscope. The\n"
"                   robot's angle is considered to be zero when it is facing directly away from\n"
"                   your alliance station wall. Remember that this should be CCW positive.\n"
"\n"
":returns: ChassisSpeeds object representing the speeds in the robot's frame\n"
"          of reference.")
  )
  
  
  
    
  .
def_static
("fromFieldRelativeSpeeds", static_cast<ChassisSpeeds(*)(const ChassisSpeeds&, const Rotation2d&)>(
        &frc::ChassisSpeeds::FromFieldRelativeSpeeds),
      py::arg("fieldRelativeSpeeds"), py::arg("robotAngle"), release_gil(), py::doc(
    "Converts a user provided field-relative ChassisSpeeds object into a\n"
"robot-relative ChassisSpeeds object.\n"
"\n"
":param fieldRelativeSpeeds: The ChassisSpeeds object representing the speeds\n"
"                            in the field frame of reference. Positive x is away from your alliance\n"
"                            wall. Positive y is to your left when standing behind the alliance wall.\n"
":param robotAngle:          The angle of the robot as measured by a gyroscope. The\n"
"                            robot's angle is considered to be zero when it is facing directly away\n"
"                            from your alliance station wall. Remember that this should be CCW\n"
"                            positive.\n"
"\n"
":returns: ChassisSpeeds object representing the speeds in the robot's frame\n"
"          of reference.")
  )
  
  
  
    
  .
def_static
("fromRobotRelativeSpeeds", static_cast<ChassisSpeeds(*)(units::meters_per_second_t, units::meters_per_second_t, units::radians_per_second_t, const Rotation2d&)>(
        &frc::ChassisSpeeds::FromRobotRelativeSpeeds),
      py::arg("vx"), py::arg("vy"), py::arg("omega"), py::arg("robotAngle"), release_gil(), py::doc(
    "Converts a user provided robot-relative set of speeds into a field-relative\n"
"ChassisSpeeds object.\n"
"\n"
":param vx:         The component of speed in the x direction relative to the robot.\n"
"                   Positive x is towards the robot's front.\n"
":param vy:         The component of speed in the y direction relative to the robot.\n"
"                   Positive y is towards the robot's left.\n"
":param omega:      The angular rate of the robot.\n"
":param robotAngle: The angle of the robot as measured by a gyroscope. The\n"
"                   robot's angle is considered to be zero when it is facing directly away from\n"
"                   your alliance station wall. Remember that this should be CCW positive.\n"
"\n"
":returns: ChassisSpeeds object representing the speeds in the field's frame\n"
"          of reference.")
  )
  
  
  
    
  .
def_static
("fromRobotRelativeSpeeds", static_cast<ChassisSpeeds(*)(const ChassisSpeeds&, const Rotation2d&)>(
        &frc::ChassisSpeeds::FromRobotRelativeSpeeds),
      py::arg("robotRelativeSpeeds"), py::arg("robotAngle"), release_gil(), py::doc(
    "Converts a user provided robot-relative ChassisSpeeds object into a\n"
"field-relative ChassisSpeeds object.\n"
"\n"
":param robotRelativeSpeeds: The ChassisSpeeds object representing the speeds\n"
"                            in the robot frame of reference. Positive x is the towards robot's\n"
"                            front. Positive y is towards the robot's left.\n"
":param robotAngle:          The angle of the robot as measured by a gyroscope. The\n"
"                            robot's angle is considered to be zero when it is facing directly away\n"
"                            from your alliance station wall. Remember that this should be CCW\n"
"                            positive.\n"
"\n"
":returns: ChassisSpeeds object representing the speeds in the field's frame\n"
"          of reference.")
  )
  
  
  
    
  .def(py::self + py::self, py::doc(
    "Adds two ChassisSpeeds and returns the sum.\n"
"\n"
"For example, ChassisSpeeds{1.0, 0.5, 1.5} + ChassisSpeeds{2.0, 1.5, 0.5}\n"
"= ChassisSpeeds{3.0, 2.0, 2.0}\n"
"\n"
":param other: The ChassisSpeeds to add.\n"
"\n"
":returns: The sum of the ChassisSpeeds.")
  )
  
  
  
    
  .def(py::self - py::self, py::doc(
    "Subtracts the other ChassisSpeeds from the current ChassisSpeeds and\n"
"returns the difference.\n"
"\n"
"For example, ChassisSpeeds{5.0, 4.0, 2.0} - ChassisSpeeds{1.0, 2.0, 1.0}\n"
"= ChassisSpeeds{4.0, 2.0, 1.0}\n"
"\n"
":param other: The ChassisSpeeds to subtract.\n"
"\n"
":returns: The difference between the two ChassisSpeeds.")
  )
  
  
  
    
  .def(- py::self, py::doc(
    "Returns the inverse of the current ChassisSpeeds.\n"
"This is equivalent to negating all components of the ChassisSpeeds.\n"
"\n"
":returns: The inverse of the current ChassisSpeeds.")
  )
  
  
  
    
  .def(py::self * double(), py::doc(
    "Multiplies the ChassisSpeeds by a scalar and returns the new ChassisSpeeds.\n"
"\n"
"For example, ChassisSpeeds{2.0, 2.5, 1.0} * 2\n"
"= ChassisSpeeds{4.0, 5.0, 1.0}\n"
"\n"
":param scalar: The scalar to multiply by.\n"
"\n"
":returns: The scaled ChassisSpeeds.")
  )
  
  
  
    
  .def(py::self / double(), py::doc(
    "Divides the ChassisSpeeds by a scalar and returns the new ChassisSpeeds.\n"
"\n"
"For example, ChassisSpeeds{2.0, 2.5, 1.0} / 2\n"
"= ChassisSpeeds{1.0, 1.25, 0.5}\n"
"\n"
":param scalar: The scalar to divide by.\n"
"\n"
":returns: The scaled ChassisSpeeds.")
  )
  
  
  
    .def_readwrite("vx", &frc::ChassisSpeeds::vx, py::doc(
    "Velocity along the x-axis. (Fwd is +)"))
  
    .def_readwrite("vy", &frc::ChassisSpeeds::vy, py::doc(
    "Velocity along the y-axis. (Left is +)"))
  
    .def_readwrite("omega", &frc::ChassisSpeeds::omega, py::doc(
    "Represents the angular velocity of the robot frame. (CCW is +)"))
  ;

  


  }







  cls_ChassisSpeeds
  .def(
    py::init<
      units::meters_per_second_t, units::meters_per_second_t,
      units::radians_per_second_t
    >(),
    py::arg("vx") = 0, py::arg("vy") = 0, py::arg("omega") = 0
  )
  .def_static("fromFeet", [](units::feet_per_second_t vx, units::feet_per_second_t vy, units::radians_per_second_t omega){
    return ChassisSpeeds{vx, vy, omega};
  }, py::arg("vx") = 0, py::arg("vy") = 0, py::arg("omega") = 0)
  .def_property("vx_fps",
    [](ChassisSpeeds * self) -> units::feet_per_second_t {
      return self->vx;
    },
    [](ChassisSpeeds * self, units::feet_per_second_t vx) {
      self->vx = vx;
    }
  )
  .def_property("vy_fps", 
    [](ChassisSpeeds * self) -> units::feet_per_second_t {
      return self->vy;
    },
    [](ChassisSpeeds * self, units::feet_per_second_t vy) {
      self->vy = vy;
    }
  )
  .def_property("omega_dps", 
    [](ChassisSpeeds * self) -> units::degrees_per_second_t {
      return self->omega;
    },
    [](ChassisSpeeds * self, units::degrees_per_second_t omega) {
      self->omega = omega;
    }
  )
  .def("__len__", [](const ChassisSpeeds &self) { return 3; })
  .def("__getitem__", [](const ChassisSpeeds &self, int index) {
    switch (index) {
      case 0:
        return self.vx();
      case 1:
        return self.vy();
      case 2:
        return self.omega();
      default:
        throw std::out_of_range("ChassisSpeeds index out of range");
    }
  })
  .def("__repr__", [](const ChassisSpeeds &cs) -> std::string {
    return "ChassisSpeeds(vx=" + std::to_string(cs.vx()) + ", "
                         "vy=" + std::to_string(cs.vy()) + ", "
                         "omega=" + std::to_string(cs.omega()) + ")";
  })
;

SetupWPyStruct<frc::ChassisSpeeds>(cls_ChassisSpeeds);


}

}; // struct rpybuild_ChassisSpeeds_initializer

static std::unique_ptr<rpybuild_ChassisSpeeds_initializer> cls;

void begin_init_ChassisSpeeds(py::module &m) {
  cls = std::make_unique<rpybuild_ChassisSpeeds_initializer>(m);
}

void finish_init_ChassisSpeeds() {
  cls->finish();
  cls.reset();
}