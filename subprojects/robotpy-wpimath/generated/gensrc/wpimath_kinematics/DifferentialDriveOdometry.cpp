
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/kinematics/DifferentialDriveOdometry.h>


#include <units_length_type_caster.h>















#include <type_traits>


  using namespace frc;



struct rpybuild_DifferentialDriveOdometry_initializer {


  

  












  py::class_<typename frc::DifferentialDriveOdometry, frc::Odometry<DifferentialDriveWheelSpeeds, DifferentialDriveWheelPositions>> cls_DifferentialDriveOdometry;

    

    
    

  py::module &m;

  
  rpybuild_DifferentialDriveOdometry_initializer(py::module &m) :

  

  

  

  
    cls_DifferentialDriveOdometry(m, "DifferentialDriveOdometry"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_DifferentialDriveOdometry.doc() =
    "Class for differential drive odometry. Odometry allows you to track the\n"
"robot's position on the field over the course of a match using readings from\n"
"2 encoders and a gyroscope.\n"
"\n"
"Teams can use odometry during the autonomous period for complex tasks like\n"
"path following. Furthermore, odometry can be used for latency compensation\n"
"when using computer-vision systems.\n"
"\n"
"It is important that you reset your encoders to zero before using this class.\n"
"Any subsequent pose resets also require the encoders to be reset to zero.";

  cls_DifferentialDriveOdometry
  
    
  .def(py::init<const Rotation2d&, units::meter_t, units::meter_t, const Pose2d&>(),
      py::arg("gyroAngle"), py::arg("leftDistance"), py::arg("rightDistance"), py::arg("initialPose") = Pose2d{}, release_gil()
    , py::keep_alive<1, 2>()
    , py::keep_alive<1, 5>(), py::doc(
    "Constructs a DifferentialDriveOdometry object.\n"
"\n"
"IF leftDistance and rightDistance are unspecified,\n"
"You NEED to reset your encoders (to zero).\n"
"\n"
":param gyroAngle:     The angle reported by the gyroscope.\n"
":param leftDistance:  The distance traveled by the left encoder.\n"
":param rightDistance: The distance traveled by the right encoder.\n"
":param initialPose:   The starting position of the robot on the field.")
  )
  
  
  
    
  .
def
("resetPosition", &frc::DifferentialDriveOdometry::ResetPosition,
      py::arg("gyroAngle"), py::arg("leftDistance"), py::arg("rightDistance"), py::arg("pose"), release_gil(), py::doc(
    "Resets the robot's position on the field.\n"
"\n"
"IF leftDistance and rightDistance are unspecified,\n"
"You NEED to reset your encoders (to zero).\n"
"\n"
"The gyroscope angle does not need to be reset here on the user's robot\n"
"code. The library automatically takes care of offsetting the gyro angle.\n"
"\n"
":param pose:          The position on the field that your robot is at.\n"
":param gyroAngle:     The angle reported by the gyroscope.\n"
":param leftDistance:  The distance traveled by the left encoder.\n"
":param rightDistance: The distance traveled by the right encoder.")
  )
  
  
  
    
  .
def
("update", &frc::DifferentialDriveOdometry::Update,
      py::arg("gyroAngle"), py::arg("leftDistance"), py::arg("rightDistance"), release_gil(), py::doc(
    "Updates the robot position on the field using distance measurements from\n"
"encoders. This method is more numerically accurate than using velocities to\n"
"integrate the pose and is also advantageous for teams that are using lower\n"
"CPR encoders.\n"
"\n"
":param gyroAngle:     The angle reported by the gyroscope.\n"
":param leftDistance:  The distance traveled by the left encoder.\n"
":param rightDistance: The distance traveled by the right encoder.\n"
"\n"
":returns: The new pose of the robot.")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_DifferentialDriveOdometry_initializer

static std::unique_ptr<rpybuild_DifferentialDriveOdometry_initializer> cls;

void begin_init_DifferentialDriveOdometry(py::module &m) {
  cls = std::make_unique<rpybuild_DifferentialDriveOdometry_initializer>(m);
}

void finish_init_DifferentialDriveOdometry() {
  cls->finish();
  cls.reset();
}