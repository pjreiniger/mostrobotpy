
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/kinematics/DifferentialDriveWheelSpeeds.h>


#include <units_velocity_type_caster.h>



#include <pybind11/operators.h>











#include <wpystruct.h>



#include <type_traits>


  using namespace frc;



struct rpybuild_DifferentialDriveWheelSpeeds_initializer {


  

  












  py::class_<typename frc::DifferentialDriveWheelSpeeds> cls_DifferentialDriveWheelSpeeds;

    

    
    

  py::module &m;

  
  rpybuild_DifferentialDriveWheelSpeeds_initializer(py::module &m) :

  

  

  

  
    cls_DifferentialDriveWheelSpeeds(m, "DifferentialDriveWheelSpeeds"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_DifferentialDriveWheelSpeeds.doc() =
    "Represents the wheel speeds for a differential drive drivetrain.";

  cls_DifferentialDriveWheelSpeeds
  
    
  .
def
("desaturate", &frc::DifferentialDriveWheelSpeeds::Desaturate,
      py::arg("attainableMaxSpeed"), release_gil(), py::doc(
    "Renormalizes the wheel speeds if either side is above the specified\n"
"maximum.\n"
"\n"
"Sometimes, after inverse kinematics, the requested speed from one or more\n"
"wheels may be above the max attainable speed for the driving motor on that\n"
"wheel. To fix this issue, one can reduce all the wheel speeds to make sure\n"
"that all requested module speeds are at-or-below the absolute threshold,\n"
"while maintaining the ratio of speeds between wheels.\n"
"\n"
":param attainableMaxSpeed: The absolute max speed that a wheel can reach.")
  )
  
  
  
    
  .def(py::self + py::self, py::doc(
    "Adds two DifferentialDriveWheelSpeeds and returns the sum.\n"
"\n"
"For example, DifferentialDriveWheelSpeeds{1.0, 0.5} +\n"
"DifferentialDriveWheelSpeeds{2.0, 1.5} =\n"
"DifferentialDriveWheelSpeeds{3.0, 2.0}\n"
"\n"
":param other: The DifferentialDriveWheelSpeeds to add.\n"
"\n"
":returns: The sum of the DifferentialDriveWheelSpeeds.")
  )
  
  
  
    
  .def(py::self - py::self, py::doc(
    "Subtracts the other DifferentialDriveWheelSpeeds from the current\n"
"DifferentialDriveWheelSpeeds and returns the difference.\n"
"\n"
"For example, DifferentialDriveWheelSpeeds{5.0, 4.0} -\n"
"DifferentialDriveWheelSpeeds{1.0, 2.0} =\n"
"DifferentialDriveWheelSpeeds{4.0, 2.0}\n"
"\n"
":param other: The DifferentialDriveWheelSpeeds to subtract.\n"
"\n"
":returns: The difference between the two DifferentialDriveWheelSpeeds.")
  )
  
  
  
    
  .def(- py::self, py::doc(
    "Returns the inverse of the current DifferentialDriveWheelSpeeds.\n"
"This is equivalent to negating all components of the\n"
"DifferentialDriveWheelSpeeds.\n"
"\n"
":returns: The inverse of the current DifferentialDriveWheelSpeeds.")
  )
  
  
  
    
  .def(py::self * double(), py::doc(
    "Multiplies the DifferentialDriveWheelSpeeds by a scalar and returns the new\n"
"DifferentialDriveWheelSpeeds.\n"
"\n"
"For example, DifferentialDriveWheelSpeeds{2.0, 2.5} * 2\n"
"= DifferentialDriveWheelSpeeds{4.0, 5.0}\n"
"\n"
":param scalar: The scalar to multiply by.\n"
"\n"
":returns: The scaled DifferentialDriveWheelSpeeds.")
  )
  
  
  
    
  .def(py::self / double(), py::doc(
    "Divides the DifferentialDriveWheelSpeeds by a scalar and returns the new\n"
"DifferentialDriveWheelSpeeds.\n"
"\n"
"For example, DifferentialDriveWheelSpeeds{2.0, 2.5} / 2\n"
"= DifferentialDriveWheelSpeeds{1.0, 1.25}\n"
"\n"
":param scalar: The scalar to divide by.\n"
"\n"
":returns: The scaled DifferentialDriveWheelSpeeds.")
  )
  
  
  
    .def_readwrite("left", &frc::DifferentialDriveWheelSpeeds::left, py::doc(
    "Speed of the left side of the robot."))
  
    .def_readwrite("right", &frc::DifferentialDriveWheelSpeeds::right, py::doc(
    "Speed of the right side of the robot."))
  ;

  


  }







  cls_DifferentialDriveWheelSpeeds
  .def(
    py::init<units::meters_per_second_t, units::meters_per_second_t>(),
    py::arg("left") = 0, py::arg("right") = 0
  )
  .def_static("fromFeet", [](units::feet_per_second_t left, units::feet_per_second_t right){
    return DifferentialDriveWheelSpeeds{left, right};
  }, py::arg("left"), py::arg("right"))
  .def_property("left_fps",
    [](DifferentialDriveWheelSpeeds * self) -> units::feet_per_second_t {
      return self->left;
    },
    [](DifferentialDriveWheelSpeeds * self, units::feet_per_second_t left) {
      self->left = left;
    }
  )
  .def_property("right_fps", 
    [](DifferentialDriveWheelSpeeds * self) -> units::feet_per_second_t {
      return self->right;
    },
    [](DifferentialDriveWheelSpeeds * self, units::feet_per_second_t right) {
      self->right = right;
    }
  )
  .def("__repr__", [](const DifferentialDriveWheelSpeeds &dds) -> std::string {
    return "DifferentialDriveWheelSpeeds(left=" + std::to_string(dds.left()) + ", "
                                        "right=" + std::to_string(dds.right()) + ")";
  })
;

SetupWPyStruct<frc::DifferentialDriveWheelSpeeds>(cls_DifferentialDriveWheelSpeeds);


}

}; // struct rpybuild_DifferentialDriveWheelSpeeds_initializer

static std::unique_ptr<rpybuild_DifferentialDriveWheelSpeeds_initializer> cls;

void begin_init_DifferentialDriveWheelSpeeds(py::module &m) {
  cls = std::make_unique<rpybuild_DifferentialDriveWheelSpeeds_initializer>(m);
}

void finish_init_DifferentialDriveWheelSpeeds() {
  cls->finish();
  cls.reset();
}