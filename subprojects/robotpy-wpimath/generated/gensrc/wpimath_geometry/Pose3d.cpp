
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/geometry/Pose3d.h>


#include <units_length_type_caster.h>



#include <pybind11/operators.h>











#include <rpy/geometryToString.h>

#include <wpystruct.h>



#include <type_traits>


  using namespace frc;



struct rpybuild_Pose3d_initializer {


  

  












  py::class_<typename frc::Pose3d> cls_Pose3d;

    

    
    

  py::module &m;

  
  rpybuild_Pose3d_initializer(py::module &m) :

  

  

  

  
    cls_Pose3d(m, "Pose3d"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_Pose3d.doc() =
    "Represents a 3D pose containing translational and rotational elements.";

  cls_Pose3d
  
    
  .def(py::init<>(), release_gil(), py::doc(
    "Constructs a pose at the origin facing toward the positive X axis.")
  )
  
  
  
    
  .def(py::init<Translation3d, Rotation3d>(),
      py::arg("translation"), py::arg("rotation"), release_gil(), py::doc(
    "Constructs a pose with the specified translation and rotation.\n"
"\n"
":param translation: The translational component of the pose.\n"
":param rotation:    The rotational component of the pose.")
  )
  
  
  
    
  .def(py::init<units::meter_t, units::meter_t, units::meter_t, Rotation3d>(),
      py::arg("x"), py::arg("y"), py::arg("z"), py::arg("rotation"), release_gil(), py::doc(
    "Constructs a pose with x, y, and z translations instead of a separate\n"
"Translation3d.\n"
"\n"
":param x:        The x component of the translational component of the pose.\n"
":param y:        The y component of the translational component of the pose.\n"
":param z:        The z component of the translational component of the pose.\n"
":param rotation: The rotational component of the pose.")
  )
  
  
  
    
  .def(py::init<const Pose2d&>(),
      py::arg("pose"), release_gil()
    , py::keep_alive<1, 2>(), py::doc(
    "Constructs a 3D pose from a 2D pose in the X-Y plane.\n"
"\n"
":param pose: The 2D pose.")
  )
  
  
  
    
  .def(py::self + Transform3d(), py::doc(
    "Transforms the pose by the given transformation and returns the new\n"
"transformed pose. The transform is applied relative to the pose's frame.\n"
"Note that this differs from Pose3d::RotateBy(const Rotation3d&), which is\n"
"applied relative to the global frame and around the origin.\n"
"\n"
":param other: The transform to transform the pose by.\n"
"\n"
":returns: The transformed pose.")
  )
  
  
  
    
  .def(py::self - py::self, py::doc(
    "Returns the Transform3d that maps the one pose to another.\n"
"\n"
":param other: The initial pose of the transformation.\n"
"\n"
":returns: The transform that maps the other pose to the current pose.")
  )
  
  
  
    
  .def(py::self == py::self, py::doc(
    "Checks equality between this Pose3d and another object.")
  )
  
  
  
    
  .
def
("translation", &frc::Pose3d::Translation, release_gil(), py::doc(
    "Returns the underlying translation.\n"
"\n"
":returns: Reference to the translational component of the pose.")
  )
  
  
  
    
  .
def
("X", &frc::Pose3d::X, release_gil(), py::doc(
    "Returns the X component of the pose's translation.\n"
"\n"
":returns: The x component of the pose's translation.")
  )
  
  
  
    
  .
def
("Y", &frc::Pose3d::Y, release_gil(), py::doc(
    "Returns the Y component of the pose's translation.\n"
"\n"
":returns: The y component of the pose's translation.")
  )
  
  
  
    
  .
def
("Z", &frc::Pose3d::Z, release_gil(), py::doc(
    "Returns the Z component of the pose's translation.\n"
"\n"
":returns: The z component of the pose's translation.")
  )
  
  
  
    
  .
def
("rotation", &frc::Pose3d::Rotation, release_gil(), py::doc(
    "Returns the underlying rotation.\n"
"\n"
":returns: Reference to the rotational component of the pose.")
  )
  
  
  
    
  .def(py::self * double(), py::doc(
    "Multiplies the current pose by a scalar.\n"
"\n"
":param scalar: The scalar.\n"
"\n"
":returns: The new scaled Pose2d.")
  )
  
  
  
    
  .def(py::self / double(), py::doc(
    "Divides the current pose by a scalar.\n"
"\n"
":param scalar: The scalar.\n"
"\n"
":returns: The new scaled Pose2d.")
  )
  
  
  
    
  .
def
("rotateBy", &frc::Pose3d::RotateBy,
      py::arg("other"), release_gil(), py::doc(
    "Rotates the pose around the origin and returns the new pose.\n"
"\n"
":param other: The rotation to transform the pose by, which is applied\n"
"              extrinsically (from the global frame).\n"
"\n"
":returns: The rotated pose.")
  )
  
  
  
    
  .
def
("transformBy", &frc::Pose3d::TransformBy,
      py::arg("other"), release_gil(), py::doc(
    "Transforms the pose by the given transformation and returns the new\n"
"transformed pose. The transform is applied relative to the pose's frame.\n"
"Note that this differs from Pose3d::RotateBy(const Rotation3d&), which is\n"
"applied relative to the global frame and around the origin.\n"
"\n"
":param other: The transform to transform the pose by.\n"
"\n"
":returns: The transformed pose.")
  )
  
  
  
    
  .
def
("relativeTo", &frc::Pose3d::RelativeTo,
      py::arg("other"), release_gil(), py::doc(
    "Returns the current pose relative to the given pose.\n"
"\n"
"This function can often be used for trajectory tracking or pose\n"
"stabilization algorithms to get the error between the reference and the\n"
"current pose.\n"
"\n"
":param other: The pose that is the origin of the new coordinate frame that\n"
"              the current pose will be converted into.\n"
"\n"
":returns: The current pose relative to the new origin pose.")
  )
  
  
  
    
  .
def
("exp", &frc::Pose3d::Exp,
      py::arg("twist"), release_gil(), py::doc(
    "Obtain a new Pose3d from a (constant curvature) velocity.\n"
"\n"
"The twist is a change in pose in the robot's coordinate frame since the\n"
"previous pose update. When the user runs exp() on the previous known\n"
"field-relative pose with the argument being the twist, the user will\n"
"receive the new field-relative pose.\n"
"\n"
"\"Exp\" represents the pose exponential, which is solving a differential\n"
"equation moving the pose forward in time.\n"
"\n"
":param twist: The change in pose in the robot's coordinate frame since the\n"
"              previous pose update. For example, if a non-holonomic robot moves forward\n"
"              0.01 meters and changes angle by 0.5 degrees since the previous pose\n"
"              update, the twist would be Twist3d{0.01_m, 0_m, 0_m, Rotation3d{0.0, 0.0,\n"
"              0.5_deg}}.\n"
"\n"
":returns: The new pose of the robot.")
  )
  
  
  
    
  .
def
("log", &frc::Pose3d::Log,
      py::arg("end"), release_gil(), py::doc(
    "Returns a Twist3d that maps this pose to the end pose. If c is the output\n"
"of a.Log(b), then a.Exp(c) would yield b.\n"
"\n"
":param end: The end pose for the transformation.\n"
"\n"
":returns: The twist that maps this to end.")
  )
  
  
  
    
  .
def
("toPose2d", &frc::Pose3d::ToPose2d, release_gil(), py::doc(
    "Returns a Pose2d representing this Pose3d projected into the X-Y plane.")
  )
  
  
  ;

  


  }







  cls_Pose3d
  .def_static("fromFeet", [](units::foot_t x, units::foot_t y, units::foot_t z, Rotation3d r) {
    return std::make_unique<Pose3d>(x, y, z, r);
  }, py::arg("x"), py::arg("y"), py::arg("z"), py::arg("r"))
  .def_property_readonly("x", &Pose3d::X)
  .def_property_readonly("y", &Pose3d::Y)
  .def_property_readonly("z", &Pose3d::Z)
  .def_property_readonly("x_feet", [](const Pose3d * self) -> units::foot_t {
    return self->X();
  })
  .def_property_readonly("y_feet", [](const Pose3d * self) -> units::foot_t {
    return self->Y();
  })
  .def_property_readonly("z_feet", [](const Pose3d * self) -> units::foot_t {
    return self->Z();
  })
  .def("__repr__", py::overload_cast<const Pose3d&>(&rpy::toString));

SetupWPyStruct<frc::Pose3d>(cls_Pose3d);


}

}; // struct rpybuild_Pose3d_initializer

static std::unique_ptr<rpybuild_Pose3d_initializer> cls;

void begin_init_Pose3d(py::module &m) {
  cls = std::make_unique<rpybuild_Pose3d_initializer>(m);
}

void finish_init_Pose3d() {
  cls->finish();
  cls.reset();
}