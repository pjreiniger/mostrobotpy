
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/geometry/Transform3d.h>


#include <units_length_type_caster.h>



#include <pybind11/operators.h>











#include <rpy/geometryToString.h>

#include <wpystruct.h>



#include <type_traits>


  using namespace frc;



struct rpybuild_Transform3d_initializer {


  

  












  py::class_<typename frc::Transform3d> cls_Transform3d;

    

    
    

  py::module &m;

  
  rpybuild_Transform3d_initializer(py::module &m) :

  

  

  

  
    cls_Transform3d(m, "Transform3d"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_Transform3d.doc() =
    "Represents a transformation for a Pose3d in the pose's frame.";

  cls_Transform3d
  
    
  .def(py::init<Pose3d, Pose3d>(),
      py::arg("initial"), py::arg("final"), release_gil(), py::doc(
    "Constructs the transform that maps the initial pose to the final pose.\n"
"\n"
":param initial: The initial pose for the transformation.\n"
":param final:   The final pose for the transformation.")
  )
  
  
  
    
  .def(py::init<Translation3d, Rotation3d>(),
      py::arg("translation"), py::arg("rotation"), release_gil(), py::doc(
    "Constructs a transform with the given translation and rotation components.\n"
"\n"
":param translation: Translational component of the transform.\n"
":param rotation:    Rotational component of the transform.")
  )
  
  
  
    
  .def(py::init<units::meter_t, units::meter_t, units::meter_t, Rotation3d>(),
      py::arg("x"), py::arg("y"), py::arg("z"), py::arg("rotation"), release_gil(), py::doc(
    "Constructs a transform with x, y, and z translations instead of a separate\n"
"Translation3d.\n"
"\n"
":param x:        The x component of the translational component of the transform.\n"
":param y:        The y component of the translational component of the transform.\n"
":param z:        The z component of the translational component of the transform.\n"
":param rotation: The rotational component of the transform.")
  )
  
  
  
    
  .def(py::init<>(), release_gil(), py::doc(
    "Constructs the identity transform -- maps an initial pose to itself.")
  )
  
  
  
    
  .
def
("translation", &frc::Transform3d::Translation, release_gil(), py::doc(
    "Returns the translation component of the transformation.\n"
"\n"
":returns: Reference to the translational component of the transform.")
  )
  
  
  
    
  .
def
("X", &frc::Transform3d::X, release_gil(), py::doc(
    "Returns the X component of the transformation's translation.\n"
"\n"
":returns: The x component of the transformation's translation.")
  )
  
  
  
    
  .
def
("Y", &frc::Transform3d::Y, release_gil(), py::doc(
    "Returns the Y component of the transformation's translation.\n"
"\n"
":returns: The y component of the transformation's translation.")
  )
  
  
  
    
  .
def
("Z", &frc::Transform3d::Z, release_gil(), py::doc(
    "Returns the Z component of the transformation's translation.\n"
"\n"
":returns: The z component of the transformation's translation.")
  )
  
  
  
    
  .
def
("rotation", &frc::Transform3d::Rotation, release_gil(), py::doc(
    "Returns the rotational component of the transformation.\n"
"\n"
":returns: Reference to the rotational component of the transform.")
  )
  
  
  
    
  .
def
("inverse", &frc::Transform3d::Inverse, release_gil(), py::doc(
    "Invert the transformation. This is useful for undoing a transformation.\n"
"\n"
":returns: The inverted transformation.")
  )
  
  
  
    
  .def(py::self * double(), py::doc(
    "Multiplies the transform by the scalar.\n"
"\n"
":param scalar: The scalar.\n"
"\n"
":returns: The scaled Transform3d.")
  )
  
  
  
    
  .def(py::self / double(), py::doc(
    "Divides the transform by the scalar.\n"
"\n"
":param scalar: The scalar.\n"
"\n"
":returns: The scaled Transform3d.")
  )
  
  
  
    
  .def(py::self + py::self, py::doc(
    "Composes two transformations. The second transform is applied relative to\n"
"the orientation of the first.\n"
"\n"
":param other: The transform to compose with this one.\n"
"\n"
":returns: The composition of the two transformations.")
  )
  
  
  
    
  .def(py::self == py::self, py::doc(
    "Checks equality between this Transform3d and another object.")
  )
  
  
  ;

  


  }







  cls_Transform3d
  .def_property_readonly("x", &Transform3d::X)
  .def_property_readonly("y", &Transform3d::Y)
  .def_property_readonly("z", &Transform3d::Z)
  .def_property_readonly("x_feet", [](const Transform3d * self) -> units::foot_t {
    return self->X();
  })
  .def_property_readonly("y_feet", [](const Transform3d * self) -> units::foot_t {
    return self->Y();
  })
  .def_property_readonly("z_feet", [](const Transform3d * self) -> units::foot_t {
    return self->Z();
  })
  .def("__repr__", py::overload_cast<const Transform3d&>(&rpy::toString));

SetupWPyStruct<frc::Transform3d>(cls_Transform3d);


}

}; // struct rpybuild_Transform3d_initializer

static std::unique_ptr<rpybuild_Transform3d_initializer> cls;

void begin_init_Transform3d(py::module &m) {
  cls = std::make_unique<rpybuild_Transform3d_initializer>(m);
}

void finish_init_Transform3d() {
  cls->finish();
  cls.reset();
}