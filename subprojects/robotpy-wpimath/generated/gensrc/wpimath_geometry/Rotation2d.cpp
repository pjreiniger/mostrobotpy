
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/geometry/Rotation2d.h>


#include <units_angle_type_caster.h>



#include <pybind11/operators.h>











#include <rpy/geometryToString.h>

#include <wpystruct.h>



#include <type_traits>


  using namespace frc;



struct rpybuild_Rotation2d_initializer {


  

  












  py::class_<typename frc::Rotation2d> cls_Rotation2d;

    

    
    

  py::module &m;

  
  rpybuild_Rotation2d_initializer(py::module &m) :

  

  

  

  
    cls_Rotation2d(m, "Rotation2d"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_Rotation2d.doc() =
    "A rotation in a 2D coordinate frame represented by a point on the unit circle\n"
"(cosine and sine).\n"
"\n"
"The angle is continuous, that is if a Rotation2d is constructed with 361\n"
"degrees, it will return 361 degrees. This allows algorithms that wouldn't\n"
"want to see a discontinuity in the rotations as it sweeps past from 360 to 0\n"
"on the second time around.";

  cls_Rotation2d
  
    
  .def(py::init<>(), release_gil(), py::doc(
    "Constructs a Rotation2d with a default angle of 0 degrees.")
  )
  
  
  
    
  .def(py::init<units::radian_t>(),
      py::arg("value"), release_gil(), py::doc(
    "Constructs a Rotation2d with the given radian value.\n"
":param value: The value of the angle in radians.\n")
  )
  
  
    
  
    
  .def(py::init<double, double>(),
      py::arg("x"), py::arg("y"), release_gil(), py::doc(
    "Constructs a Rotation2d with the given x and y (cosine and sine)\n"
"components. The x and y don't have to be normalized.\n"
"\n"
":param x: The x component or cosine of the rotation.\n"
":param y: The y component or sine of the rotation.")
  )
  
  
  
    
  .def(py::self + py::self, py::doc(
    "Adds two rotations together, with the result being bounded between -pi and\n"
"pi.\n"
"\n"
"For example, <code>Rotation2d{30_deg} + Rotation2d{60_deg}</code> equals\n"
"<code>Rotation2d{units::radian_t{std::numbers::pi/2.0}}</code>\n"
"\n"
":param other: The rotation to add.\n"
"\n"
":returns: The sum of the two rotations.")
  )
  
  
  
    
  .def(py::self - py::self, py::doc(
    "Subtracts the new rotation from the current rotation and returns the new\n"
"rotation.\n"
"\n"
"For example, <code>Rotation2d{10_deg} - Rotation2d{100_deg}</code> equals\n"
"<code>Rotation2d{units::radian_t{-std::numbers::pi/2.0}}</code>\n"
"\n"
":param other: The rotation to subtract.\n"
"\n"
":returns: The difference between the two rotations.")
  )
  
  
  
    
  .def(- py::self, py::doc(
    "Takes the inverse of the current rotation. This is simply the negative of\n"
"the current angular value.\n"
"\n"
":returns: The inverse of the current rotation.")
  )
  
  
  
    
  .def(py::self * double(), py::doc(
    "Multiplies the current rotation by a scalar.\n"
"\n"
":param scalar: The scalar.\n"
"\n"
":returns: The new scaled Rotation2d.")
  )
  
  
  
    
  .def(py::self / double(), py::doc(
    "Divides the current rotation by a scalar.\n"
"\n"
":param scalar: The scalar.\n"
"\n"
":returns: The new scaled Rotation2d.")
  )
  
  
  
    
  .def(py::self == py::self, py::doc(
    "Checks equality between this Rotation2d and another object.\n"
"\n"
":param other: The other object.\n"
"\n"
":returns: Whether the two objects are equal.")
  )
  
  
  
    
  .
def
("rotateBy", &frc::Rotation2d::RotateBy,
      py::arg("other"), release_gil(), py::doc(
    "Adds the new rotation to the current rotation using a rotation matrix.\n"
"\n"
"::\n"
"\n"
"  [cos_new]   [other.cos, -other.sin][cos]\n"
"  [sin_new] = [other.sin,  other.cos][sin]\n"
"  value_new = std::atan2(sin_new, cos_new)\n"
"\n"
":param other: The rotation to rotate by.\n"
"\n"
":returns: The new rotated Rotation2d.")
  )
  
  
  
    
  .
def
("radians", &frc::Rotation2d::Radians, release_gil(), py::doc(
    "Returns the radian value of the rotation.\n"
"\n"
":returns: The radian value of the rotation.\n"
"          @see AngleModulus to constrain the angle within (-pi, pi]")
  )
  
  
  
    
  .
def
("degrees", &frc::Rotation2d::Degrees, release_gil(), py::doc(
    "Returns the degree value of the rotation.\n"
"\n"
":returns: The degree value of the rotation.\n"
"          @see InputModulus to constrain the angle within (-180, 180]")
  )
  
  
  
    
  .
def
("cos", &frc::Rotation2d::Cos, release_gil(), py::doc(
    "Returns the cosine of the rotation.\n"
"\n"
":returns: The cosine of the rotation.")
  )
  
  
  
    
  .
def
("sin", &frc::Rotation2d::Sin, release_gil(), py::doc(
    "Returns the sine of the rotation.\n"
"\n"
":returns: The sine of the rotation.")
  )
  
  
  
    
  .
def
("tan", &frc::Rotation2d::Tan, release_gil(), py::doc(
    "Returns the tangent of the rotation.\n"
"\n"
":returns: The tangent of the rotation.")
  )
  
  
  ;

  


  }







  cls_Rotation2d
  .def_static("fromDegrees", [](units::degree_t value) {
    return std::make_unique<Rotation2d>(value);
  }, py::arg("value"))
  .def_static("fromRotations", [](units::turn_t value) {
    return std::make_unique<Rotation2d>(value);
  })
  .def("__repr__", py::overload_cast<const Rotation2d&>(&rpy::toString));

SetupWPyStruct<frc::Rotation2d>(cls_Rotation2d);


}

}; // struct rpybuild_Rotation2d_initializer

static std::unique_ptr<rpybuild_Rotation2d_initializer> cls;

void begin_init_Rotation2d(py::module &m) {
  cls = std::make_unique<rpybuild_Rotation2d_initializer>(m);
}

void finish_init_Rotation2d() {
  cls->finish();
  cls.reset();
}