
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/geometry/Quaternion.h>


#include <pybind11/eigen.h>



#include <pybind11/operators.h>











#include <rpy/geometryToString.h>

#include <wpystruct.h>



#include <type_traits>


  using namespace frc;





struct rpybuild_Quaternion_initializer {


  

  












  py::class_<typename frc::Quaternion> cls_Quaternion;

    

    
    

  py::module &m;

  
  rpybuild_Quaternion_initializer(py::module &m) :

  

  

  

  
    cls_Quaternion(m, "Quaternion"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_Quaternion.doc() =
    "Represents a quaternion.";

  cls_Quaternion
  
    
  .def(py::init<>(), release_gil(), py::doc(
    "Constructs a quaternion with a default angle of 0 degrees.")
  )
  
  
  
    
  .def(py::init<double, double, double, double>(),
      py::arg("w"), py::arg("x"), py::arg("y"), py::arg("z"), release_gil(), py::doc(
    "Constructs a quaternion with the given components.\n"
"\n"
":param w: W component of the quaternion.\n"
":param x: X component of the quaternion.\n"
":param y: Y component of the quaternion.\n"
":param z: Z component of the quaternion.")
  )
  
  
  
    
  .def(py::self + py::self, py::doc(
    "Adds with another quaternion.\n"
"\n"
":param other: the other quaternion")
  )
  
  
  
    
  .def(py::self - py::self, py::doc(
    "Subtracts another quaternion.\n"
"\n"
":param other: the other quaternion")
  )
  
  
  
    
  .def(py::self * double(), py::doc(
    "Multiples with a scalar value.\n"
"\n"
":param other: the scalar value")
  )
  
  
  
    
  .def(py::self / double(), py::doc(
    "Divides by a scalar value.\n"
"\n"
":param other: the scalar value")
  )
  
  
  
    
  .def(py::self * py::self, py::doc(
    "Multiply with another quaternion.\n"
"\n"
":param other: The other quaternion.")
  )
  
  
  
    
  .def(py::self == py::self, py::doc(
    "Checks equality between this Quaternion and another object.\n"
"\n"
":param other: The other object.\n"
"\n"
":returns: Whether the two objects are equal.")
  )
  
  
  
    
  .
def
("dot", &frc::Quaternion::Dot,
      py::arg("other"), release_gil(), py::doc(
    "Returns the elementwise product of two quaternions.")
  )
  
  
  
    
  .
def
("conjugate", &frc::Quaternion::Conjugate, release_gil(), py::doc(
    "Returns the conjugate of the quaternion.")
  )
  
  
  
    
  .
def
("inverse", &frc::Quaternion::Inverse, release_gil(), py::doc(
    "Returns the inverse of the quaternion.")
  )
  
  
  
    
  .
def
("normalize", &frc::Quaternion::Normalize, release_gil(), py::doc(
    "Normalizes the quaternion.")
  )
  
  
  
    
  .
def
("norm", &frc::Quaternion::Norm, release_gil(), py::doc(
    "Calculates the L2 norm of the quaternion.")
  )
  
  
  
    
  .
def
("pow", &frc::Quaternion::Pow,
      py::arg("t"), release_gil(), py::doc(
    "Calculates this quaternion raised to a power.\n"
"\n"
":param t: the power to raise this quaternion to.")
  )
  
  
  
    
  .
def
("exp", static_cast<Quaternion(frc::Quaternion::*)(const Quaternion&) const>(
        &frc::Quaternion::Exp),
      py::arg("other"), release_gil(), py::doc(
    "Matrix exponential of a quaternion.\n"
"\n"
":param other: the \"Twist\" that will be applied to this quaternion.")
  )
  
  
  
    
  .
def
("exp", static_cast<Quaternion(frc::Quaternion::*)() const>(
        &frc::Quaternion::Exp), release_gil(), py::doc(
    "Matrix exponential of a quaternion.\n"
"\n"
"source: wpimath/algorithms.md\n"
"\n"
"If this quaternion is in ùñòùñî(3) and you are looking for an element of\n"
"SO(3), use FromRotationVector")
  )
  
  
  
    
  .
def
("log", static_cast<Quaternion(frc::Quaternion::*)(const Quaternion&) const>(
        &frc::Quaternion::Log),
      py::arg("other"), release_gil(), py::doc(
    "Log operator of a quaternion.\n"
"\n"
":param other: The quaternion to map this quaternion onto")
  )
  
  
  
    
  .
def
("log", static_cast<Quaternion(frc::Quaternion::*)() const>(
        &frc::Quaternion::Log), release_gil(), py::doc(
    "Log operator of a quaternion.\n"
"\n"
"source:  wpimath/algorithms.md\n"
"\n"
"If this quaternion is in SO(3) and you are looking for an element of ùñòùñî(3),\n"
"use ToRotationVector")
  )
  
  
  
    
  .
def
("W", &frc::Quaternion::W, release_gil(), py::doc(
    "Returns W component of the quaternion.")
  )
  
  
  
    
  .
def
("X", &frc::Quaternion::X, release_gil(), py::doc(
    "Returns X component of the quaternion.")
  )
  
  
  
    
  .
def
("Y", &frc::Quaternion::Y, release_gil(), py::doc(
    "Returns Y component of the quaternion.")
  )
  
  
  
    
  .
def
("Z", &frc::Quaternion::Z, release_gil(), py::doc(
    "Returns Z component of the quaternion.")
  )
  
  
  
    
  .
def
("toRotationVector", &frc::Quaternion::ToRotationVector, release_gil(), py::doc(
    "Returns the rotation vector representation of this quaternion.\n"
"\n"
"This is also the log operator of SO(3).")
  )
  
  
  
    
  .
def_static
("fromRotationVector", &frc::Quaternion::FromRotationVector,
      py::arg("rvec"), release_gil(), py::doc(
    "Returns the quaternion representation of this rotation vector.\n"
"\n"
"This is also the exp operator of ùñòùñî(3).\n"
"\n"
"source: wpimath/algorithms.md")
  )
  
  
  ;

  


  }







  cls_Quaternion
  .def("__repr__", py::overload_cast<const Quaternion&>(&rpy::toString));

SetupWPyStruct<frc::Quaternion>(cls_Quaternion);


}

}; // struct rpybuild_Quaternion_initializer

static std::unique_ptr<rpybuild_Quaternion_initializer> cls;

void begin_init_Quaternion(py::module &m) {
  cls = std::make_unique<rpybuild_Quaternion_initializer>(m);
}

void finish_init_Quaternion() {
  cls->finish();
  cls.reset();
}