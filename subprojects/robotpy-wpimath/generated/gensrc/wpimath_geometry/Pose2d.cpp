
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/geometry/Pose2d.h>


#include <units_angle_type_caster.h>

#include <units_length_type_caster.h>

#include <wpi_span_type_caster.h>



#include <pybind11/operators.h>











#include <rpy/geometryToString.h>

#include <wpystruct.h>



#include <type_traits>


  using namespace frc;





struct rpybuild_Pose2d_initializer {


  

  












  py::class_<typename frc::Pose2d> cls_Pose2d;

    

    
    

  py::module &m;

  
  rpybuild_Pose2d_initializer(py::module &m) :

  

  

  

  
    cls_Pose2d(m, "Pose2d"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_Pose2d.doc() =
    "Represents a 2D pose containing translational and rotational elements.";

  cls_Pose2d
  
    
  .def(py::init<>(), release_gil(), py::doc(
    "Constructs a pose at the origin facing toward the positive X axis.")
  )
  
  
  
    
  .def(py::init<Translation2d, Rotation2d>(),
      py::arg("translation"), py::arg("rotation"), release_gil(), py::doc(
    "Constructs a pose with the specified translation and rotation.\n"
"\n"
":param translation: The translational component of the pose.\n"
":param rotation:    The rotational component of the pose.")
  )
  
  
  
    
  .def(py::init<units::meter_t, units::meter_t, Rotation2d>(),
      py::arg("x"), py::arg("y"), py::arg("rotation"), release_gil(), py::doc(
    "Constructs a pose with x and y translations instead of a separate\n"
"Translation2d.\n"
"\n"
":param x:        The x component of the translational component of the pose.\n"
":param y:        The y component of the translational component of the pose.\n"
":param rotation: The rotational component of the pose.")
  )
  
  
  
    
  .def(py::self + Transform2d(), py::doc(
    "Transforms the pose by the given transformation and returns the new\n"
"transformed pose.\n"
"\n"
"::\n"
"\n"
"  [x_new]    [cos, -sin, 0][transform.x]\n"
"  [y_new] += [sin,  cos, 0][transform.y]\n"
"  [t_new]    [  0,    0, 1][transform.t]\n"
"\n"
":param other: The transform to transform the pose by.\n"
"\n"
":returns: The transformed pose.")
  )
  
  
  
    
  .def(py::self - py::self, py::doc(
    "Returns the Transform2d that maps the one pose to another.\n"
"\n"
":param other: The initial pose of the transformation.\n"
"\n"
":returns: The transform that maps the other pose to the current pose.")
  )
  
  
  
    
  .def(py::self == py::self, py::doc(
    "Checks equality between this Pose2d and another object.")
  )
  
  
  
    
  .
def
("translation", &frc::Pose2d::Translation, release_gil(), py::doc(
    "Returns the underlying translation.\n"
"\n"
":returns: Reference to the translational component of the pose.")
  )
  
  
  
    
  .
def
("X", &frc::Pose2d::X, release_gil(), py::doc(
    "Returns the X component of the pose's translation.\n"
"\n"
":returns: The x component of the pose's translation.")
  )
  
  
  
    
  .
def
("Y", &frc::Pose2d::Y, release_gil(), py::doc(
    "Returns the Y component of the pose's translation.\n"
"\n"
":returns: The y component of the pose's translation.")
  )
  
  
  
    
  .
def
("rotation", &frc::Pose2d::Rotation, release_gil(), py::doc(
    "Returns the underlying rotation.\n"
"\n"
":returns: Reference to the rotational component of the pose.")
  )
  
  
  
    
  .def(py::self * double(), py::doc(
    "Multiplies the current pose by a scalar.\n"
"\n"
":param scalar: The scalar.\n"
"\n"
":returns: The new scaled Pose2d.")
  )
  
  
  
    
  .def(py::self / double(), py::doc(
    "Divides the current pose by a scalar.\n"
"\n"
":param scalar: The scalar.\n"
"\n"
":returns: The new scaled Pose2d.")
  )
  
  
  
    
  .
def
("rotateBy", &frc::Pose2d::RotateBy,
      py::arg("other"), release_gil(), py::doc(
    "Rotates the pose around the origin and returns the new pose.\n"
"\n"
":param other: The rotation to transform the pose by.\n"
"\n"
":returns: The rotated pose.")
  )
  
  
  
    
  .
def
("transformBy", &frc::Pose2d::TransformBy,
      py::arg("other"), release_gil(), py::doc(
    "Transforms the pose by the given transformation and returns the new pose.\n"
"See + operator for the matrix multiplication performed.\n"
"\n"
":param other: The transform to transform the pose by.\n"
"\n"
":returns: The transformed pose.")
  )
  
  
  
    
  .
def
("relativeTo", &frc::Pose2d::RelativeTo,
      py::arg("other"), release_gil(), py::doc(
    "Returns the current pose relative to the given pose.\n"
"\n"
"This function can often be used for trajectory tracking or pose\n"
"stabilization algorithms to get the error between the reference and the\n"
"current pose.\n"
"\n"
":param other: The pose that is the origin of the new coordinate frame that\n"
"              the current pose will be converted into.\n"
"\n"
":returns: The current pose relative to the new origin pose.")
  )
  
  
  
    
  .
def
("exp", &frc::Pose2d::Exp,
      py::arg("twist"), release_gil(), py::doc(
    "Obtain a new Pose2d from a (constant curvature) velocity.\n"
"\n"
"See https://file.tavsys.net/control/controls-engineering-in-frc.pdf section\n"
"10.2 \"Pose exponential\" for a derivation.\n"
"\n"
"The twist is a change in pose in the robot's coordinate frame since the\n"
"previous pose update. When the user runs exp() on the previous known\n"
"field-relative pose with the argument being the twist, the user will\n"
"receive the new field-relative pose.\n"
"\n"
"\"Exp\" represents the pose exponential, which is solving a differential\n"
"equation moving the pose forward in time.\n"
"\n"
":param twist: The change in pose in the robot's coordinate frame since the\n"
"              previous pose update. For example, if a non-holonomic robot moves forward\n"
"              0.01 meters and changes angle by 0.5 degrees since the previous pose\n"
"              update, the twist would be Twist2d{0.01_m, 0_m, 0.5_deg}.\n"
"\n"
":returns: The new pose of the robot.")
  )
  
  
  
    
  .
def
("log", &frc::Pose2d::Log,
      py::arg("end"), release_gil(), py::doc(
    "Returns a Twist2d that maps this pose to the end pose. If c is the output\n"
"of a.Log(b), then a.Exp(c) would yield b.\n"
"\n"
":param end: The end pose for the transformation.\n"
"\n"
":returns: The twist that maps this to end.")
  )
  
  
  
    
  .
def
("nearest", static_cast<Pose2d(frc::Pose2d::*)(std::span<const Pose2d>) const>(
        &frc::Pose2d::Nearest),
      py::arg("poses"), release_gil(), py::doc(
    "Returns the nearest Pose2d from a collection of poses\n"
"\n"
":param poses: The collection of poses.\n"
"\n"
":returns: The nearest Pose2d from the collection.")
  )
  
  
  ;

  


  }







  cls_Pose2d
  .def_static("fromFeet", [](units::foot_t x, units::foot_t y, Rotation2d r) {
    return std::make_unique<Pose2d>(x, y, r);
  }, py::arg("x"), py::arg("y"), py::arg("r"))
  .def_static("fromFeet", [](units::foot_t x, units::foot_t y, units::radian_t angle) {
    return std::make_unique<Pose2d>(x, y, Rotation2d(angle));
  }, py::arg("x"), py::arg("y"), py::arg("angle"))
  .def(py::init([](units::meter_t x, units::meter_t y, units::radian_t angle) {
    return std::make_unique<Pose2d>(x, y, angle);
  }), py::arg("x"), py::arg("y"), py::arg("angle"))
  .def_property_readonly("x", &Pose2d::X)
  .def_property_readonly("y", &Pose2d::Y)
  .def_property_readonly("x_feet", [](Pose2d * self) -> units::foot_t {
    return self->X();
  })
  .def_property_readonly("y_feet", [](Pose2d * self) -> units::foot_t {
    return self->Y();
  })
  .def("__repr__", py::overload_cast<const Pose2d&>(&rpy::toString));

SetupWPyStruct<frc::Pose2d>(cls_Pose2d);


}

}; // struct rpybuild_Pose2d_initializer

static std::unique_ptr<rpybuild_Pose2d_initializer> cls;

void begin_init_Pose2d(py::module &m) {
  cls = std::make_unique<rpybuild_Pose2d_initializer>(m);
}

void finish_init_Pose2d() {
  cls->finish();
  cls.reset();
}