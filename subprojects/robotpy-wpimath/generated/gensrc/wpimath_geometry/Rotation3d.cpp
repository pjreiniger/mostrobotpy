
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/geometry/Rotation3d.h>


#include <pybind11/eigen.h>

#include <units_angle_type_caster.h>



#include <pybind11/operators.h>











#include <rpy/geometryToString.h>

#include <wpystruct.h>



#include <type_traits>


  using namespace frc;



struct rpybuild_Rotation3d_initializer {


  

  












  py::class_<typename frc::Rotation3d> cls_Rotation3d;

    

    
    

  py::module &m;

  
  rpybuild_Rotation3d_initializer(py::module &m) :

  

  

  

  
    cls_Rotation3d(m, "Rotation3d"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_Rotation3d.doc() =
    "A rotation in a 3D coordinate frame represented by a quaternion.";

  cls_Rotation3d
  
    
  .def(py::init<>(), release_gil(), py::doc(
    "Constructs a Rotation3d representing no rotation.")
  )
  
  
  
    
  .def(py::init<const Quaternion&>(),
      py::arg("q"), release_gil()
    , py::keep_alive<1, 2>(), py::doc(
    "Constructs a Rotation3d from a quaternion.\n"
"\n"
":param q: The quaternion.")
  )
  
  
  
    
  .def(py::init<units::radian_t, units::radian_t, units::radian_t>(),
      py::arg("roll"), py::arg("pitch"), py::arg("yaw"), release_gil(), py::doc(
    "Constructs a Rotation3d from extrinsic roll, pitch, and yaw.\n"
"\n"
"Extrinsic rotations occur in that order around the axes in the fixed global\n"
"frame rather than the body frame.\n"
"\n"
"Angles are measured counterclockwise with the rotation axis pointing \"out\n"
"of the page\". If you point your right thumb along the positive axis\n"
"direction, your fingers curl in the direction of positive rotation.\n"
"\n"
":param roll:  The counterclockwise rotation angle around the X axis (roll).\n"
":param pitch: The counterclockwise rotation angle around the Y axis (pitch).\n"
":param yaw:   The counterclockwise rotation angle around the Z axis (yaw).")
  )
  
  
  
    
  .def(py::init<const Eigen::Vector3d&, units::radian_t>(),
      py::arg("axis"), py::arg("angle"), release_gil()
    , py::keep_alive<1, 2>(), py::doc(
    "Constructs a Rotation3d with the given axis-angle representation. The axis\n"
"doesn't have to be normalized.\n"
"\n"
":param axis:  The rotation axis.\n"
":param angle: The rotation around the axis.")
  )
  
  
  
    
  .def(py::init<const Eigen::Vector3d&>(),
      py::arg("rvec"), release_gil()
    , py::keep_alive<1, 2>(), py::doc(
    "Constructs a Rotation3d with the given rotation vector representation. This\n"
"representation is equivalent to axis-angle, where the normalized axis is\n"
"multiplied by the rotation around the axis in radians.\n"
"\n"
":param rvec: The rotation vector.")
  )
  
  
  
    
  .def(py::init<const Eigen::Matrix3d&>(),
      py::arg("rotationMatrix"), release_gil()
    , py::keep_alive<1, 2>(), py::doc(
    "Constructs a Rotation3d from a rotation matrix.\n"
"\n"
":param rotationMatrix: The rotation matrix.\n"
"                       @throws std::domain_error if the rotation matrix isn't special orthogonal.")
  )
  
  
  
    
  .def(py::init<const Eigen::Vector3d&, const Eigen::Vector3d&>(),
      py::arg("initial"), py::arg("final"), release_gil()
    , py::keep_alive<1, 2>()
    , py::keep_alive<1, 3>(), py::doc(
    "Constructs a Rotation3d that rotates the initial vector onto the final\n"
"vector.\n"
"\n"
"This is useful for turning a 3D vector (final) into an orientation relative\n"
"to a coordinate system vector (initial).\n"
"\n"
":param initial: The initial vector.\n"
":param final:   The final vector.")
  )
  
  
  
    
  .def(py::self + py::self, py::doc(
    "Adds two rotations together.\n"
"\n"
":param other: The rotation to add.\n"
"\n"
":returns: The sum of the two rotations.")
  )
  
  
  
    
  .def(py::self - py::self, py::doc(
    "Subtracts the new rotation from the current rotation and returns the new\n"
"rotation.\n"
"\n"
":param other: The rotation to subtract.\n"
"\n"
":returns: The difference between the two rotations.")
  )
  
  
  
    
  .def(- py::self, py::doc(
    "Takes the inverse of the current rotation.\n"
"\n"
":returns: The inverse of the current rotation.")
  )
  
  
  
    
  .def(py::self * double(), py::doc(
    "Multiplies the current rotation by a scalar.\n"
"\n"
":param scalar: The scalar.\n"
"\n"
":returns: The new scaled Rotation3d.")
  )
  
  
  
    
  .def(py::self / double(), py::doc(
    "Divides the current rotation by a scalar.\n"
"\n"
":param scalar: The scalar.\n"
"\n"
":returns: The new scaled Rotation3d.")
  )
  
  
  
    
  .def(py::self == py::self, py::doc(
    "Checks equality between this Rotation3d and another object.")
  )
  
  
  
    
  .
def
("rotateBy", &frc::Rotation3d::RotateBy,
      py::arg("other"), release_gil(), py::doc(
    "Adds the new rotation to the current rotation. The other rotation is\n"
"applied extrinsically, which means that it rotates around the global axes.\n"
"For example, Rotation3d{90_deg, 0, 0}.RotateBy(Rotation3d{0, 45_deg, 0})\n"
"rotates by 90 degrees around the +X axis and then by 45 degrees around the\n"
"global +Y axis. (This is equivalent to Rotation3d{90_deg, 45_deg, 0})\n"
"\n"
":param other: The extrinsic rotation to rotate by.\n"
"\n"
":returns: The new rotated Rotation3d.")
  )
  
  
  
    
  .
def
("getQuaternion", &frc::Rotation3d::GetQuaternion, release_gil(), py::doc(
    "Returns the quaternion representation of the Rotation3d.")
  )
  
  
  
    
  .
def
("X", &frc::Rotation3d::X, release_gil(), py::doc(
    "Returns the counterclockwise rotation angle around the X axis (roll).")
  )
  
  
  
    
  .
def
("Y", &frc::Rotation3d::Y, release_gil(), py::doc(
    "Returns the counterclockwise rotation angle around the Y axis (pitch).")
  )
  
  
  
    
  .
def
("Z", &frc::Rotation3d::Z, release_gil(), py::doc(
    "Returns the counterclockwise rotation angle around the Z axis (yaw).")
  )
  
  
  
    
  .
def
("axis", &frc::Rotation3d::Axis, release_gil(), py::doc(
    "Returns the axis in the axis-angle representation of this rotation.")
  )
  
  
  
    
  .
def
("angle", &frc::Rotation3d::Angle, release_gil(), py::doc(
    "Returns the angle in the axis-angle representation of this rotation.")
  )
  
  
  
    
  .
def
("toRotation2d", &frc::Rotation3d::ToRotation2d, release_gil(), py::doc(
    "Returns a Rotation2d representing this Rotation3d projected into the X-Y\n"
"plane.")
  )
  
  
  ;

  


  }







  cls_Rotation3d
  .def_static("fromDegrees", [](units::degree_t roll, units::degree_t pitch, units::degree_t yaw) {
    return std::make_unique<Rotation3d>(roll, pitch, yaw);
  }, py::arg("roll"), py::arg("pitch"), py::arg("yaw"))
  .def_property_readonly("x", &Rotation3d::X)
  .def_property_readonly("y", &Rotation3d::Y)
  .def_property_readonly("z", &Rotation3d::Z)
  .def_property_readonly("angle", &Rotation3d::Angle)
  .def_property_readonly("x_degrees", [](const Rotation3d * self) -> units::degree_t {
    return self->X();
  })
  .def_property_readonly("y_degrees", [](const Rotation3d * self) -> units::degree_t {
    return self->Y();
  })
  .def_property_readonly("z_degrees", [](const Rotation3d * self) -> units::degree_t {
    return self->Z();
  })
  .def_property_readonly("angle_degrees", [](const Rotation3d * self) -> units::degree_t {
    return self->Angle();
  })
  .def("__repr__", py::overload_cast<const Rotation3d&>(&rpy::toString));

SetupWPyStruct<frc::Rotation3d>(cls_Rotation3d);


}

}; // struct rpybuild_Rotation3d_initializer

static std::unique_ptr<rpybuild_Rotation3d_initializer> cls;

void begin_init_Rotation3d(py::module &m) {
  cls = std::make_unique<rpybuild_Rotation3d_initializer>(m);
}

void finish_init_Rotation3d() {
  cls->finish();
  cls.reset();
}