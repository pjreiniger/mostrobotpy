
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/geometry/Ellipse2d.h>


#include <units_length_type_caster.h>

#include <wpi_array_type_caster.h>



#include <pybind11/operators.h>











#include <rpy/geometryToString.h>

#include <wpystruct.h>



#include <type_traits>


  using namespace frc;



struct rpybuild_Ellipse2d_initializer {


  

  












  py::class_<typename frc::Ellipse2d> cls_Ellipse2d;

    

    
    

  py::module &m;

  
  rpybuild_Ellipse2d_initializer(py::module &m) :

  

  

  

  
    cls_Ellipse2d(m, "Ellipse2d"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_Ellipse2d.doc() =
    "Represents a 2d ellipse space containing translational, rotational, and\n"
"scaling components.";

  cls_Ellipse2d
  
    
  .def(py::init<const Pose2d&, units::meter_t, units::meter_t>(),
      py::arg("center"), py::arg("xSemiAxis"), py::arg("ySemiAxis"), release_gil()
    , py::keep_alive<1, 2>(), py::doc(
    "Constructs an ellipse around a center point and two semi-axes, a horizontal\n"
"and vertical one.\n"
"\n"
":param center:    The center of the ellipse.\n"
":param xSemiAxis: The x semi-axis.\n"
":param ySemiAxis: The y semi-axis.")
  )
  
  
  
    
  .def(py::init<const Translation2d&, double>(),
      py::arg("center"), py::arg("radius"), release_gil()
    , py::keep_alive<1, 2>(), py::doc(
    "Constructs a perfectly circular ellipse with the specified radius.\n"
"\n"
":param center: The center of the circle.\n"
":param radius: The radius of the circle.")
  )
  
  
  
    
  .
def
("center", &frc::Ellipse2d::Center, release_gil(), py::doc(
    "Returns the center of the ellipse.\n"
"\n"
":returns: The center of the ellipse.")
  )
  
  
  
    
  .
def
("rotation", &frc::Ellipse2d::Rotation, release_gil(), py::doc(
    "Returns the rotational component of the ellipse.\n"
"\n"
":returns: The rotational component of the ellipse.")
  )
  
  
  
    
  .
def
("focalPoints", &frc::Ellipse2d::FocalPoints, release_gil(), py::doc(
    "Returns the focal points of the ellipse. In a perfect circle, this will\n"
"always return the center.\n"
"\n"
":returns: The focal points.")
  )
  
  
  
    
  .
def
("transformBy", &frc::Ellipse2d::TransformBy,
      py::arg("other"), release_gil(), py::doc(
    "Transforms the center of the ellipse and returns the new ellipse.\n"
"\n"
":param other: The transform to transform by.\n"
"\n"
":returns: The transformed ellipse.")
  )
  
  
  
    
  .
def
("rotateBy", &frc::Ellipse2d::RotateBy,
      py::arg("other"), release_gil(), py::doc(
    "Rotates the center of the ellipse and returns the new ellipse.\n"
"\n"
":param other: The rotation to transform by.\n"
"\n"
":returns: The rotated ellipse.")
  )
  
  
  
    
  .
def
("intersects", &frc::Ellipse2d::Intersects,
      py::arg("point"), release_gil(), py::doc(
    "Checks if a point is intersected by this ellipse's circumference.\n"
"\n"
":param point: The point to check.\n"
"\n"
":returns: True, if this ellipse's circumference intersects the point.")
  )
  
  
  
    
  .
def
("contains", &frc::Ellipse2d::Contains,
      py::arg("point"), release_gil(), py::doc(
    "Checks if a point is contained within this ellipse. This is inclusive, if\n"
"the point lies on the circumference this will return ``true``.\n"
"\n"
":param point: The point to check.\n"
"\n"
":returns: True, if the point is within or on the ellipse.")
  )
  
  
  
    
  .
def
("distance", &frc::Ellipse2d::Distance,
      py::arg("point"), release_gil(), py::doc(
    "Returns the distance between the perimeter of the ellipse and the point.\n"
"\n"
":param point: The point to check.\n"
"\n"
":returns: The distance (0, if the point is contained by the ellipse)")
  )
  
  
  
    
  .
def
("findNearestPoint", &frc::Ellipse2d::FindNearestPoint,
      py::arg("point"), release_gil(), py::doc(
    "Returns the nearest point that is contained within the ellipse.\n"
"\n"
":param point: The point that this will find the nearest point to.\n"
"\n"
":returns: A new point that is nearest to ``point`` and contained in the\n"
"          ellipse.")
  )
  
  
  
    
  .def(py::self == py::self, py::doc(
    "Checks equality between this Ellipse2d and another object.\n"
"\n"
":param other: The other object.\n"
"\n"
":returns: Whether the two objects are equal.")
  )
  
  
  ;

  


  }







  cls_Ellipse2d
  .def_static("fromFeet", [](const Pose2d& center, units::foot_t xSemiAxis, units::foot_t ySemiAxis) {
    return std::make_unique<Ellipse2d>(center, xSemiAxis, ySemiAxis);
  }, py::arg("center"), py::arg("xSemiAxis"), py::arg("ySemiAxis"))
  .def_property_readonly("xsemiaxis", &Ellipse2d::XSemiAxis)
  .def_property_readonly("ysemiaxis", &Ellipse2d::YSemiAxis)
  .def_property_readonly("xsemiaxis_feet", [](Ellipse2d &self) -> units::foot_t {
    return self.XSemiAxis();
  })
  .def_property_readonly("ysemiaxis_feet", [](Ellipse2d &self) -> units::foot_t {
    return self.YSemiAxis();
  })
  .def("__repr__", py::overload_cast<const Ellipse2d&>(&rpy::toString));


SetupWPyStruct<frc::Ellipse2d>(cls_Ellipse2d);

}

}; // struct rpybuild_Ellipse2d_initializer

static std::unique_ptr<rpybuild_Ellipse2d_initializer> cls;

void begin_init_Ellipse2d(py::module &m) {
  cls = std::make_unique<rpybuild_Ellipse2d_initializer>(m);
}

void finish_init_Ellipse2d() {
  cls->finish();
  cls.reset();
}