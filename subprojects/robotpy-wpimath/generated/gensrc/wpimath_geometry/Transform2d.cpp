
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/geometry/Transform2d.h>


#include <units_angle_type_caster.h>

#include <units_length_type_caster.h>



#include <pybind11/operators.h>











#include <frc/geometry/Pose2d.h>

#include <rpy/geometryToString.h>

#include <wpystruct.h>



#include <type_traits>


  using namespace frc;



struct rpybuild_Transform2d_initializer {


  

  












  py::class_<typename frc::Transform2d> cls_Transform2d;

    

    
    

  py::module &m;

  
  rpybuild_Transform2d_initializer(py::module &m) :

  

  

  

  
    cls_Transform2d(m, "Transform2d"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_Transform2d.doc() =
    "Represents a transformation for a Pose2d in the pose's frame.";

  cls_Transform2d
  
    
  .def(py::init<Pose2d, Pose2d>(),
      py::arg("initial"), py::arg("final"), release_gil(), py::doc(
    "Constructs the transform that maps the initial pose to the final pose.\n"
"\n"
":param initial: The initial pose for the transformation.\n"
":param final:   The final pose for the transformation.")
  )
  
  
  
    
  .def(py::init<Translation2d, Rotation2d>(),
      py::arg("translation"), py::arg("rotation"), release_gil(), py::doc(
    "Constructs a transform with the given translation and rotation components.\n"
"\n"
":param translation: Translational component of the transform.\n"
":param rotation:    Rotational component of the transform.")
  )
  
  
  
    
  .def(py::init<units::meter_t, units::meter_t, Rotation2d>(),
      py::arg("x"), py::arg("y"), py::arg("rotation"), release_gil(), py::doc(
    "Constructs a transform with x and y translations instead of a separate\n"
"Translation2d.\n"
"\n"
":param x:        The x component of the translational component of the transform.\n"
":param y:        The y component of the translational component of the transform.\n"
":param rotation: The rotational component of the transform.")
  )
  
  
  
    
  .def(py::init<>(), release_gil(), py::doc(
    "Constructs the identity transform -- maps an initial pose to itself.")
  )
  
  
  
    
  .
def
("translation", &frc::Transform2d::Translation, release_gil(), py::doc(
    "Returns the translation component of the transformation.\n"
"\n"
":returns: Reference to the translational component of the transform.")
  )
  
  
  
    
  .
def
("X", &frc::Transform2d::X, release_gil(), py::doc(
    "Returns the X component of the transformation's translation.\n"
"\n"
":returns: The x component of the transformation's translation.")
  )
  
  
  
    
  .
def
("Y", &frc::Transform2d::Y, release_gil(), py::doc(
    "Returns the Y component of the transformation's translation.\n"
"\n"
":returns: The y component of the transformation's translation.")
  )
  
  
  
    
  .
def
("rotation", &frc::Transform2d::Rotation, release_gil(), py::doc(
    "Returns the rotational component of the transformation.\n"
"\n"
":returns: Reference to the rotational component of the transform.")
  )
  
  
  
    
  .
def
("inverse", &frc::Transform2d::Inverse, release_gil(), py::doc(
    "Invert the transformation. This is useful for undoing a transformation.\n"
"\n"
":returns: The inverted transformation.")
  )
  
  
  
    
  .def(py::self * double(), py::doc(
    "Multiplies the transform by the scalar.\n"
"\n"
":param scalar: The scalar.\n"
"\n"
":returns: The scaled Transform2d.")
  )
  
  
  
    
  .def(py::self / double(), py::doc(
    "Divides the transform by the scalar.\n"
"\n"
":param scalar: The scalar.\n"
"\n"
":returns: The scaled Transform2d.")
  )
  
  
  
    
  .def(py::self + py::self, py::doc(
    "Composes two transformations. The second transform is applied relative to\n"
"the orientation of the first.\n"
"\n"
":param other: The transform to compose with this one.\n"
"\n"
":returns: The composition of the two transformations.")
  )
  
  
  
    
  .def(py::self == py::self, py::doc(
    "Checks equality between this Transform2d and another object.")
  )
  
  
  ;

  


  }







  cls_Transform2d
  .def_static("fromFeet", [](units::foot_t x, units::foot_t y, units::radian_t angle){
    return std::make_unique<Transform2d>(Translation2d(x, y), Rotation2d(angle));
  }, py::arg("x"), py::arg("y"), py::arg("angle"))
  .def(py::init([](units::meter_t x, units::meter_t y, units::radian_t angle) {
    return std::make_unique<Transform2d>(Translation2d(x, y), Rotation2d(angle));
  }), py::arg("x"), py::arg("y"), py::arg("angle"))
  .def_property_readonly("x", &Transform2d::X)
  .def_property_readonly("y", &Transform2d::Y)
  .def_property_readonly("x_feet", [](Transform2d * self) -> units::foot_t {
    return self->X();
  })
  .def_property_readonly("y_feet", [](Transform2d * self) -> units::foot_t {
    return self->Y();
  })
  .def("__repr__", py::overload_cast<const Transform2d&>(&rpy::toString));
;

SetupWPyStruct<frc::Transform2d>(cls_Transform2d);


}

}; // struct rpybuild_Transform2d_initializer

static std::unique_ptr<rpybuild_Transform2d_initializer> cls;

void begin_init_Transform2d(py::module &m) {
  cls = std::make_unique<rpybuild_Transform2d_initializer>(m);
}

void finish_init_Transform2d() {
  cls->finish();
  cls.reset();
}