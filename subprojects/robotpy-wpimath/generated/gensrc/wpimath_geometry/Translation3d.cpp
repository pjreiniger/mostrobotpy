
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/geometry/Translation3d.h>


#include <pybind11/eigen.h>

#include <units_length_type_caster.h>



#include <pybind11/operators.h>











#include <rpy/geometryToString.h>

#include <wpystruct.h>

#include <pybind11/eigen.h>



#include <type_traits>


  using namespace frc;





struct rpybuild_Translation3d_initializer {


  

  












  py::class_<typename frc::Translation3d> cls_Translation3d;

    

    
    

  py::module &m;

  
  rpybuild_Translation3d_initializer(py::module &m) :

  

  

  

  
    cls_Translation3d(m, "Translation3d"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_Translation3d.doc() =
    "Represents a translation in 3D space.\n"
"This object can be used to represent a point or a vector.\n"
"\n"
"This assumes that you are using conventional mathematical axes. When the\n"
"robot is at the origin facing in the positive X direction, forward is\n"
"positive X, left is positive Y, and up is positive Z.";

  cls_Translation3d
  
    
  .def(py::init<>(), release_gil(), py::doc(
    "Constructs a Translation3d with X, Y, and Z components equal to zero.")
  )
  
  
  
    
  .def(py::init<units::meter_t, units::meter_t, units::meter_t>(),
      py::arg("x"), py::arg("y"), py::arg("z"), release_gil(), py::doc(
    "Constructs a Translation3d with the X, Y, and Z components equal to the\n"
"provided values.\n"
"\n"
":param x: The x component of the translation.\n"
":param y: The y component of the translation.\n"
":param z: The z component of the translation.")
  )
  
  
  
    
  .def(py::init<units::meter_t, const Rotation3d&>(),
      py::arg("distance"), py::arg("angle"), release_gil()
    , py::keep_alive<1, 3>(), py::doc(
    "Constructs a Translation3d with the provided distance and angle. This is\n"
"essentially converting from polar coordinates to Cartesian coordinates.\n"
"\n"
":param distance: The distance from the origin to the end of the translation.\n"
":param angle:    The angle between the x-axis and the translation vector.")
  )
  
  
  
    
  .def(py::init<const Eigen::Vector3d&>(),
      py::arg("vector"), release_gil()
    , py::keep_alive<1, 2>(), py::doc(
    "Constructs a Translation3d from the provided translation vector's X, Y, and\n"
"Z components. The values are assumed to be in meters.\n"
"\n"
":param vector: The translation vector to represent.")
  )
  
  
  
    
  .
def
("distance", &frc::Translation3d::Distance,
      py::arg("other"), release_gil(), py::doc(
    "Calculates the distance between two translations in 3D space.\n"
"\n"
"The distance between translations is defined as\n"
"√((x₂−x₁)²+(y₂−y₁)²+(z₂−z₁)²).\n"
"\n"
":param other: The translation to compute the distance to.\n"
"\n"
":returns: The distance between the two translations.")
  )
  
  
  
    
  .
def
("X", &frc::Translation3d::X, release_gil(), py::doc(
    "Returns the X component of the translation.\n"
"\n"
":returns: The Z component of the translation.")
  )
  
  
  
    
  .
def
("Y", &frc::Translation3d::Y, release_gil(), py::doc(
    "Returns the Y component of the translation.\n"
"\n"
":returns: The Y component of the translation.")
  )
  
  
  
    
  .
def
("Z", &frc::Translation3d::Z, release_gil(), py::doc(
    "Returns the Z component of the translation.\n"
"\n"
":returns: The Z component of the translation.")
  )
  
  
  
    
  .
def
("toVector", &frc::Translation3d::ToVector, release_gil(), py::doc(
    "Returns a vector representation of this translation.\n"
"\n"
":returns: A Vector representation of this translation.")
  )
  
  
  
    
  .
def
("norm", &frc::Translation3d::Norm, release_gil(), py::doc(
    "Returns the norm, or distance from the origin to the translation.\n"
"\n"
":returns: The norm of the translation.")
  )
  
  
  
    
  .
def
("rotateBy", &frc::Translation3d::RotateBy,
      py::arg("other"), release_gil(), py::doc(
    "Applies a rotation to the translation in 3D space.\n"
"\n"
"For example, rotating a Translation3d of &lt;2, 0, 0&gt; by 90 degrees\n"
"around the Z axis will return a Translation3d of &lt;0, 2, 0&gt;.\n"
"\n"
":param other: The rotation to rotate the translation by.\n"
"\n"
":returns: The new rotated translation.")
  )
  
  
  
    
  .
def
("toTranslation2d", &frc::Translation3d::ToTranslation2d, release_gil(), py::doc(
    "Returns a Translation2d representing this Translation3d projected into the\n"
"X-Y plane.")
  )
  
  
  
    
  .def(py::self + py::self, py::doc(
    "Returns the sum of two translations in 3D space.\n"
"\n"
"For example, Translation3d{1.0, 2.5, 3.5} + Translation3d{2.0, 5.5, 7.5} =\n"
"Translation3d{3.0, 8.0, 11.0}.\n"
"\n"
":param other: The translation to add.\n"
"\n"
":returns: The sum of the translations.")
  )
  
  
  
    
  .def(py::self - py::self, py::doc(
    "Returns the difference between two translations.\n"
"\n"
"For example, Translation3d{5.0, 4.0, 3.0} - Translation3d{1.0, 2.0, 3.0} =\n"
"Translation3d{4.0, 2.0, 0.0}.\n"
"\n"
":param other: The translation to subtract.\n"
"\n"
":returns: The difference between the two translations.")
  )
  
  
  
    
  .def(- py::self, py::doc(
    "Returns the inverse of the current translation. This is equivalent to\n"
"negating all components of the translation.\n"
"\n"
":returns: The inverse of the current translation.")
  )
  
  
  
    
  .def(py::self * double(), py::doc(
    "Returns the translation multiplied by a scalar.\n"
"\n"
"For example, Translation3d{2.0, 2.5, 4.5} * 2 = Translation3d{4.0, 5.0,\n"
"9.0}.\n"
"\n"
":param scalar: The scalar to multiply by.\n"
"\n"
":returns: The scaled translation.")
  )
  
  
  
    
  .def(py::self / double(), py::doc(
    "Returns the translation divided by a scalar.\n"
"\n"
"For example, Translation3d{2.0, 2.5, 4.5} / 2 = Translation3d{1.0, 1.25,\n"
"2.25}.\n"
"\n"
":param scalar: The scalar to divide by.\n"
"\n"
":returns: The scaled translation.")
  )
  
  
  
    
  .def(py::self == py::self, py::doc(
    "Checks equality between this Translation3d and another object.\n"
"\n"
":param other: The other object.\n"
"\n"
":returns: Whether the two objects are equal.")
  )
  
  
  ;

  


  }







  cls_Translation3d
  .def_static("fromFeet", [](units::foot_t x, units::foot_t y, units::foot_t z){
    return std::make_unique<Translation3d>(x, y, z);
  }, py::arg("x"), py::arg("y"), py::arg("z"))
  .def_property_readonly("x", &Translation3d::X)
  .def_property_readonly("y", &Translation3d::Y)
  .def_property_readonly("z", &Translation3d::Z)
  .def_property_readonly("x_feet", [](const Translation3d * self) -> units::foot_t {
    return self->X();
  })
  .def_property_readonly("y_feet", [](const Translation3d * self) -> units::foot_t {
    return self->Y();
  })
  .def_property_readonly("z_feet", [](const Translation3d * self) -> units::foot_t {
    return self->Z();
  })
  .def("distanceFeet", [](Translation3d * self, const Translation3d &other) -> units::foot_t {
    return self->Distance(other);
  })
  .def("normFeet", [](const Translation3d * self) -> units::foot_t {
    return self->Norm();
  })
  .def("__abs__", &Translation3d::Norm)
  .def("__len__", [](const Translation3d& self) { return 3; })
  .def("__getitem__", [](const Translation3d& self, int index) {
    switch (index) {
      case 0:
        return self.X();
      case 1:
        return self.Y();
      case 2:
        return self.Z();
      default:
        throw std::out_of_range("Translation3d index out of range");
    }
  })
  .def("__repr__", py::overload_cast<const Translation3d&>(&rpy::toString));

SetupWPyStruct<frc::Translation3d>(cls_Translation3d);


}

}; // struct rpybuild_Translation3d_initializer

static std::unique_ptr<rpybuild_Translation3d_initializer> cls;

void begin_init_Translation3d(py::module &m) {
  cls = std::make_unique<rpybuild_Translation3d_initializer>(m);
}

void finish_init_Translation3d() {
  cls->finish();
  cls.reset();
}