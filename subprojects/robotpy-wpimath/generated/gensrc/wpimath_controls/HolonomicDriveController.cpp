
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/controller/HolonomicDriveController.h>


#include <units_angle_type_caster.h>

#include <units_velocity_type_caster.h>















#include <type_traits>


  using namespace frc;





struct rpybuild_HolonomicDriveController_initializer {


  

  




  py::module pkg_controller;









  py::class_<typename frc::HolonomicDriveController> cls_HolonomicDriveController;

    

    
    

  py::module &m;

  
  rpybuild_HolonomicDriveController_initializer(py::module &m) :

  
    pkg_controller(m.def_submodule("controller")),
  

  

  

  
    cls_HolonomicDriveController(pkg_controller, "HolonomicDriveController"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_HolonomicDriveController.doc() =
    "This holonomic drive controller can be used to follow trajectories using a\n"
"holonomic drivetrain (i.e. swerve or mecanum). Holonomic trajectory following\n"
"is a much simpler problem to solve compared to skid-steer style drivetrains\n"
"because it is possible to individually control forward, sideways, and angular\n"
"velocity.\n"
"\n"
"The holonomic drive controller takes in one PID controller for each\n"
"direction, forward and sideways, and one profiled PID controller for the\n"
"angular direction. Because the heading dynamics are decoupled from\n"
"translations, users can specify a custom heading that the drivetrain should\n"
"point toward. This heading reference is profiled for smoothness.";

  cls_HolonomicDriveController
  
    
  .def(py::init<PIDController, PIDController, ProfiledPIDController<units::radian>>(),
      py::arg("xController"), py::arg("yController"), py::arg("thetaController"), release_gil(), py::doc(
    "Constructs a holonomic drive controller.\n"
"\n"
":param xController:     A PID Controller to respond to error in the\n"
"                        field-relative x direction.\n"
":param yController:     A PID Controller to respond to error in the\n"
"                        field-relative y direction.\n"
":param thetaController: A profiled PID controller to respond to error in\n"
"                        angle.")
  )
  
  
  
    
  .
def
("atReference", &frc::HolonomicDriveController::AtReference, release_gil(), py::doc(
    "Returns true if the pose error is within tolerance of the reference.")
  )
  
  
  
    
  .
def
("setTolerance", &frc::HolonomicDriveController::SetTolerance,
      py::arg("tolerance"), release_gil(), py::doc(
    "Sets the pose error which is considered tolerable for use with\n"
"AtReference().\n"
"\n"
":param tolerance: Pose error which is tolerable.")
  )
  
  
  
    
  .
def
("calculate", static_cast<ChassisSpeeds(frc::HolonomicDriveController::*)(const Pose2d&, const Pose2d&, units::meters_per_second_t, const Rotation2d&)>(
        &frc::HolonomicDriveController::Calculate),
      py::arg("currentPose"), py::arg("trajectoryPose"), py::arg("desiredLinearVelocity"), py::arg("desiredHeading"), release_gil(), py::doc(
    "Returns the next output of the holonomic drive controller.\n"
"\n"
":param currentPose:           The current pose, as measured by odometry or pose\n"
"                              estimator.\n"
":param trajectoryPose:        The desired trajectory pose, as sampled for the\n"
"                              current timestep.\n"
":param desiredLinearVelocity: The desired linear velocity.\n"
":param desiredHeading:        The desired heading.\n"
"\n"
":returns: The next output of the holonomic drive controller.")
  )
  
  
  
    
  .
def
("calculate", static_cast<ChassisSpeeds(frc::HolonomicDriveController::*)(const Pose2d&, const Trajectory::State&, const Rotation2d&)>(
        &frc::HolonomicDriveController::Calculate),
      py::arg("currentPose"), py::arg("desiredState"), py::arg("desiredHeading"), release_gil(), py::doc(
    "Returns the next output of the holonomic drive controller.\n"
"\n"
":param currentPose:    The current pose, as measured by odometry or pose\n"
"                       estimator.\n"
":param desiredState:   The desired trajectory pose, as sampled for the current\n"
"                       timestep.\n"
":param desiredHeading: The desired heading.\n"
"\n"
":returns: The next output of the holonomic drive controller.")
  )
  
  
  
    
  .
def
("setEnabled", &frc::HolonomicDriveController::SetEnabled,
      py::arg("enabled"), release_gil(), py::doc(
    "Enables and disables the controller for troubleshooting purposes. When\n"
"Calculate() is called on a disabled controller, only feedforward values\n"
"are returned.\n"
"\n"
":param enabled: If the controller is enabled or not.")
  )
  
  
  
    
  .
def
("getThetaController", &frc::HolonomicDriveController::getThetaController, release_gil(), py::doc(
    "Returns the rotation ProfiledPIDController")
  )
  
  
  
    
  .
def
("getXController", &frc::HolonomicDriveController::getXController, release_gil(), py::doc(
    "Returns the X PIDController")
  )
  
  
  
    
  .
def
("getYController", &frc::HolonomicDriveController::getYController, release_gil(), py::doc(
    "Returns the Y PIDController")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_HolonomicDriveController_initializer

static std::unique_ptr<rpybuild_HolonomicDriveController_initializer> cls;

void begin_init_HolonomicDriveController(py::module &m) {
  cls = std::make_unique<rpybuild_HolonomicDriveController_initializer>(m);
}

void finish_init_HolonomicDriveController() {
  cls->finish();
  cls.reset();
}