
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/trajectory/constraint/DifferentialDriveKinematicsConstraint.h>


#include <units_compound_type_caster.h>

#include <units_velocity_type_caster.h>







#define RPYGEN_ENABLE_frc__DifferentialDriveKinematicsConstraint_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__DifferentialDriveKinematicsConstraint.hpp>









#include <type_traits>


  using namespace frc;



struct rpybuild_DifferentialDriveKinematicsConstraint_initializer {


  
    using MinMax = frc::TrajectoryConstraint::MinMax;
  

  




  py::module pkg_constraint;









  
  using DifferentialDriveKinematicsConstraint_Trampoline = rpygen::PyTrampoline_frc__DifferentialDriveKinematicsConstraint<typename frc::DifferentialDriveKinematicsConstraint, typename rpygen::PyTrampolineCfg_frc__DifferentialDriveKinematicsConstraint<>>;
    static_assert(std::is_abstract<DifferentialDriveKinematicsConstraint_Trampoline>::value == false, "frc::DifferentialDriveKinematicsConstraint " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::DifferentialDriveKinematicsConstraint, DifferentialDriveKinematicsConstraint_Trampoline, frc::TrajectoryConstraint> cls_DifferentialDriveKinematicsConstraint;

    

    
    

  py::module &m;

  
  rpybuild_DifferentialDriveKinematicsConstraint_initializer(py::module &m) :

  
    pkg_constraint(m.def_submodule("constraint")),
  

  

  

  
    cls_DifferentialDriveKinematicsConstraint(pkg_constraint, "DifferentialDriveKinematicsConstraint"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_DifferentialDriveKinematicsConstraint.doc() =
    "A class that enforces constraints on the differential drive kinematics.\n"
"This can be used to ensure that the trajectory is constructed so that the\n"
"commanded velocities for both sides of the drivetrain stay below a certain\n"
"limit.";

  cls_DifferentialDriveKinematicsConstraint
  
    
  .def(py::init<DifferentialDriveKinematics, units::meters_per_second_t>(),
      py::arg("kinematics"), py::arg("maxSpeed"), release_gil()
  )
  
  
  
    
  .
def
("maxVelocity", &frc::DifferentialDriveKinematicsConstraint::MaxVelocity,
      py::arg("pose"), py::arg("curvature"), py::arg("velocity"), release_gil()
  )
  
  
  
    
  .
def
("minMaxAcceleration", &frc::DifferentialDriveKinematicsConstraint::MinMaxAcceleration,
      py::arg("pose"), py::arg("curvature"), py::arg("speed"), release_gil()
  )
  
  
  ;

  


  }







  cls_DifferentialDriveKinematicsConstraint
  .def_static("fromFps", [](const DifferentialDriveKinematics& kinematics,
                            units::feet_per_second_t maxSpeed) {
    return std::make_shared<DifferentialDriveKinematicsConstraint>(kinematics, maxSpeed);
  }, py::arg("kinematics"), py::arg("maxSpeed"))
;

}

}; // struct rpybuild_DifferentialDriveKinematicsConstraint_initializer

static std::unique_ptr<rpybuild_DifferentialDriveKinematicsConstraint_initializer> cls;

void begin_init_DifferentialDriveKinematicsConstraint(py::module &m) {
  cls = std::make_unique<rpybuild_DifferentialDriveKinematicsConstraint_initializer>(m);
}

void finish_init_DifferentialDriveKinematicsConstraint() {
  cls->finish();
  cls.reset();
}