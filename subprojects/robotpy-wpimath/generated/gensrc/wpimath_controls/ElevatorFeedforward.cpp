
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/controller/ElevatorFeedforward.h>


#include <units_acceleration_type_caster.h>

#include <units_compound_type_caster.h>

#include <units_length_type_caster.h>

#include <units_time_type_caster.h>

#include <units_velocity_type_caster.h>

#include <units_voltage_type_caster.h>













#include <wpystruct.h>



#include <type_traits>


  using namespace frc;





struct rpybuild_ElevatorFeedforward_initializer {


  

  




  py::module pkg_controller;









  py::class_<typename frc::ElevatorFeedforward> cls_ElevatorFeedforward;

    

    
    

  py::module &m;

  
  rpybuild_ElevatorFeedforward_initializer(py::module &m) :

  
    pkg_controller(m.def_submodule("controller")),
  

  

  

  
    cls_ElevatorFeedforward(pkg_controller, "ElevatorFeedforward"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  
    using Distance [[maybe_unused]] = typename frc::ElevatorFeedforward::Distance;
  
    using Velocity [[maybe_unused]] = typename frc::ElevatorFeedforward::Velocity;
  
    using Acceleration [[maybe_unused]] = typename frc::ElevatorFeedforward::Acceleration;
  
    using kv_unit [[maybe_unused]] = typename frc::ElevatorFeedforward::kv_unit;
  
    using ka_unit [[maybe_unused]] = typename frc::ElevatorFeedforward::ka_unit;
  


  

  cls_ElevatorFeedforward.doc() =
    "A helper class that computes feedforward outputs for a simple elevator\n"
"(modeled as a motor acting against the force of gravity).";

  cls_ElevatorFeedforward
  
    
  .def(py::init<units::volt_t, units::volt_t, units::unit_t<kv_unit>, units::unit_t<ka_unit>>(),
      py::arg("kS"), py::arg("kG"), py::arg("kV"), py::arg("kA") = units::unit_t<ka_unit> (0), release_gil(), py::doc(
    "Creates a new ElevatorFeedforward with the specified gains.\n"
"\n"
":param kS: The static gain, in volts.\n"
":param kG: The gravity gain, in volts.\n"
":param kV: The velocity gain, in volt seconds per distance.\n"
":param kA: The acceleration gain, in volt seconds² per distance.")
  )
  
  
  
    
  .
def
("calculate", static_cast<units::volt_t(frc::ElevatorFeedforward::*)(units::unit_t<Velocity>, units::unit_t<Acceleration>)>(
        &frc::ElevatorFeedforward::Calculate),
      py::arg("velocity"), py::arg("acceleration") = units::unit_t<Acceleration> (0), release_gil(), py::doc(
    "Calculates the feedforward from the gains and setpoints.\n"
"\n"
":param velocity:     The velocity setpoint, in distance per second.\n"
":param acceleration: The acceleration setpoint, in distance per second².\n"
"\n"
":returns: The computed feedforward, in volts.")
  )
  
  
  
    
  .
def
("calculate", static_cast<units::volt_t(frc::ElevatorFeedforward::*)(units::unit_t<Velocity>, units::unit_t<Velocity>, units::second_t) const>(
        &frc::ElevatorFeedforward::Calculate),
      py::arg("currentVelocity"), py::arg("nextVelocity"), py::arg("dt"), release_gil(), py::doc(
    "Calculates the feedforward from the gains and setpoints.\n"
"\n"
":param currentVelocity: The current velocity setpoint, in distance per\n"
"                        second.\n"
":param nextVelocity:    The next velocity setpoint, in distance per second.\n"
":param dt:              Time between velocity setpoints in seconds.\n"
"\n"
":returns: The computed feedforward, in volts.")
  )
  
  
  
    
  .
def
("maxAchievableVelocity", &frc::ElevatorFeedforward::MaxAchievableVelocity,
      py::arg("maxVoltage"), py::arg("acceleration"), release_gil(), py::doc(
    "Calculates the maximum achievable velocity given a maximum voltage supply\n"
"and an acceleration.  Useful for ensuring that velocity and\n"
"acceleration constraints for a trapezoidal profile are simultaneously\n"
"achievable - enter the acceleration constraint, and this will give you\n"
"a simultaneously-achievable velocity constraint.\n"
"\n"
":param maxVoltage:   The maximum voltage that can be supplied to the elevator.\n"
":param acceleration: The acceleration of the elevator.\n"
"\n"
":returns: The maximum possible velocity at the given acceleration.")
  )
  
  
  
    
  .
def
("minAchievableVelocity", &frc::ElevatorFeedforward::MinAchievableVelocity,
      py::arg("maxVoltage"), py::arg("acceleration"), release_gil(), py::doc(
    "Calculates the minimum achievable velocity given a maximum voltage supply\n"
"and an acceleration.  Useful for ensuring that velocity and\n"
"acceleration constraints for a trapezoidal profile are simultaneously\n"
"achievable - enter the acceleration constraint, and this will give you\n"
"a simultaneously-achievable velocity constraint.\n"
"\n"
":param maxVoltage:   The maximum voltage that can be supplied to the elevator.\n"
":param acceleration: The acceleration of the elevator.\n"
"\n"
":returns: The minimum possible velocity at the given acceleration.")
  )
  
  
  
    
  .
def
("maxAchievableAcceleration", &frc::ElevatorFeedforward::MaxAchievableAcceleration,
      py::arg("maxVoltage"), py::arg("velocity"), release_gil(), py::doc(
    "Calculates the maximum achievable acceleration given a maximum voltage\n"
"supply and a velocity. Useful for ensuring that velocity and\n"
"acceleration constraints for a trapezoidal profile are simultaneously\n"
"achievable - enter the velocity constraint, and this will give you\n"
"a simultaneously-achievable acceleration constraint.\n"
"\n"
":param maxVoltage: The maximum voltage that can be supplied to the elevator.\n"
":param velocity:   The velocity of the elevator.\n"
"\n"
":returns: The maximum possible acceleration at the given velocity.")
  )
  
  
  
    
  .
def
("minAchievableAcceleration", &frc::ElevatorFeedforward::MinAchievableAcceleration,
      py::arg("maxVoltage"), py::arg("velocity"), release_gil(), py::doc(
    "Calculates the minimum achievable acceleration given a maximum voltage\n"
"supply and a velocity. Useful for ensuring that velocity and\n"
"acceleration constraints for a trapezoidal profile are simultaneously\n"
"achievable - enter the velocity constraint, and this will give you\n"
"a simultaneously-achievable acceleration constraint.\n"
"\n"
":param maxVoltage: The maximum voltage that can be supplied to the elevator.\n"
":param velocity:   The velocity of the elevator.\n"
"\n"
":returns: The minimum possible acceleration at the given velocity.")
  )
  
  
  
    .def_readonly("kS", &frc::ElevatorFeedforward::kS, py::doc(
    "The static gain."))
  
    .def_readonly("kG", &frc::ElevatorFeedforward::kG, py::doc(
    "The gravity gain."))
  
    .def_readonly("kV", &frc::ElevatorFeedforward::kV, py::doc(
    "The velocity gain."))
  
    .def_readonly("kA", &frc::ElevatorFeedforward::kA, py::doc(
    "The acceleration gain."))
  ;

  


  }







  SetupWPyStruct<frc::ElevatorFeedforward>(cls_ElevatorFeedforward);


}

}; // struct rpybuild_ElevatorFeedforward_initializer

static std::unique_ptr<rpybuild_ElevatorFeedforward_initializer> cls;

void begin_init_ElevatorFeedforward(py::module &m) {
  cls = std::make_unique<rpybuild_ElevatorFeedforward_initializer>(m);
}

void finish_init_ElevatorFeedforward() {
  cls->finish();
  cls.reset();
}