
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/controller/ElevatorFeedforward.h>


#include <units_acceleration_type_caster.h>

#include <units_compound_type_caster.h>

#include <units_length_type_caster.h>

#include <units_time_type_caster.h>

#include <units_velocity_type_caster.h>

#include <units_voltage_type_caster.h>













#include <wpystruct.h>



#include <type_traits>


  using namespace frc;



struct rpybuild_ElevatorFeedforward_initializer {


  

  




  py::module pkg_controller;









  py::class_<typename frc::ElevatorFeedforward> cls_ElevatorFeedforward;

    

    
    

  py::module &m;

  
  rpybuild_ElevatorFeedforward_initializer(py::module &m) :

  
    pkg_controller(m.def_submodule("controller")),
  

  

  

  
    cls_ElevatorFeedforward(pkg_controller, "ElevatorFeedforward"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  
    using Distance [[maybe_unused]] = typename frc::ElevatorFeedforward::Distance;
  
    using Velocity [[maybe_unused]] = typename frc::ElevatorFeedforward::Velocity;
  
    using Acceleration [[maybe_unused]] = typename frc::ElevatorFeedforward::Acceleration;
  
    using kv_unit [[maybe_unused]] = typename frc::ElevatorFeedforward::kv_unit;
  
    using ka_unit [[maybe_unused]] = typename frc::ElevatorFeedforward::ka_unit;
  


  

  cls_ElevatorFeedforward.doc() =
    "A helper class that computes feedforward outputs for a simple elevator\n"
"(modeled as a motor acting against the force of gravity).";

  cls_ElevatorFeedforward
  
    
  .def(py::init<units::volt_t, units::volt_t, units::unit_t<kv_unit>, units::unit_t<ka_unit>, units::second_t>(),
      py::arg("kS"), py::arg("kG"), py::arg("kV"), py::arg("kA") = units::unit_t<ka_unit> (0), py::arg("dt") = (units::second_t)20_ms, release_gil(), py::doc(
    "Creates a new ElevatorFeedforward with the specified gains.\n"
"\n"
":param kS: The static gain, in volts.\n"
":param kG: The gravity gain, in volts.\n"
":param kV: The velocity gain, in volt seconds per distance.\n"
":param kA: The acceleration gain, in volt secondsÂ² per distance.\n"
":param dt: The period in seconds.\n"
"           @throws IllegalArgumentException for kv &lt; zero.\n"
"           @throws IllegalArgumentException for ka &lt; zero.\n"
"           @throws IllegalArgumentException for period &le; zero.")
  )
  
  
  
    
  .
def
("calculate", static_cast<units::volt_t(frc::ElevatorFeedforward::*)(units::unit_t<Velocity>, units::unit_t<Acceleration>) const>(
        &frc::ElevatorFeedforward::Calculate),
      py::arg("velocity"), py::arg("acceleration"), release_gil(), py::doc(
    "Calculates the feedforward from the gains and setpoints assuming continuous\n"
"control.\n"
"\n"
":deprecated: Use the current/next velocity overload instead.\n"
"\n"
":param velocity:     The velocity setpoint.\n"
":param acceleration: The acceleration setpoint.\n"
"\n"
":returns: The computed feedforward, in volts.")
  )
  
  
  
    
  .
def
("calculate", static_cast<units::volt_t(frc::ElevatorFeedforward::*)(units::unit_t<Velocity>, units::unit_t<Velocity>, units::second_t) const>(
        &frc::ElevatorFeedforward::Calculate),
      py::arg("currentVelocity"), py::arg("nextVelocity"), py::arg("dt"), release_gil(), py::doc(
    "Calculates the feedforward from the gains and setpoints assuming continuous\n"
"control.\n"
"\n"
":param currentVelocity: The current velocity setpoint.\n"
":param nextVelocity:    The next velocity setpoint.\n"
":param dt:              Time between velocity setpoints in seconds.\n"
"\n"
":returns: The computed feedforward, in volts.")
  )
  
  
  
    
  .
def
("calculate", static_cast<units::volt_t(frc::ElevatorFeedforward::*)(units::unit_t<Velocity>) const>(
        &frc::ElevatorFeedforward::Calculate),
      py::arg("currentVelocity"), release_gil(), py::doc(
    "Calculates the feedforward from the gains and setpoint assuming discrete\n"
"control. Use this method when the setpoint does not change.\n"
"\n"
":param currentVelocity: The velocity setpoint.\n"
"\n"
":returns: The computed feedforward, in volts.")
  )
  
  
  
    
  .
def
("calculate", static_cast<units::volt_t(frc::ElevatorFeedforward::*)(units::unit_t<Velocity>, units::unit_t<Velocity>) const>(
        &frc::ElevatorFeedforward::Calculate),
      py::arg("currentVelocity"), py::arg("nextVelocity"), release_gil(), py::doc(
    "Calculates the feedforward from the gains and setpoints assuming discrete\n"
"control.\n"
"\n"
"Note this method is inaccurate when the velocity crosses 0.\n"
"\n"
":param currentVelocity: The current velocity setpoint.\n"
":param nextVelocity:    The next velocity setpoint.\n"
"\n"
":returns: The computed feedforward, in volts.")
  )
  
  
  
    
  .
def
("maxAchievableVelocity", &frc::ElevatorFeedforward::MaxAchievableVelocity,
      py::arg("maxVoltage"), py::arg("acceleration"), release_gil(), py::doc(
    "Calculates the maximum achievable velocity given a maximum voltage supply\n"
"and an acceleration.  Useful for ensuring that velocity and\n"
"acceleration constraints for a trapezoidal profile are simultaneously\n"
"achievable - enter the acceleration constraint, and this will give you\n"
"a simultaneously-achievable velocity constraint.\n"
"\n"
":param maxVoltage:   The maximum voltage that can be supplied to the elevator.\n"
":param acceleration: The acceleration of the elevator.\n"
"\n"
":returns: The maximum possible velocity at the given acceleration.")
  )
  
  
  
    
  .
def
("minAchievableVelocity", &frc::ElevatorFeedforward::MinAchievableVelocity,
      py::arg("maxVoltage"), py::arg("acceleration"), release_gil(), py::doc(
    "Calculates the minimum achievable velocity given a maximum voltage supply\n"
"and an acceleration.  Useful for ensuring that velocity and\n"
"acceleration constraints for a trapezoidal profile are simultaneously\n"
"achievable - enter the acceleration constraint, and this will give you\n"
"a simultaneously-achievable velocity constraint.\n"
"\n"
":param maxVoltage:   The maximum voltage that can be supplied to the elevator.\n"
":param acceleration: The acceleration of the elevator.\n"
"\n"
":returns: The minimum possible velocity at the given acceleration.")
  )
  
  
  
    
  .
def
("maxAchievableAcceleration", &frc::ElevatorFeedforward::MaxAchievableAcceleration,
      py::arg("maxVoltage"), py::arg("velocity"), release_gil(), py::doc(
    "Calculates the maximum achievable acceleration given a maximum voltage\n"
"supply and a velocity. Useful for ensuring that velocity and\n"
"acceleration constraints for a trapezoidal profile are simultaneously\n"
"achievable - enter the velocity constraint, and this will give you\n"
"a simultaneously-achievable acceleration constraint.\n"
"\n"
":param maxVoltage: The maximum voltage that can be supplied to the elevator.\n"
":param velocity:   The velocity of the elevator.\n"
"\n"
":returns: The maximum possible acceleration at the given velocity.")
  )
  
  
  
    
  .
def
("minAchievableAcceleration", &frc::ElevatorFeedforward::MinAchievableAcceleration,
      py::arg("maxVoltage"), py::arg("velocity"), release_gil(), py::doc(
    "Calculates the minimum achievable acceleration given a maximum voltage\n"
"supply and a velocity. Useful for ensuring that velocity and\n"
"acceleration constraints for a trapezoidal profile are simultaneously\n"
"achievable - enter the velocity constraint, and this will give you\n"
"a simultaneously-achievable acceleration constraint.\n"
"\n"
":param maxVoltage: The maximum voltage that can be supplied to the elevator.\n"
":param velocity:   The velocity of the elevator.\n"
"\n"
":returns: The minimum possible acceleration at the given velocity.")
  )
  
  
  
    
  .
def
("getKs", &frc::ElevatorFeedforward::GetKs, release_gil(), py::doc(
    "Returns the static gain.\n"
"\n"
":returns: The static gain.")
  )
  
  
  
    
  .
def
("getKg", &frc::ElevatorFeedforward::GetKg, release_gil(), py::doc(
    "Returns the gravity gain.\n"
"\n"
":returns: The gravity gain.")
  )
  
  
  
    
  .
def
("getKv", &frc::ElevatorFeedforward::GetKv, release_gil(), py::doc(
    "Returns the velocity gain.\n"
"\n"
":returns: The velocity gain.")
  )
  
  
  
    
  .
def
("getKa", &frc::ElevatorFeedforward::GetKa, release_gil(), py::doc(
    "Returns the acceleration gain.\n"
"\n"
":returns: The acceleration gain.")
  )
  
  
  ;

  


  }







  SetupWPyStruct<frc::ElevatorFeedforward>(cls_ElevatorFeedforward);


}

}; // struct rpybuild_ElevatorFeedforward_initializer

static std::unique_ptr<rpybuild_ElevatorFeedforward_initializer> cls;

void begin_init_ElevatorFeedforward(py::module &m) {
  cls = std::make_unique<rpybuild_ElevatorFeedforward_initializer>(m);
}

void finish_init_ElevatorFeedforward() {
  cls->finish();
  cls.reset();
}