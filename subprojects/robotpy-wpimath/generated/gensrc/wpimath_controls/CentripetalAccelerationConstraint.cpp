
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/trajectory/constraint/CentripetalAccelerationConstraint.h>


#include <units_acceleration_type_caster.h>

#include <units_compound_type_caster.h>

#include <units_velocity_type_caster.h>







#define RPYGEN_ENABLE_frc__CentripetalAccelerationConstraint_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__CentripetalAccelerationConstraint.hpp>









#include <type_traits>


  using namespace frc;





struct rpybuild_CentripetalAccelerationConstraint_initializer {


  
    using MinMax = frc::TrajectoryConstraint::MinMax;
  

  




  py::module pkg_constraint;









  
  using CentripetalAccelerationConstraint_Trampoline = rpygen::PyTrampoline_frc__CentripetalAccelerationConstraint<typename frc::CentripetalAccelerationConstraint, typename rpygen::PyTrampolineCfg_frc__CentripetalAccelerationConstraint<>>;
    static_assert(std::is_abstract<CentripetalAccelerationConstraint_Trampoline>::value == false, "frc::CentripetalAccelerationConstraint " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::CentripetalAccelerationConstraint, CentripetalAccelerationConstraint_Trampoline, frc::TrajectoryConstraint> cls_CentripetalAccelerationConstraint;

    

    
    

  py::module &m;

  
  rpybuild_CentripetalAccelerationConstraint_initializer(py::module &m) :

  
    pkg_constraint(m.def_submodule("constraint")),
  

  

  

  
    cls_CentripetalAccelerationConstraint(pkg_constraint, "CentripetalAccelerationConstraint"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_CentripetalAccelerationConstraint.doc() =
    "A constraint on the maximum absolute centripetal acceleration allowed when\n"
"traversing a trajectory. The centripetal acceleration of a robot is defined\n"
"as the velocity squared divided by the radius of curvature.\n"
"\n"
"Effectively, limiting the maximum centripetal acceleration will cause the\n"
"robot to slow down around tight turns, making it easier to track trajectories\n"
"with sharp turns.";

  cls_CentripetalAccelerationConstraint
  
    
  .def(py::init<units::meters_per_second_squared_t>(),
      py::arg("maxCentripetalAcceleration"), release_gil()
  )
  
  
  
    
  .
def
("maxVelocity", &frc::CentripetalAccelerationConstraint::MaxVelocity,
      py::arg("pose"), py::arg("curvature"), py::arg("velocity"), release_gil()
  )
  
  
  
    
  .
def
("minMaxAcceleration", &frc::CentripetalAccelerationConstraint::MinMaxAcceleration,
      py::arg("pose"), py::arg("curvature"), py::arg("speed"), release_gil()
  )
  
  
  ;

  


  }







  cls_CentripetalAccelerationConstraint
  .def_static("fromFps", [](units::feet_per_second_squared_t maxCentripetalAcceleration) {
    return std::make_shared<CentripetalAccelerationConstraint>(maxCentripetalAcceleration);
  }, py::arg("maxCentripetalAcceleration"));

}

}; // struct rpybuild_CentripetalAccelerationConstraint_initializer

static std::unique_ptr<rpybuild_CentripetalAccelerationConstraint_initializer> cls;

void begin_init_CentripetalAccelerationConstraint(py::module &m) {
  cls = std::make_unique<rpybuild_CentripetalAccelerationConstraint_initializer>(m);
}

void finish_init_CentripetalAccelerationConstraint() {
  cls->finish();
  cls.reset();
}