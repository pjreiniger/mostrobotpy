
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/estimator/MecanumDrivePoseEstimator.h>


#include <wpi_array_type_caster.h>















#include <type_traits>


  using namespace frc;



struct rpybuild_MecanumDrivePoseEstimator_initializer {


  

  




  py::module pkg_estimator;









  py::class_<typename frc::MecanumDrivePoseEstimator, frc::PoseEstimator<MecanumDriveWheelSpeeds, MecanumDriveWheelPositions>> cls_MecanumDrivePoseEstimator;

    

    
    

  py::module &m;

  
  rpybuild_MecanumDrivePoseEstimator_initializer(py::module &m) :

  
    pkg_estimator(m.def_submodule("estimator")),
  

  

  

  
    cls_MecanumDrivePoseEstimator(pkg_estimator, "MecanumDrivePoseEstimator"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_MecanumDrivePoseEstimator.doc() =
    "This class wraps an Unscented Kalman Filter to fuse latency-compensated\n"
"vision measurements with mecanum drive encoder velocity measurements. It will\n"
"correct for noisy measurements and encoder drift. It is intended to be an\n"
"easy but more accurate drop-in for :class:`MecanumDriveOdometry`.\n"
"\n"
":meth:`update` should be called every robot loop. If your loops are faster or\n"
"slower than the default of 0.02s, then you should change the nominal delta\n"
"time by specifying it in the constructor.\n"
"\n"
":meth:`addVisionMeasurement` can be called as infrequently as you want; if you\n"
"never call it, then this class will behave mostly like regular encoder\n"
"odometry.\n"
"\n"
"The state-space system used internally has the following states (x), inputs\n"
"(u), and outputs (y):\n"
"\n"
":math:`x = [x, y, \\theta]^T` in the field-coordinate system\n"
"containing x position, y position, and heading.\n"
"\n"
":math:`u = [v_x, v_y, \\omega]^T` containing x velocity, y velocity,\n"
"and angular velocity in the field-coordinate system.\n"
"\n"
":math:`y = [x, y, \\theta]^T` from vision containing x position, y\n"
"position, and heading; or :math:`y = [theta]^T` containing gyro\n"
"heading.\n";

  cls_MecanumDrivePoseEstimator
  
    
  .def(py::init<MecanumDriveKinematics&, const Rotation2d&, const MecanumDriveWheelPositions&, const Pose2d&>(),
      py::arg("kinematics"), py::arg("gyroAngle"), py::arg("wheelPositions"), py::arg("initialPose"), release_gil()
    , py::keep_alive<1, 2>()
    , py::keep_alive<1, 3>()
    , py::keep_alive<1, 4>()
    , py::keep_alive<1, 5>(), py::doc(
    "Constructs a MecanumDrivePoseEstimator with default standard deviations\n"
"for the model and vision measurements.\n"
"\n"
"The default standard deviations of the model states are\n"
"0.1 meters for x, 0.1 meters for y, and 0.1 radians for heading.\n"
"The default standard deviations of the vision measurements are\n"
"0.45 meters for x, 0.45 meters for y, and 0.45 radians for heading.\n"
"\n"
":param kinematics:     A correctly-configured kinematics object for your\n"
"                       drivetrain.\n"
":param gyroAngle:      The current gyro angle.\n"
":param wheelPositions: The distance measured by each wheel.\n"
":param initialPose:    The starting pose estimate.")
  )
  
  
  
    
  .def(py::init<MecanumDriveKinematics&, const Rotation2d&, const MecanumDriveWheelPositions&, const Pose2d&, const wpi::array<double, 3>&, const wpi::array<double, 3>&>(),
      py::arg("kinematics"), py::arg("gyroAngle"), py::arg("wheelPositions"), py::arg("initialPose"), py::arg("stateStdDevs"), py::arg("visionMeasurementStdDevs"), release_gil()
    , py::keep_alive<1, 2>()
    , py::keep_alive<1, 3>()
    , py::keep_alive<1, 4>()
    , py::keep_alive<1, 5>()
    , py::keep_alive<1, 6>()
    , py::keep_alive<1, 7>(), py::doc(
    "Constructs a MecanumDrivePoseEstimator.\n"
"\n"
":param kinematics:               A correctly-configured kinematics object for your\n"
"                                 drivetrain.\n"
":param gyroAngle:                The current gyro angle.\n"
":param wheelPositions:           The distance measured by each wheel.\n"
":param initialPose:              The starting pose estimate.\n"
":param stateStdDevs:             Standard deviations of the pose estimate (x position in\n"
"                                 meters, y position in meters, and heading in radians). Increase these\n"
"                                 numbers to trust your state estimate less.\n"
":param visionMeasurementStdDevs: Standard deviations of the vision pose\n"
"                                 measurement (x position in meters, y position in meters, and heading in\n"
"                                 radians). Increase these numbers to trust the vision pose measurement\n"
"                                 less.")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_MecanumDrivePoseEstimator_initializer

static std::unique_ptr<rpybuild_MecanumDrivePoseEstimator_initializer> cls;

void begin_init_MecanumDrivePoseEstimator(py::module &m) {
  cls = std::make_unique<rpybuild_MecanumDrivePoseEstimator_initializer>(m);
}

void finish_init_MecanumDrivePoseEstimator() {
  cls->finish();
  cls.reset();
}