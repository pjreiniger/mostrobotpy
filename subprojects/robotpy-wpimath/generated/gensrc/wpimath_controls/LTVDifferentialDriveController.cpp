
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/controller/LTVDifferentialDriveController.h>


#include <units_length_type_caster.h>

#include <units_time_type_caster.h>

#include <units_velocity_type_caster.h>

#include <wpi_array_type_caster.h>















#include <type_traits>


  using namespace frc;



struct rpybuild_LTVDifferentialDriveController_initializer {


  

  




  py::module pkg_controller;









  py::class_<typename frc::LTVDifferentialDriveController> cls_LTVDifferentialDriveController;

    

    
    

  py::module &m;

  
  rpybuild_LTVDifferentialDriveController_initializer(py::module &m) :

  
    pkg_controller(m.def_submodule("controller")),
  

  

  

  
    cls_LTVDifferentialDriveController(pkg_controller, "LTVDifferentialDriveController"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_LTVDifferentialDriveController.doc() =
    "The linear time-varying differential drive controller has a similar form to\n"
"the LQR, but the model used to compute the controller gain is the nonlinear\n"
"differential drive model linearized around the drivetrain's current state. We\n"
"precompute gains for important places in our state-space, then interpolate\n"
"between them with a lookup table to save computational resources.\n"
"\n"
"This controller has a flat hierarchy with pose and wheel velocity references\n"
"and voltage outputs. This is different from a Ramsete controller's nested\n"
"hierarchy where the top-level controller has a pose reference and chassis\n"
"velocity command outputs, and the low-level controller has wheel velocity\n"
"references and voltage outputs. Flat hierarchies are easier to tune in one\n"
"shot. Furthermore, this controller is more optimal in the \"least-squares\n"
"error\" sense than a controller based on Ramsete.\n"
"\n"
"See section 8.7 in Controls Engineering in FRC for a derivation of the\n"
"control law we used shown in theorem 8.7.4.";

  cls_LTVDifferentialDriveController
  
    
  .def(py::init<const frc::LinearSystem<2, 2, 2>&, units::meter_t, const wpi::array<double, 5>&, const wpi::array<double, 2>&, units::second_t>(),
      py::arg("plant"), py::arg("trackwidth"), py::arg("Qelems"), py::arg("Relems"), py::arg("dt"), release_gil()
    , py::keep_alive<1, 2>()
    , py::keep_alive<1, 4>()
    , py::keep_alive<1, 5>(), py::doc(
    "Constructs a linear time-varying differential drive controller.\n"
"\n"
"See\n"
"https://docs.wpilib.org/en/stable/docs/software/advanced-controls/state-space/state-space-intro.html#lqr-tuning\n"
"for how to select the tolerances.\n"
"\n"
":param plant:      The differential drive velocity plant.\n"
":param trackwidth: The distance between the differential drive's left and\n"
"                   right wheels.\n"
":param Qelems:     The maximum desired error tolerance for each state.\n"
":param Relems:     The maximum desired control effort for each input.\n"
":param dt:         Discretization timestep.\n"
"                   @throws std::domain_error if max velocity of plant with 12 V input <= 0 m/s\n"
"                   or >= 15 m/s.")
  )
  
  
  
    
  .
def
("atReference", &frc::LTVDifferentialDriveController::AtReference, release_gil(), py::doc(
    "Returns true if the pose error is within tolerance of the reference.")
  )
  
  
  
    
  .
def
("setTolerance", &frc::LTVDifferentialDriveController::SetTolerance,
      py::arg("poseTolerance"), py::arg("leftVelocityTolerance"), py::arg("rightVelocityTolerance"), release_gil(), py::doc(
    "Sets the pose error which is considered tolerable for use with\n"
"AtReference().\n"
"\n"
":param poseTolerance:          Pose error which is tolerable.\n"
":param leftVelocityTolerance:  Left velocity error which is tolerable.\n"
":param rightVelocityTolerance: Right velocity error which is tolerable.")
  )
  
  
  
    
  .
def
("calculate", static_cast<DifferentialDriveWheelVoltages(frc::LTVDifferentialDriveController::*)(const Pose2d&, units::meters_per_second_t, units::meters_per_second_t, const Pose2d&, units::meters_per_second_t, units::meters_per_second_t)>(
        &frc::LTVDifferentialDriveController::Calculate),
      py::arg("currentPose"), py::arg("leftVelocity"), py::arg("rightVelocity"), py::arg("poseRef"), py::arg("leftVelocityRef"), py::arg("rightVelocityRef"), release_gil(), py::doc(
    "Returns the left and right output voltages of the LTV controller.\n"
"\n"
"The reference pose, linear velocity, and angular velocity should come from\n"
"a drivetrain trajectory.\n"
"\n"
":param currentPose:      The current pose.\n"
":param leftVelocity:     The current left velocity.\n"
":param rightVelocity:    The current right velocity.\n"
":param poseRef:          The desired pose.\n"
":param leftVelocityRef:  The desired left velocity.\n"
":param rightVelocityRef: The desired right velocity.")
  )
  
  
  
    
  .
def
("calculate", static_cast<DifferentialDriveWheelVoltages(frc::LTVDifferentialDriveController::*)(const Pose2d&, units::meters_per_second_t, units::meters_per_second_t, const Trajectory::State&)>(
        &frc::LTVDifferentialDriveController::Calculate),
      py::arg("currentPose"), py::arg("leftVelocity"), py::arg("rightVelocity"), py::arg("desiredState"), release_gil(), py::doc(
    "Returns the left and right output voltages of the LTV controller.\n"
"\n"
"The reference pose, linear velocity, and angular velocity should come from\n"
"a drivetrain trajectory.\n"
"\n"
":param currentPose:   The current pose.\n"
":param leftVelocity:  The left velocity.\n"
":param rightVelocity: The right velocity.\n"
":param desiredState:  The desired pose, linear velocity, and angular velocity\n"
"                      from a trajectory.")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_LTVDifferentialDriveController_initializer

static std::unique_ptr<rpybuild_LTVDifferentialDriveController_initializer> cls;

void begin_init_LTVDifferentialDriveController(py::module &m) {
  cls = std::make_unique<rpybuild_LTVDifferentialDriveController_initializer>(m);
}

void finish_init_LTVDifferentialDriveController() {
  cls->finish();
  cls.reset();
}