
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/trajectory/constraint/DifferentialDriveVoltageConstraint.h>


#include <units_compound_type_caster.h>

#include <units_length_type_caster.h>

#include <units_velocity_type_caster.h>

#include <units_voltage_type_caster.h>







#define RPYGEN_ENABLE_frc__DifferentialDriveVoltageConstraint_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__DifferentialDriveVoltageConstraint.hpp>









#include <type_traits>


  using namespace frc;



struct rpybuild_DifferentialDriveVoltageConstraint_initializer {


  
    using MinMax = frc::TrajectoryConstraint::MinMax;
  

  




  py::module pkg_constraint;









  
  using DifferentialDriveVoltageConstraint_Trampoline = rpygen::PyTrampoline_frc__DifferentialDriveVoltageConstraint<typename frc::DifferentialDriveVoltageConstraint, typename rpygen::PyTrampolineCfg_frc__DifferentialDriveVoltageConstraint<>>;
    static_assert(std::is_abstract<DifferentialDriveVoltageConstraint_Trampoline>::value == false, "frc::DifferentialDriveVoltageConstraint " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::DifferentialDriveVoltageConstraint, DifferentialDriveVoltageConstraint_Trampoline, frc::TrajectoryConstraint> cls_DifferentialDriveVoltageConstraint;

    

    
    

  py::module &m;

  
  rpybuild_DifferentialDriveVoltageConstraint_initializer(py::module &m) :

  
    pkg_constraint(m.def_submodule("constraint")),
  

  

  

  
    cls_DifferentialDriveVoltageConstraint(pkg_constraint, "DifferentialDriveVoltageConstraint"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_DifferentialDriveVoltageConstraint.doc() =
    "A class that enforces constraints on differential drive voltage expenditure\n"
"based on the motor dynamics and the drive kinematics.  Ensures that the\n"
"acceleration of any wheel of the robot while following the trajectory is\n"
"never higher than what can be achieved with the given maximum voltage.";

  cls_DifferentialDriveVoltageConstraint
  
    
  .def(py::init<const SimpleMotorFeedforward<units::meter>&, DifferentialDriveKinematics, units::volt_t>(),
      py::arg("feedforward"), py::arg("kinematics"), py::arg("maxVoltage"), release_gil()
    , py::keep_alive<1, 2>(), py::doc(
    "Creates a new DifferentialDriveVoltageConstraint.\n"
"\n"
":param feedforward: A feedforward component describing the behavior of the\n"
"                    drive.\n"
":param kinematics:  A kinematics component describing the drive geometry.\n"
":param maxVoltage:  The maximum voltage available to the motors while\n"
"                    following the path. Should be somewhat less than the nominal battery\n"
"                    voltage (12V) to account for \"voltage sag\" due to current draw.")
  )
  
  
  
    
  .
def
("maxVelocity", &frc::DifferentialDriveVoltageConstraint::MaxVelocity,
      py::arg("pose"), py::arg("curvature"), py::arg("velocity"), release_gil()
  )
  
  
  
    
  .
def
("minMaxAcceleration", &frc::DifferentialDriveVoltageConstraint::MinMaxAcceleration,
      py::arg("pose"), py::arg("curvature"), py::arg("speed"), release_gil()
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_DifferentialDriveVoltageConstraint_initializer

static std::unique_ptr<rpybuild_DifferentialDriveVoltageConstraint_initializer> cls;

void begin_init_DifferentialDriveVoltageConstraint(py::module &m) {
  cls = std::make_unique<rpybuild_DifferentialDriveVoltageConstraint_initializer>(m);
}

void finish_init_DifferentialDriveVoltageConstraint() {
  cls->finish();
  cls.reset();
}