
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/estimator/DifferentialDrivePoseEstimator.h>


#include <units_length_type_caster.h>

#include <units_time_type_caster.h>

#include <wpi_array_type_caster.h>















#include <type_traits>


  using namespace frc;



struct rpybuild_DifferentialDrivePoseEstimator_initializer {


  

  




  py::module pkg_estimator;









  py::class_<typename frc::DifferentialDrivePoseEstimator, frc::PoseEstimator<DifferentialDriveWheelSpeeds, DifferentialDriveWheelPositions>> cls_DifferentialDrivePoseEstimator;

    

    
    

  py::module &m;

  
  rpybuild_DifferentialDrivePoseEstimator_initializer(py::module &m) :

  
    pkg_estimator(m.def_submodule("estimator")),
  

  

  

  
    cls_DifferentialDrivePoseEstimator(pkg_estimator, "DifferentialDrivePoseEstimator"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_DifferentialDrivePoseEstimator.doc() =
    "This class wraps an Unscented Kalman Filter to fuse latency-compensated\n"
"vision measurements with differential drive encoder measurements. It will\n"
"correct for noisy vision measurements and encoder drift. It is intended to be\n"
"an easy drop-in for :class:`DifferentialDriveOdometry`. In fact, if you never call\n"
":meth:`addVisionMeasurement`, and only call :meth:`update`, this will behave exactly the\n"
"same as DifferentialDriveOdometry.\n"
"\n"
":meth:`update` should be called every robot loop (if your robot loops are faster or\n"
"slower than the default, then you should change the nominal delta time via\n"
"the constructor).\n"
"\n"
":meth:`addVisionMeasurement` can be called as infrequently as you want; if you\n"
"never call it, then this class will behave like regular encoder odometry.\n"
"\n"
"The state-space system used internally has the following states (x), inputs\n"
"(u), and outputs (y):\n"
"\n"
":math:`x = [x, y, \\theta, dist_l, dist_r]^T` in the field coordinate\n"
"system containing x position, y position, heading, left encoder distance,\n"
"and right encoder distance.\n"
"\n"
":math:`u = [v_l, v_r, d\\theta]^T` containing left wheel velocity,\n"
"right wheel velocity, and change in gyro heading.\n"
"\n"
"NB: Using velocities make things considerably easier, because it means that\n"
"teams don't have to worry about getting an accurate model. Basically, we\n"
"suspect that it's easier for teams to get good encoder data than it is for\n"
"them to perform system identification well enough to get a good model.\n"
"\n"
":math:`y = [x, y, \\theta]^T` from vision containing x position, y\n"
"position, and heading; or :math:`y = [dist_l, dist_r, \\theta]^T`\n"
"containing left encoder position, right encoder position, and gyro heading.\n";

  cls_DifferentialDrivePoseEstimator
  
    
  .def(py::init<DifferentialDriveKinematics&, const Rotation2d&, units::meter_t, units::meter_t, const Pose2d&>(),
      py::arg("kinematics"), py::arg("gyroAngle"), py::arg("leftDistance"), py::arg("rightDistance"), py::arg("initialPose"), release_gil()
    , py::keep_alive<1, 2>()
    , py::keep_alive<1, 3>()
    , py::keep_alive<1, 6>(), py::doc(
    "Constructs a DifferentialDrivePoseEstimator with default standard\n"
"deviations for the model and vision measurements.\n"
"\n"
"The default standard deviations of the model states are\n"
"0.02 meters for x, 0.02 meters for y, and 0.01 radians for heading.\n"
"The default standard deviations of the vision measurements are\n"
"0.1 meters for x, 0.1 meters for y, and 0.1 radians for heading.\n"
"\n"
":param kinematics:    A correctly-configured kinematics object for your\n"
"                      drivetrain.\n"
":param gyroAngle:     The gyro angle of the robot.\n"
":param leftDistance:  The distance traveled by the left encoder.\n"
":param rightDistance: The distance traveled by the right encoder.\n"
":param initialPose:   The estimated initial pose.")
  )
  
  
  
    
  .def(py::init<DifferentialDriveKinematics&, const Rotation2d&, units::meter_t, units::meter_t, const Pose2d&, const wpi::array<double, 3>&, const wpi::array<double, 3>&>(),
      py::arg("kinematics"), py::arg("gyroAngle"), py::arg("leftDistance"), py::arg("rightDistance"), py::arg("initialPose"), py::arg("stateStdDevs"), py::arg("visionMeasurementStdDevs"), release_gil()
    , py::keep_alive<1, 2>()
    , py::keep_alive<1, 3>()
    , py::keep_alive<1, 6>()
    , py::keep_alive<1, 7>()
    , py::keep_alive<1, 8>(), py::doc(
    "Constructs a DifferentialDrivePoseEstimator.\n"
"\n"
":param kinematics:               A correctly-configured kinematics object for your\n"
"                                 drivetrain.\n"
":param gyroAngle:                The gyro angle of the robot.\n"
":param leftDistance:             The distance traveled by the left encoder.\n"
":param rightDistance:            The distance traveled by the right encoder.\n"
":param initialPose:              The estimated initial pose.\n"
":param stateStdDevs:             Standard deviations of the pose estimate (x position in\n"
"                                 meters, y position in meters, and heading in radians). Increase these\n"
"                                 numbers to trust your state estimate less.\n"
":param visionMeasurementStdDevs: Standard deviations of the vision pose\n"
"                                 measurement (x position in meters, y position in meters, and heading in\n"
"                                 radians). Increase these numbers to trust the vision pose measurement\n"
"                                 less.")
  )
  
  
  
    
  .
def
("resetPosition", &frc::DifferentialDrivePoseEstimator::ResetPosition,
      py::arg("gyroAngle"), py::arg("leftDistance"), py::arg("rightDistance"), py::arg("pose"), release_gil(), py::doc(
    "Resets the robot's position on the field.\n"
"\n"
":param gyroAngle:     The current gyro angle.\n"
":param leftDistance:  The distance traveled by the left encoder.\n"
":param rightDistance: The distance traveled by the right encoder.\n"
":param pose:          The estimated pose of the robot on the field.")
  )
  
  
  
    
  .
def
("update", &frc::DifferentialDrivePoseEstimator::Update,
      py::arg("gyroAngle"), py::arg("leftDistance"), py::arg("rightDistance"), release_gil(), py::doc(
    "Updates the pose estimator with wheel encoder and gyro information. This\n"
"should be called every loop.\n"
"\n"
":param gyroAngle:     The current gyro angle.\n"
":param leftDistance:  The distance traveled by the left encoder.\n"
":param rightDistance: The distance traveled by the right encoder.\n"
"\n"
":returns: The estimated pose of the robot.")
  )
  
  
  
    
  .
def
("updateWithTime", &frc::DifferentialDrivePoseEstimator::UpdateWithTime,
      py::arg("currentTime"), py::arg("gyroAngle"), py::arg("leftDistance"), py::arg("rightDistance"), release_gil(), py::doc(
    "Updates the pose estimator with wheel encoder and gyro information. This\n"
"should be called every loop.\n"
"\n"
":param currentTime:   The time at which this method was called.\n"
":param gyroAngle:     The current gyro angle.\n"
":param leftDistance:  The distance traveled by the left encoder.\n"
":param rightDistance: The distance traveled by the right encoder.\n"
"\n"
":returns: The estimated pose of the robot.")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_DifferentialDrivePoseEstimator_initializer

static std::unique_ptr<rpybuild_DifferentialDrivePoseEstimator_initializer> cls;

void begin_init_DifferentialDrivePoseEstimator(py::module &m) {
  cls = std::make_unique<rpybuild_DifferentialDrivePoseEstimator_initializer>(m);
}

void finish_init_DifferentialDrivePoseEstimator() {
  cls->finish();
  cls.reset();
}