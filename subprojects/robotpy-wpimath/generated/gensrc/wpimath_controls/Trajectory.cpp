
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/trajectory/Trajectory.h>


#include <pybind11/stl.h>

#include <units_acceleration_type_caster.h>

#include <units_compound_type_caster.h>

#include <units_time_type_caster.h>

#include <units_velocity_type_caster.h>



#include <pybind11/operators.h>











#include <rpy/geometryToString.h>



#include <type_traits>


  using namespace frc;



struct rpybuild_Trajectory_initializer {


  

  




  py::module pkg_trajectory;









  py::class_<typename frc::Trajectory> cls_Trajectory;

    

    
    
    py::class_<typename frc::Trajectory::State> cls_State;

    

    
    
    

  py::module &m;

  
  rpybuild_Trajectory_initializer(py::module &m) :

  
    pkg_trajectory(m.def_submodule("trajectory")),
  

  

  

  
    cls_Trajectory(pkg_trajectory, "Trajectory"),

  

  
  
    cls_State(cls_Trajectory, "State"),

  

  
  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  

    
    
  }

void finish() {





  {
  
  using State [[maybe_unused]] = typename frc::Trajectory::State;
  
  
  


  

  cls_Trajectory.doc() =
    "Represents a time-parameterized trajectory. The trajectory contains of\n"
"various States that represent the pose, curvature, time elapsed, velocity,\n"
"and acceleration at that point.";

  cls_Trajectory
  
    
  .def(py::init<>(), release_gil()
  )
  
  
  
    
  .def(py::init<const std::vector<State>&>(),
      py::arg("states"), release_gil()
    , py::keep_alive<1, 2>(), py::doc(
    "Constructs a trajectory from a vector of states.\n"
"\n"
"@throws std::invalid_argument if the vector of states is empty.")
  )
  
  
  
    
  .
def
("totalTime", &frc::Trajectory::TotalTime, release_gil(), py::doc(
    "Returns the overall duration of the trajectory.\n"
"\n"
":returns: The duration of the trajectory.")
  )
  
  
  
    
  .
def
("states", &frc::Trajectory::States, release_gil(), py::doc(
    "Return the states of the trajectory.\n"
"\n"
":returns: The states of the trajectory.")
  )
  
  
  
    
  .
def
("sample", &frc::Trajectory::Sample,
      py::arg("t"), release_gil(), py::doc(
    "Sample the trajectory at a point in time.\n"
"\n"
":param t: The point in time since the beginning of the trajectory to sample.\n"
"\n"
":returns: The state at that point in time.\n"
"          @throws std::runtime_error if the trajectory has no states.")
  )
  
  
  
    
  .
def
("transformBy", &frc::Trajectory::TransformBy,
      py::arg("transform"), release_gil(), py::doc(
    "Transforms all poses in the trajectory by the given transform. This is\n"
"useful for converting a robot-relative trajectory into a field-relative\n"
"trajectory. This works with respect to the first pose in the trajectory.\n"
"\n"
":param transform: The transform to transform the trajectory by.\n"
"\n"
":returns: The transformed trajectory.")
  )
  
  
  
    
  .
def
("relativeTo", &frc::Trajectory::RelativeTo,
      py::arg("pose"), release_gil(), py::doc(
    "Transforms all poses in the trajectory so that they are relative to the\n"
"given pose. This is useful for converting a field-relative trajectory\n"
"into a robot-relative trajectory.\n"
"\n"
":param pose: The pose that is the origin of the coordinate frame that\n"
"             the current trajectory will be transformed into.\n"
"\n"
":returns: The transformed trajectory.")
  )
  
  
  
    
  .def(py::self + py::self, py::doc(
    "Concatenates another trajectory to the current trajectory. The user is\n"
"responsible for making sure that the end pose of this trajectory and the\n"
"start pose of the other trajectory match (if that is the desired behavior).\n"
"\n"
":param other: The trajectory to concatenate.\n"
"\n"
":returns: The concatenated trajectory.")
  )
  
  
  
    
  .
def
("initialPose", &frc::Trajectory::InitialPose, release_gil(), py::doc(
    "Returns the initial pose of the trajectory.\n"
"\n"
":returns: The initial pose of the trajectory.")
  )
  
  
  
    
  .def(py::self == py::self, py::doc(
    "Checks equality between this Trajectory and another object.")
  )
  
  
  ;

  


  

  cls_State.doc() =
    "Represents one point on the trajectory.";

  cls_State
  
    
  .def(py::self == py::self, py::doc(
    "Checks equality between this State and another object.")
  )
  
  
  
    
  .
def
("interpolate", &frc::Trajectory::State::Interpolate,
      py::arg("endValue"), py::arg("i"), release_gil(), py::doc(
    "Interpolates between two States.\n"
"\n"
":param endValue: The end value for the interpolation.\n"
":param i:        The interpolant (fraction).\n"
"\n"
":returns: The interpolated state.")
  )
  
  
  
    .def_readwrite("t", &frc::Trajectory::State::t, py::doc(
    "The time elapsed since the beginning of the trajectory."))
  
    .def_readwrite("velocity", &frc::Trajectory::State::velocity, py::doc(
    "The speed at that point of the trajectory."))
  
    .def_readwrite("acceleration", &frc::Trajectory::State::acceleration, py::doc(
    "The acceleration at that point of the trajectory."))
  
    .def_readwrite("pose", &frc::Trajectory::State::pose, py::doc(
    "The pose at that point of the trajectory."))
  
    .def_readwrite("curvature", &frc::Trajectory::State::curvature, py::doc(
    "The curvature at that point of the trajectory."))
  ;

  


  
  }







  cls_State
  .def(
    py::init<
      units::second_t,
      units::meters_per_second_t,
      units::meters_per_second_squared_t,
      Pose2d,
      units::curvature_t
    >(),
    py::arg("t") = 0_s,
    py::arg("velocity") = 0_mps,
    py::arg("acceleration") = 0_mps_sq,
    py::arg("pose") = Pose2d(),
    py::arg("curvature") = 0.0
  )
  .def_property_readonly("velocity_fps", [](frc::Trajectory::State * self) -> units::feet_per_second_t {
    return self->velocity;
  })
  .def_property_readonly("acceleration_fps", [](frc::Trajectory::State * self) -> units::feet_per_second_squared_t {
    return self->acceleration;
  })
  .def("__repr__", [](frc::Trajectory::State *self) {
    return "Trajectory.State("
      "t=" + std::to_string(self->t()) + ", "
      "velocity=" + std::to_string(self->velocity()) + ", "
      "acceleration=" + std::to_string(self->acceleration()) + ", "
      "pose=" + rpy::toString(self->pose) + ", "
      "curvature=" + std::to_string(self->curvature()) + ")";
  })
  .def_readwrite("curvature", &frc::Trajectory::State::curvature);


}

}; // struct rpybuild_Trajectory_initializer

static std::unique_ptr<rpybuild_Trajectory_initializer> cls;

void begin_init_Trajectory(py::module &m) {
  cls = std::make_unique<rpybuild_Trajectory_initializer>(m);
}

void finish_init_Trajectory() {
  cls->finish();
  cls.reset();
}