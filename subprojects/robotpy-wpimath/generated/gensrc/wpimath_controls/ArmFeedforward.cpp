
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/controller/ArmFeedforward.h>


#include <units_angle_type_caster.h>

#include <units_angular_acceleration_type_caster.h>

#include <units_angular_velocity_type_caster.h>

#include <units_compound_type_caster.h>

#include <units_time_type_caster.h>

#include <units_voltage_type_caster.h>













#include <wpystruct.h>



#include <type_traits>


  using namespace frc;



struct rpybuild_ArmFeedforward_initializer {


  
    using Acceleration = frc::ArmFeedforward::Acceleration;
  
    using kv_unit = frc::ArmFeedforward::kv_unit;
  
    using ka_unit = frc::ArmFeedforward::ka_unit;
  

  




  py::module pkg_controller;









  py::class_<typename frc::ArmFeedforward> cls_ArmFeedforward;

    

    
    

  py::module &m;

  
  rpybuild_ArmFeedforward_initializer(py::module &m) :

  
    pkg_controller(m.def_submodule("controller")),
  

  

  

  
    cls_ArmFeedforward(pkg_controller, "ArmFeedforward"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  
    using Angle [[maybe_unused]] = typename frc::ArmFeedforward::Angle;
  
    using Velocity [[maybe_unused]] = typename frc::ArmFeedforward::Velocity;
  


  

  cls_ArmFeedforward.doc() =
    "A helper class that computes feedforward outputs for a simple arm (modeled as\n"
"a motor acting against the force of gravity on a beam suspended at an angle).";

  cls_ArmFeedforward
  
    
  .def(py::init<units::volt_t, units::volt_t, units::unit_t<kv_unit>, units::unit_t<ka_unit>, units::second_t>(),
      py::arg("kS"), py::arg("kG"), py::arg("kV"), py::arg("kA") = units::unit_t<ka_unit> (0), py::arg("dt") = (units::second_t)20_ms, release_gil(), py::doc(
    "Creates a new ArmFeedforward with the specified gains.\n"
"\n"
":param kS: The static gain, in volts.\n"
":param kG: The gravity gain, in volts.\n"
":param kV: The velocity gain, in volt seconds per radian.\n"
":param kA: The acceleration gain, in volt secondsÂ² per radian.\n"
":param dt: The period in seconds.\n"
"           @throws IllegalArgumentException for kv &lt; zero.\n"
"           @throws IllegalArgumentException for ka &lt; zero.\n"
"           @throws IllegalArgumentException for period &le; zero.")
  )
  
  
  
    
  .
def
("calculate", static_cast<units::volt_t(frc::ArmFeedforward::*)(units::unit_t<Angle>, units::unit_t<Velocity>, units::unit_t<Acceleration>) const>(
        &frc::ArmFeedforward::Calculate),
      py::arg("angle"), py::arg("velocity"), py::arg("acceleration"), release_gil(), py::doc(
    "Calculates the feedforward from the gains and setpoints assuming continuous\n"
"control.\n"
"\n"
":param angle:        The angle setpoint, in radians. This angle should be\n"
"                     measured from the horizontal (i.e. if the provided\n"
"                     angle is 0, the arm should be parallel to the floor).\n"
"                     If your encoder does not follow this convention, an\n"
"                     offset should be added.\n"
":param velocity:     The velocity setpoint.\n"
":param acceleration: The acceleration setpoint.\n"
"\n"
":returns: The computed feedforward, in volts.")
  )
  
  
  
    
  .
def
("calculate", static_cast<units::volt_t(frc::ArmFeedforward::*)(units::unit_t<Angle>, units::unit_t<Velocity>, units::unit_t<Velocity>, units::second_t) const>(
        &frc::ArmFeedforward::Calculate),
      py::arg("currentAngle"), py::arg("currentVelocity"), py::arg("nextVelocity"), py::arg("dt"), release_gil(), py::doc(
    "Calculates the feedforward from the gains and setpoints assuming continuous\n"
"control.\n"
"\n"
":param currentAngle:    The current angle in radians. This angle should be\n"
"                        measured from the horizontal (i.e. if the provided angle is 0, the arm\n"
"                        should be parallel to the floor). If your encoder does not follow this\n"
"                        convention, an offset should be added.\n"
":param currentVelocity: The current velocity setpoint.\n"
":param nextVelocity:    The next velocity setpoint.\n"
":param dt:              Time between velocity setpoints in seconds.\n"
"\n"
":returns: The computed feedforward in volts.")
  )
  
  
  
    
  .
def
("calculate", static_cast<units::volt_t(frc::ArmFeedforward::*)(units::unit_t<Angle>, units::unit_t<Velocity>) const>(
        &frc::ArmFeedforward::Calculate),
      py::arg("currentAngle"), py::arg("currentVelocity"), release_gil(), py::doc(
    "Calculates the feedforward from the gains and setpoint assuming discrete\n"
"control. Use this method when the velocity does not change.\n"
"\n"
":param currentAngle:    The current angle. This angle should be measured from\n"
"                        the horizontal (i.e. if the provided angle is 0, the arm should be parallel\n"
"                        to the floor). If your encoder does not follow this convention, an offset\n"
"                        should be added.\n"
":param currentVelocity: The current velocity.\n"
"\n"
":returns: The computed feedforward in volts.")
  )
  
  
  
    
  .
def
("calculate", static_cast<units::volt_t(frc::ArmFeedforward::*)(units::unit_t<Angle>, units::unit_t<Velocity>, units::unit_t<Velocity>) const>(
        &frc::ArmFeedforward::Calculate),
      py::arg("currentAngle"), py::arg("currentVelocity"), py::arg("nextVelocity"), release_gil(), py::doc(
    "Calculates the feedforward from the gains and setpoints assuming discrete\n"
"control.\n"
"\n"
":param currentAngle:    The current angle. This angle should be measured from\n"
"                        the horizontal (i.e. if the provided angle is 0, the arm should be parallel\n"
"                        to the floor). If your encoder does not follow this convention, an offset\n"
"                        should be added.\n"
":param currentVelocity: The current velocity.\n"
":param nextVelocity:    The next velocity.\n"
"\n"
":returns: The computed feedforward in volts.")
  )
  
  
  
    
  .
def
("maxAchievableVelocity", &frc::ArmFeedforward::MaxAchievableVelocity,
      py::arg("maxVoltage"), py::arg("angle"), py::arg("acceleration"), release_gil(), py::doc(
    "Calculates the maximum achievable velocity given a maximum voltage supply,\n"
"a position, and an acceleration.  Useful for ensuring that velocity and\n"
"acceleration constraints for a trapezoidal profile are simultaneously\n"
"achievable - enter the acceleration constraint, and this will give you\n"
"a simultaneously-achievable velocity constraint.\n"
"\n"
":param maxVoltage:   The maximum voltage that can be supplied to the arm.\n"
":param angle:        The angle of the arm. This angle should be measured\n"
"                     from the horizontal (i.e. if the provided angle is 0,\n"
"                     the arm should be parallel to the floor). If your\n"
"                     encoder does not follow this convention, an offset\n"
"                     should be added.\n"
":param acceleration: The acceleration of the arm.\n"
"\n"
":returns: The maximum possible velocity at the given acceleration and angle.")
  )
  
  
  
    
  .
def
("minAchievableVelocity", &frc::ArmFeedforward::MinAchievableVelocity,
      py::arg("maxVoltage"), py::arg("angle"), py::arg("acceleration"), release_gil(), py::doc(
    "Calculates the minimum achievable velocity given a maximum voltage supply,\n"
"a position, and an acceleration.  Useful for ensuring that velocity and\n"
"acceleration constraints for a trapezoidal profile are simultaneously\n"
"achievable - enter the acceleration constraint, and this will give you\n"
"a simultaneously-achievable velocity constraint.\n"
"\n"
":param maxVoltage:   The maximum voltage that can be supplied to the arm.\n"
":param angle:        The angle of the arm. This angle should be measured\n"
"                     from the horizontal (i.e. if the provided angle is 0,\n"
"                     the arm should be parallel to the floor). If your\n"
"                     encoder does not follow this convention, an offset\n"
"                     should be added.\n"
":param acceleration: The acceleration of the arm.\n"
"\n"
":returns: The minimum possible velocity at the given acceleration and angle.")
  )
  
  
  
    
  .
def
("maxAchievableAcceleration", &frc::ArmFeedforward::MaxAchievableAcceleration,
      py::arg("maxVoltage"), py::arg("angle"), py::arg("velocity"), release_gil(), py::doc(
    "Calculates the maximum achievable acceleration given a maximum voltage\n"
"supply, a position, and a velocity. Useful for ensuring that velocity and\n"
"acceleration constraints for a trapezoidal profile are simultaneously\n"
"achievable - enter the velocity constraint, and this will give you\n"
"a simultaneously-achievable acceleration constraint.\n"
"\n"
":param maxVoltage: The maximum voltage that can be supplied to the arm.\n"
":param angle:      The angle of the arm. This angle should be measured\n"
"                   from the horizontal (i.e. if the provided angle is 0,\n"
"                   the arm should be parallel to the floor). If your\n"
"                   encoder does not follow this convention, an offset\n"
"                   should be added.\n"
":param velocity:   The velocity of the arm.\n"
"\n"
":returns: The maximum possible acceleration at the given velocity and angle.")
  )
  
  
  
    
  .
def
("minAchievableAcceleration", &frc::ArmFeedforward::MinAchievableAcceleration,
      py::arg("maxVoltage"), py::arg("angle"), py::arg("velocity"), release_gil(), py::doc(
    "Calculates the minimum achievable acceleration given a maximum voltage\n"
"supply, a position, and a velocity. Useful for ensuring that velocity and\n"
"acceleration constraints for a trapezoidal profile are simultaneously\n"
"achievable - enter the velocity constraint, and this will give you\n"
"a simultaneously-achievable acceleration constraint.\n"
"\n"
":param maxVoltage: The maximum voltage that can be supplied to the arm.\n"
":param angle:      The angle of the arm. This angle should be measured\n"
"                   from the horizontal (i.e. if the provided angle is 0,\n"
"                   the arm should be parallel to the floor). If your\n"
"                   encoder does not follow this convention, an offset\n"
"                   should be added.\n"
":param velocity:   The velocity of the arm.\n"
"\n"
":returns: The minimum possible acceleration at the given velocity and angle.")
  )
  
  
  
    
  .
def
("getKs", &frc::ArmFeedforward::GetKs, release_gil(), py::doc(
    "Returns the static gain.\n"
"\n"
":returns: The static gain.")
  )
  
  
  
    
  .
def
("getKg", &frc::ArmFeedforward::GetKg, release_gil(), py::doc(
    "Returns the gravity gain.\n"
"\n"
":returns: The gravity gain.")
  )
  
  
  
    
  .
def
("getKv", &frc::ArmFeedforward::GetKv, release_gil(), py::doc(
    "Returns the velocity gain.\n"
"\n"
":returns: The velocity gain.")
  )
  
  
  
    
  .
def
("getKa", &frc::ArmFeedforward::GetKa, release_gil(), py::doc(
    "Returns the acceleration gain.\n"
"\n"
":returns: The acceleration gain.")
  )
  
  
  ;

  


  }







  SetupWPyStruct<frc::ArmFeedforward>(cls_ArmFeedforward);


}

}; // struct rpybuild_ArmFeedforward_initializer

static std::unique_ptr<rpybuild_ArmFeedforward_initializer> cls;

void begin_init_ArmFeedforward(py::module &m) {
  cls = std::make_unique<rpybuild_ArmFeedforward_initializer>(m);
}

void finish_init_ArmFeedforward() {
  cls->finish();
  cls.reset();
}