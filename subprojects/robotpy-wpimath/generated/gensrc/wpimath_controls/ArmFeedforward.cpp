
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/controller/ArmFeedforward.h>


#include <units_angle_type_caster.h>

#include <units_angular_acceleration_type_caster.h>

#include <units_angular_velocity_type_caster.h>

#include <units_compound_type_caster.h>

#include <units_time_type_caster.h>

#include <units_voltage_type_caster.h>













#include <wpystruct.h>



#include <type_traits>


  using namespace frc;





struct rpybuild_ArmFeedforward_initializer {


  
    using Acceleration = frc::ArmFeedforward::Acceleration;
  
    using kv_unit = frc::ArmFeedforward::kv_unit;
  
    using ka_unit = frc::ArmFeedforward::ka_unit;
  

  




  py::module pkg_controller;









  py::class_<typename frc::ArmFeedforward> cls_ArmFeedforward;

    

    
    

  py::module &m;

  
  rpybuild_ArmFeedforward_initializer(py::module &m) :

  
    pkg_controller(m.def_submodule("controller")),
  

  

  

  
    cls_ArmFeedforward(pkg_controller, "ArmFeedforward"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  
    using Angle [[maybe_unused]] = typename frc::ArmFeedforward::Angle;
  
    using Velocity [[maybe_unused]] = typename frc::ArmFeedforward::Velocity;
  


  

  cls_ArmFeedforward.doc() =
    "A helper class that computes feedforward outputs for a simple arm (modeled as\n"
"a motor acting against the force of gravity on a beam suspended at an angle).";

  cls_ArmFeedforward
  
    
  .def(py::init<units::volt_t, units::volt_t, units::unit_t<kv_unit>, units::unit_t<ka_unit>>(),
      py::arg("kS"), py::arg("kG"), py::arg("kV"), py::arg("kA") = units::unit_t<ka_unit> (0), release_gil(), py::doc(
    "Creates a new ArmFeedforward with the specified gains.\n"
"\n"
":param kS: The static gain, in volts.\n"
":param kG: The gravity gain, in volts.\n"
":param kV: The velocity gain, in volt seconds per radian.\n"
":param kA: The acceleration gain, in volt seconds² per radian.")
  )
  
  
  
    
  .
def
("calculate", &frc::ArmFeedforward::Calculate,
      py::arg("angle"), py::arg("velocity"), py::arg("acceleration") = units::unit_t<Acceleration> (0), release_gil(), py::doc(
    "Calculates the feedforward from the gains and setpoints.\n"
"\n"
":param angle:        The angle setpoint, in radians. This angle should be\n"
"                     measured from the horizontal (i.e. if the provided\n"
"                     angle is 0, the arm should be parallel to the floor).\n"
"                     If your encoder does not follow this convention, an\n"
"                     offset should be added.\n"
":param velocity:     The velocity setpoint, in radians per second.\n"
":param acceleration: The acceleration setpoint, in radians per second².\n"
"\n"
":returns: The computed feedforward, in volts.")
  )
  
  
  
    
  .
def
("maxAchievableVelocity", &frc::ArmFeedforward::MaxAchievableVelocity,
      py::arg("maxVoltage"), py::arg("angle"), py::arg("acceleration"), release_gil(), py::doc(
    "Calculates the maximum achievable velocity given a maximum voltage supply,\n"
"a position, and an acceleration.  Useful for ensuring that velocity and\n"
"acceleration constraints for a trapezoidal profile are simultaneously\n"
"achievable - enter the acceleration constraint, and this will give you\n"
"a simultaneously-achievable velocity constraint.\n"
"\n"
":param maxVoltage:   The maximum voltage that can be supplied to the arm.\n"
":param angle:        The angle of the arm. This angle should be measured\n"
"                     from the horizontal (i.e. if the provided angle is 0,\n"
"                     the arm should be parallel to the floor). If your\n"
"                     encoder does not follow this convention, an offset\n"
"                     should be added.\n"
":param acceleration: The acceleration of the arm.\n"
"\n"
":returns: The maximum possible velocity at the given acceleration and angle.")
  )
  
  
  
    
  .
def
("minAchievableVelocity", &frc::ArmFeedforward::MinAchievableVelocity,
      py::arg("maxVoltage"), py::arg("angle"), py::arg("acceleration"), release_gil(), py::doc(
    "Calculates the minimum achievable velocity given a maximum voltage supply,\n"
"a position, and an acceleration.  Useful for ensuring that velocity and\n"
"acceleration constraints for a trapezoidal profile are simultaneously\n"
"achievable - enter the acceleration constraint, and this will give you\n"
"a simultaneously-achievable velocity constraint.\n"
"\n"
":param maxVoltage:   The maximum voltage that can be supplied to the arm.\n"
":param angle:        The angle of the arm. This angle should be measured\n"
"                     from the horizontal (i.e. if the provided angle is 0,\n"
"                     the arm should be parallel to the floor). If your\n"
"                     encoder does not follow this convention, an offset\n"
"                     should be added.\n"
":param acceleration: The acceleration of the arm.\n"
"\n"
":returns: The minimum possible velocity at the given acceleration and angle.")
  )
  
  
  
    
  .
def
("maxAchievableAcceleration", &frc::ArmFeedforward::MaxAchievableAcceleration,
      py::arg("maxVoltage"), py::arg("angle"), py::arg("velocity"), release_gil(), py::doc(
    "Calculates the maximum achievable acceleration given a maximum voltage\n"
"supply, a position, and a velocity. Useful for ensuring that velocity and\n"
"acceleration constraints for a trapezoidal profile are simultaneously\n"
"achievable - enter the velocity constraint, and this will give you\n"
"a simultaneously-achievable acceleration constraint.\n"
"\n"
":param maxVoltage: The maximum voltage that can be supplied to the arm.\n"
":param angle:      The angle of the arm. This angle should be measured\n"
"                   from the horizontal (i.e. if the provided angle is 0,\n"
"                   the arm should be parallel to the floor). If your\n"
"                   encoder does not follow this convention, an offset\n"
"                   should be added.\n"
":param velocity:   The velocity of the arm.\n"
"\n"
":returns: The maximum possible acceleration at the given velocity and angle.")
  )
  
  
  
    
  .
def
("minAchievableAcceleration", &frc::ArmFeedforward::MinAchievableAcceleration,
      py::arg("maxVoltage"), py::arg("angle"), py::arg("velocity"), release_gil(), py::doc(
    "Calculates the minimum achievable acceleration given a maximum voltage\n"
"supply, a position, and a velocity. Useful for ensuring that velocity and\n"
"acceleration constraints for a trapezoidal profile are simultaneously\n"
"achievable - enter the velocity constraint, and this will give you\n"
"a simultaneously-achievable acceleration constraint.\n"
"\n"
":param maxVoltage: The maximum voltage that can be supplied to the arm.\n"
":param angle:      The angle of the arm. This angle should be measured\n"
"                   from the horizontal (i.e. if the provided angle is 0,\n"
"                   the arm should be parallel to the floor). If your\n"
"                   encoder does not follow this convention, an offset\n"
"                   should be added.\n"
":param velocity:   The velocity of the arm.\n"
"\n"
":returns: The minimum possible acceleration at the given velocity and angle.")
  )
  
  
  
    .def_readonly("kS", &frc::ArmFeedforward::kS, py::doc(
    "The static gain, in volts."))
  
    .def_readonly("kG", &frc::ArmFeedforward::kG, py::doc(
    "The gravity gain, in volts."))
  
    .def_readonly("kV", &frc::ArmFeedforward::kV, py::doc(
    "The velocity gain, in volt seconds per radian."))
  
    .def_readonly("kA", &frc::ArmFeedforward::kA, py::doc(
    "The acceleration gain, in volt seconds² per radian."))
  ;

  


  }







  SetupWPyStruct<frc::ArmFeedforward>(cls_ArmFeedforward);


}

}; // struct rpybuild_ArmFeedforward_initializer

static std::unique_ptr<rpybuild_ArmFeedforward_initializer> cls;

void begin_init_ArmFeedforward(py::module &m) {
  cls = std::make_unique<rpybuild_ArmFeedforward_initializer>(m);
}

void finish_init_ArmFeedforward() {
  cls->finish();
  cls.reset();
}