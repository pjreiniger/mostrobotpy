
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/controller/PIDController.h>


#include <units_time_type_caster.h>







#define RPYGEN_ENABLE_frc__PIDController_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__PIDController.hpp>









#include <type_traits>


  using namespace frc;





struct rpybuild_PIDController_initializer {


  

  




  py::module pkg_controller;









  
  using PIDController_Trampoline = rpygen::PyTrampoline_frc__PIDController<typename frc::PIDController, typename rpygen::PyTrampolineCfg_frc__PIDController<>>;
    static_assert(std::is_abstract<PIDController_Trampoline>::value == false, "frc::PIDController " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::PIDController, PIDController_Trampoline, wpi::Sendable> cls_PIDController;

    

    
    

  py::module &m;

  
  rpybuild_PIDController_initializer(py::module &m) :

  
    pkg_controller(m.def_submodule("controller")),
  

  

  

  
    cls_PIDController(pkg_controller, "PIDController"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_PIDController.doc() =
    "Implements a PID control loop.";

  cls_PIDController
  
    
  .def(py::init<double, double, double, units::second_t>(),
      py::arg("Kp"), py::arg("Ki"), py::arg("Kd"), py::arg("period") = (units::second_t)0.020_s, release_gil(), py::doc(
    "Allocates a PIDController with the given constants for Kp, Ki, and Kd.\n"
"\n"
":param Kp:     The proportional coefficient. Must be >= 0.\n"
":param Ki:     The integral coefficient. Must be >= 0.\n"
":param Kd:     The derivative coefficient. Must be >= 0.\n"
":param period: The period between controller updates in seconds. The\n"
"               default is 20 milliseconds. Must be positive.")
  )
  
  
  
    
  .
def
("setPID", &frc::PIDController::SetPID,
      py::arg("Kp"), py::arg("Ki"), py::arg("Kd"), release_gil(), py::doc(
    "Sets the PID Controller gain parameters.\n"
"\n"
"Sets the proportional, integral, and differential coefficients.\n"
"\n"
":param Kp: The proportional coefficient. Must be >= 0.\n"
":param Ki: The integral coefficient. Must be >= 0.\n"
":param Kd: The differential coefficient. Must be >= 0.")
  )
  
  
  
    
  .
def
("setP", &frc::PIDController::SetP,
      py::arg("Kp"), release_gil(), py::doc(
    "Sets the proportional coefficient of the PID controller gain.\n"
"\n"
":param Kp: The proportional coefficient. Must be >= 0.")
  )
  
  
  
    
  .
def
("setI", &frc::PIDController::SetI,
      py::arg("Ki"), release_gil(), py::doc(
    "Sets the integral coefficient of the PID controller gain.\n"
"\n"
":param Ki: The integral coefficient. Must be >= 0.")
  )
  
  
  
    
  .
def
("setD", &frc::PIDController::SetD,
      py::arg("Kd"), release_gil(), py::doc(
    "Sets the differential coefficient of the PID controller gain.\n"
"\n"
":param Kd: The differential coefficient. Must be >= 0.")
  )
  
  
  
    
  .
def
("setIZone", &frc::PIDController::SetIZone,
      py::arg("iZone"), release_gil(), py::doc(
    "Sets the IZone range. When the absolute value of the position error is\n"
"greater than IZone, the total accumulated error will reset to zero,\n"
"disabling integral gain until the absolute value of the position error is\n"
"less than IZone. This is used to prevent integral windup. Must be\n"
"non-negative. Passing a value of zero will effectively disable integral\n"
"gain. Passing a value of infinity disables IZone functionality.\n"
"\n"
":param iZone: Maximum magnitude of error to allow integral control. Must be\n"
"              >= 0.")
  )
  
  
  
    
  .
def
("getP", &frc::PIDController::GetP, release_gil(), py::doc(
    "Gets the proportional coefficient.\n"
"\n"
":returns: proportional coefficient")
  )
  
  
  
    
  .
def
("getI", &frc::PIDController::GetI, release_gil(), py::doc(
    "Gets the integral coefficient.\n"
"\n"
":returns: integral coefficient")
  )
  
  
  
    
  .
def
("getD", &frc::PIDController::GetD, release_gil(), py::doc(
    "Gets the differential coefficient.\n"
"\n"
":returns: differential coefficient")
  )
  
  
  
    
  .
def
("getIZone", &frc::PIDController::GetIZone, release_gil(), py::doc(
    "Get the IZone range.\n"
"\n"
":returns: Maximum magnitude of error to allow integral control.")
  )
  
  
  
    
  .
def
("getPeriod", &frc::PIDController::GetPeriod, release_gil(), py::doc(
    "Gets the period of this controller.\n"
"\n"
":returns: The period of the controller.")
  )
  
  
  
    
  .
def
("getPositionTolerance", &frc::PIDController::GetPositionTolerance, release_gil(), py::doc(
    "Gets the position tolerance of this controller.\n"
"\n"
":returns: The position tolerance of the controller.")
  )
  
  
  
    
  .
def
("getVelocityTolerance", &frc::PIDController::GetVelocityTolerance, release_gil(), py::doc(
    "Gets the velocity tolerance of this controller.\n"
"\n"
":returns: The velocity tolerance of the controller.")
  )
  
  
  
    
  .
def
("setSetpoint", &frc::PIDController::SetSetpoint,
      py::arg("setpoint"), release_gil(), py::doc(
    "Sets the setpoint for the PIDController.\n"
"\n"
":param setpoint: The desired setpoint.")
  )
  
  
  
    
  .
def
("getSetpoint", &frc::PIDController::GetSetpoint, release_gil(), py::doc(
    "Returns the current setpoint of the PIDController.\n"
"\n"
":returns: The current setpoint.")
  )
  
  
  
    
  .
def
("atSetpoint", &frc::PIDController::AtSetpoint, release_gil(), py::doc(
    "Returns true if the error is within the tolerance of the setpoint.\n"
"\n"
"This will return false until at least one input value has been computed.")
  )
  
  
  
    
  .
def
("enableContinuousInput", &frc::PIDController::EnableContinuousInput,
      py::arg("minimumInput"), py::arg("maximumInput"), release_gil(), py::doc(
    "Enables continuous input.\n"
"\n"
"Rather then using the max and min input range as constraints, it considers\n"
"them to be the same point and automatically calculates the shortest route\n"
"to the setpoint.\n"
"\n"
":param minimumInput: The minimum value expected from the input.\n"
":param maximumInput: The maximum value expected from the input.")
  )
  
  
  
    
  .
def
("disableContinuousInput", &frc::PIDController::DisableContinuousInput, release_gil(), py::doc(
    "Disables continuous input.")
  )
  
  
  
    
  .
def
("isContinuousInputEnabled", &frc::PIDController::IsContinuousInputEnabled, release_gil(), py::doc(
    "Returns true if continuous input is enabled.")
  )
  
  
  
    
  .
def
("setIntegratorRange", &frc::PIDController::SetIntegratorRange,
      py::arg("minimumIntegral"), py::arg("maximumIntegral"), release_gil(), py::doc(
    "Sets the minimum and maximum values for the integrator.\n"
"\n"
"When the cap is reached, the integrator value is added to the controller\n"
"output rather than the integrator value times the integral gain.\n"
"\n"
":param minimumIntegral: The minimum value of the integrator.\n"
":param maximumIntegral: The maximum value of the integrator.")
  )
  
  
  
    
  .
def
("setTolerance", &frc::PIDController::SetTolerance,
      py::arg("positionTolerance"), py::arg("velocityTolerance") = std::numeric_limits<double>::infinity (), release_gil(), py::doc(
    "Sets the error which is considered tolerable for use with AtSetpoint().\n"
"\n"
":param positionTolerance: Position error which is tolerable.\n"
":param velocityTolerance: Velocity error which is tolerable.")
  )
  
  
  
    
  .
def
("getPositionError", &frc::PIDController::GetPositionError, release_gil(), py::doc(
    "Returns the difference between the setpoint and the measurement.")
  )
  
  
  
    
  .
def
("getVelocityError", &frc::PIDController::GetVelocityError, release_gil(), py::doc(
    "Returns the velocity error.")
  )
  
  
  
    
  .
def
("calculate", static_cast<double(frc::PIDController::*)(double)>(
        &frc::PIDController::Calculate),
      py::arg("measurement"), release_gil(), py::doc(
    "Returns the next output of the PID controller.\n"
"\n"
":param measurement: The current measurement of the process variable.")
  )
  
  
  
    
  .
def
("calculate", static_cast<double(frc::PIDController::*)(double, double)>(
        &frc::PIDController::Calculate),
      py::arg("measurement"), py::arg("setpoint"), release_gil(), py::doc(
    "Returns the next output of the PID controller.\n"
"\n"
":param measurement: The current measurement of the process variable.\n"
":param setpoint:    The new setpoint of the controller.")
  )
  
  
  
    
  .
def
("reset", &frc::PIDController::Reset, release_gil(), py::doc(
    "Reset the previous error, the integral term, and disable the controller.")
  )
  
  
  
    
  .
def
("initSendable", &frc::PIDController::InitSendable,
      py::arg("builder"), release_gil()
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_PIDController_initializer

static std::unique_ptr<rpybuild_PIDController_initializer> cls;

void begin_init_PIDController(py::module &m) {
  cls = std::make_unique<rpybuild_PIDController_initializer>(m);
}

void finish_init_PIDController() {
  cls->finish();
  cls.reset();
}