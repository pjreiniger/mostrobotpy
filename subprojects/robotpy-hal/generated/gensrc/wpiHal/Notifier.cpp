
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <hal/Notifier.h>
















#include <type_traits>




struct rpybuild_Notifier_initializer {













  py::module &m;

  
  rpybuild_Notifier_initializer(py::module &m) :

  

  

  

  

    m(m)
  {
    
    

    
  }

void finish() {







m
  .
def
("initializeNotifier", []() {
                    int32_t status;
          auto __ret =::HAL_InitializeNotifier(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Initializes a notifier.\n"
"\n"
"A notifier is an FPGA controller timer that triggers at requested intervals\n"
"based on the FPGA time. This can be used to make precise control loops.\n"
"\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: the created notifier")
  )
  
  ;
m
  .
def
("setNotifierThreadPriority", [](HAL_Bool realTime, int32_t priority) {
                    int32_t status;
          auto __ret =::HAL_SetNotifierThreadPriority(std::move(realTime), std::move(priority), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("realTime"), py::arg("priority"), release_gil(), py::doc(
    "Sets the HAL notifier thread priority.\n"
"\n"
"The HAL notifier thread is responsible for managing the FPGA's notifier\n"
"interrupt and waking up user's Notifiers when it's their time to run.\n"
"Giving the HAL notifier thread real-time priority helps ensure the user's\n"
"real-time Notifiers, if any, are notified to run in a timely manner.\n"
"\n"
":param in:  realTime Set to true to set a real-time priority, false for\n"
"            standard priority.\n"
":param in:  priority Priority to set the thread to. For real-time, this is\n"
"            1-99 with 99 being highest. For non-real-time, this is\n"
"            forced to 0. See \"man 7 sched\" for more details.\n"
":param out: status  Error status variable. 0 on success.\n"
"\n"
":returns: True on success.")
  )
  
  ;
m
  .
def
("setNotifierName", [](HAL_NotifierHandle notifierHandle, const char* name) {
                    int32_t status;
          ::HAL_SetNotifierName(std::move(notifierHandle), name, &status);
          return status;
        },
      py::arg("notifierHandle"), py::arg("name"), release_gil(), py::doc(
    "Sets the name of a notifier.\n"
"\n"
":param in:  notifierHandle the notifier handle\n"
":param in:  name name\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("stopNotifier", [](HAL_NotifierHandle notifierHandle) {
                    int32_t status;
          ::HAL_StopNotifier(std::move(notifierHandle), &status);
          return status;
        },
      py::arg("notifierHandle"), release_gil(), py::doc(
    "Stops a notifier from running.\n"
"\n"
"This will cause any call into HAL_WaitForNotifierAlarm to return with time =\n"
"0.\n"
"\n"
":param in:  notifierHandle the notifier handle\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("cleanNotifier", &::HAL_CleanNotifier,
      py::arg("notifierHandle"), release_gil(), py::doc(
    "Cleans a notifier.\n"
"\n"
"Note this also stops a notifier if it is already running.\n"
"\n"
":param in: notifierHandle the notifier handle")
  )
  
  ;
m
  .
def
("updateNotifierAlarm", [](HAL_NotifierHandle notifierHandle, uint64_t triggerTime) {
                    int32_t status;
          ::HAL_UpdateNotifierAlarm(std::move(notifierHandle), std::move(triggerTime), &status);
          return status;
        },
      py::arg("notifierHandle"), py::arg("triggerTime"), release_gil(), py::doc(
    "Updates the trigger time for a notifier.\n"
"\n"
"Note that this time is an absolute time relative to HAL_GetFPGATime()\n"
"\n"
":param in:  notifierHandle the notifier handle\n"
":param in:  triggerTime    the updated trigger time\n"
":param out: status        Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("cancelNotifierAlarm", [](HAL_NotifierHandle notifierHandle) {
                    int32_t status;
          ::HAL_CancelNotifierAlarm(std::move(notifierHandle), &status);
          return status;
        },
      py::arg("notifierHandle"), release_gil(), py::doc(
    "Cancels the next notifier alarm.\n"
"\n"
"This does not cause HAL_WaitForNotifierAlarm to return.\n"
"\n"
":param in:  notifierHandle the notifier handle\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("waitForNotifierAlarm", [](HAL_NotifierHandle notifierHandle) {
                    int32_t status;
          auto __ret =::HAL_WaitForNotifierAlarm(std::move(notifierHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("notifierHandle"), release_gil(), py::doc(
    "Waits for the next alarm for the specific notifier.\n"
"\n"
"This is a blocking call until either the time elapses or HAL_StopNotifier\n"
"gets called. If the latter occurs, this function will return zero and any\n"
"loops using this function should exit. Failing to do so can lead to\n"
"use-after-frees.\n"
"\n"
":param in:  notifierHandle the notifier handle\n"
":param out: status        Error status variable. 0 on success.\n"
"\n"
":returns: the FPGA time the notifier returned")
  )
  
  ;



}

}; // struct rpybuild_Notifier_initializer

static std::unique_ptr<rpybuild_Notifier_initializer> cls;

void begin_init_Notifier(py::module &m) {
  cls = std::make_unique<rpybuild_Notifier_initializer>(m);
}

void finish_init_Notifier() {
  cls->finish();
  cls.reset();
}