
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <hal/SimDevice.h>


#include <wpi_smallvector_type_caster.h>

#include <wpi_span_type_caster.h>













#include <hal/simulation/SimDeviceData.h>



#include <type_traits>


  using namespace hal;





struct rpybuild_SimDevice_initializer {


  

  


  

  


  

  


  

  


  

  


  

  


  

  







  
  py::enum_<::HAL_SimValueDirection> enum1;






  py::class_<typename hal::SimValue> cls_SimValue;

    

    
    
  py::class_<typename hal::SimInt, hal::SimValue> cls_SimInt;

    

    
    
  py::class_<typename hal::SimLong, hal::SimValue> cls_SimLong;

    

    
    
  py::class_<typename hal::SimDouble, hal::SimValue> cls_SimDouble;

    

    
    
  py::class_<typename hal::SimEnum, hal::SimValue> cls_SimEnum;

    

    
    
  py::class_<typename hal::SimBoolean, hal::SimValue> cls_SimBoolean;

    

    
    
  py::class_<typename hal::SimDevice> cls_SimDevice;

    
    
  py::enum_<hal::SimDevice::Direction> cls_SimDevice_enum1;
    

    
    

  py::module &m;

  
  rpybuild_SimDevice_initializer(py::module &m) :

  

  
    enum1
  (m, "SimValueDirection"
  ,
    "Direction of a simulated value (from the perspective of user code)."),
  

  

  
    cls_SimValue(m, "SimValue"),

  

  
  
  
    cls_SimInt(m, "SimInt"),

  

  
  
  
    cls_SimLong(m, "SimLong"),

  

  
  
  
    cls_SimDouble(m, "SimDouble"),

  

  
  
  
    cls_SimEnum(m, "SimEnum"),

  

  
  
  
    cls_SimBoolean(m, "SimBoolean"),

  

  
  
  
    cls_SimDevice(m, "SimDevice"),

  
    cls_SimDevice_enum1
  (cls_SimDevice, "Direction"
  ,
    "Direction of a simulated value (from the perspective of user code)."),
  

  
  
  

    m(m)
  {
    
    
      enum1
  
    .value("HAL_SimValueInput", ::HAL_SimValueDirection::HAL_SimValueInput,
      "input to user code from the simulator")
  
    .value("HAL_SimValueOutput", ::HAL_SimValueDirection::HAL_SimValueOutput,
      "output from user code to the simulator")
  
    .value("HAL_SimValueBidir", ::HAL_SimValueDirection::HAL_SimValueBidir,
      "bidirectional between user code and simulator")
  ;

    

    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  
    cls_SimDevice_enum1
  
    .value("kInput", hal::SimDevice::Direction::kInput)
  
    .value("kOutput", hal::SimDevice::Direction::kOutput)
  
    .value("kBidir", hal::SimDevice::Direction::kBidir)
  ;

  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_SimValue.doc() =
    "Readonly wrapper around a HAL simulator value.\n"
"\n"
"It is not useful to construct these directly -- they are returned from\n"
":meth:`.SimDeviceSim.getValue` or :meth:`.SimDevice.createValue`.\n";

  cls_SimValue
  
    
  .def(py::init<HAL_SimValueHandle>(),
      py::arg("handle"), release_gil(), py::doc(
    "Wraps a simulated value handle as returned by HAL_CreateSimValue().\n"
"\n"
":param handle: simulated value handle")
  )
  
  
  ;

  


  }

  {
  
  
  


  

  cls_SimInt.doc() =
    "Wrapper around a HAL simulator int value handle.\n"
"\n"
"It is not useful to construct these directly, they are returned\n"
"from various functions.\n";

  cls_SimInt
  
    
  .def(py::init<HAL_SimValueHandle>(),
      py::arg("handle"), release_gil(), py::doc(
    "Wraps a simulated value handle as returned by HAL_CreateSimValueInt().\n"
"\n"
":param handle: simulated value handle")
  )
  
  
  
    
  .
def
("get", &hal::SimInt::Get, release_gil(), py::doc(
    "Gets the simulated value.\n"
"\n"
":returns: The current value")
  )
  
  
  
    
  .
def
("set", &hal::SimInt::Set,
      py::arg("value"), release_gil(), py::doc(
    "Sets the simulated value.\n"
"\n"
":param value: the value to set")
  )
  
  
  
    
  .
def
("reset", &hal::SimInt::Reset, release_gil(), py::doc(
    "Resets the simulated value to 0. Use this instead of Set(0) for resetting\n"
"incremental sensor values like encoder counts or gyro accumulated angle\n"
"to ensure correct behavior in a distributed system (e.g. WebSockets).")
  )
  
  
  ;

  


  }

  {
  
  
  


  

  cls_SimLong.doc() =
    "Wrapper around a HAL simulator long value handle.\n"
"\n"
"It is not useful to construct these directly, they are returned\n"
"from various functions.\n";

  cls_SimLong
  
    
  .def(py::init<HAL_SimValueHandle>(),
      py::arg("handle"), release_gil(), py::doc(
    "Wraps a simulated value handle as returned by HAL_CreateSimValueLong().\n"
"\n"
":param handle: simulated value handle")
  )
  
  
  
    
  .
def
("get", &hal::SimLong::Get, release_gil(), py::doc(
    "Gets the simulated value.\n"
"\n"
":returns: The current value")
  )
  
  
  
    
  .
def
("set", &hal::SimLong::Set,
      py::arg("value"), release_gil(), py::doc(
    "Sets the simulated value.\n"
"\n"
":param value: the value to set")
  )
  
  
  
    
  .
def
("reset", &hal::SimLong::Reset, release_gil(), py::doc(
    "Resets the simulated value to 0. Use this instead of Set(0) for resetting\n"
"incremental sensor values like encoder counts or gyro accumulated angle\n"
"to ensure correct behavior in a distributed system (e.g. WebSockets).")
  )
  
  
  ;

  


  }

  {
  
  
  


  

  cls_SimDouble.doc() =
    "Wrapper around a HAL simulator double value.\n"
"\n"
"It is not useful to construct these directly -- they are returned from\n"
":meth:`.SimDeviceSim.getDouble` or :meth:`.SimDevice.createDouble`.\n";

  cls_SimDouble
  
    
  .def(py::init<HAL_SimValueHandle>(),
      py::arg("handle"), release_gil(), py::doc(
    "Wraps a simulated value handle as returned by HAL_CreateSimValueDouble().\n"
"\n"
":param handle: simulated value handle")
  )
  
  
  
    
  .
def
("get", &hal::SimDouble::Get, release_gil(), py::doc(
    "Gets the simulated value.\n"
"\n"
":returns: The current value")
  )
  
  
  
    
  .
def
("set", &hal::SimDouble::Set,
      py::arg("value"), release_gil(), py::doc(
    "Sets the simulated value.\n"
"\n"
":param value: the value to set")
  )
  
  
  
    
  .
def
("reset", &hal::SimDouble::Reset, release_gil(), py::doc(
    "Resets the simulated value to 0. Use this instead of Set(0) for resetting\n"
"incremental sensor values like encoder counts or gyro accumulated angle\n"
"to ensure correct behavior in a distributed system (e.g. WebSockets).")
  )
  
  
  ;

  


  }

  {
  
  
  


  

  cls_SimEnum.doc() =
    "Wrapper around a HAL simulator enum value.\n"
"\n"
"It is not useful to construct these directly -- they are returned from\n"
":meth:`.SimDeviceSim.getEnum` or :meth:`.SimDevice.createEnum`.\n";

  cls_SimEnum
  
    
  .def(py::init<HAL_SimValueHandle>(),
      py::arg("handle"), release_gil(), py::doc(
    "Wraps a simulated value handle as returned by HAL_CreateSimValueEnum().\n"
"\n"
":param handle: simulated value handle")
  )
  
  
  
    
  .
def
("get", &hal::SimEnum::Get, release_gil(), py::doc(
    "Gets the simulated value.\n"
"\n"
":returns: The current value")
  )
  
  
  
    
  .
def
("set", &hal::SimEnum::Set,
      py::arg("value"), release_gil(), py::doc(
    "Sets the simulated value.\n"
"\n"
":param value: the value to set")
  )
  
  
  ;

  


  }

  {
  
  
  


  

  cls_SimBoolean.doc() =
    "Wrapper around a HAL simulator boolean value.\n"
"\n"
"It is not useful to construct these directly -- they are returned from\n"
":meth:`.SimDeviceSim.getBoolean` or :meth:`.SimDevice.createBoolean`.\n";

  cls_SimBoolean
  
    
  .def(py::init<HAL_SimValueHandle>(),
      py::arg("handle"), release_gil(), py::doc(
    "Wraps a simulated value handle as returned by HAL_CreateSimValueBoolean().\n"
"\n"
":param handle: simulated value handle")
  )
  
  
  
    
  .
def
("get", &hal::SimBoolean::Get, release_gil(), py::doc(
    "Gets the simulated value.\n"
"\n"
":returns: The current value")
  )
  
  
  
    
  .
def
("set", &hal::SimBoolean::Set,
      py::arg("value"), release_gil(), py::doc(
    "Sets the simulated value.\n"
"\n"
":param value: the value to set")
  )
  
  
  ;

  


  }

  {
  
  
  using Direction [[maybe_unused]] = typename hal::SimDevice::Direction;
  
  


  

  cls_SimDevice.doc() =
    "Wrapper around a HAL simulation 'device'\n"
"\n"
"This creates a simulated 'device' object that can be interacted with\n"
"from user SimDeviceSim objects or via the Simulation GUI.\n"
"\n"
".. note:: To interact with an existing device use\n"
"          :class:`hal.simulation.SimDeviceSim` instead.\n";

  cls_SimDevice
  
    
  .def(py::init<const char*>(),
      py::arg("name"), release_gil(), py::doc(
    "Creates a simulated device.\n"
"\n"
"The device name must be unique.  Returns null if the device name\n"
"already exists.  If multiple instances of the same device are desired,\n"
"recommend appending the instance/unique identifier in brackets to the base\n"
"name, e.g. \"device[1]\".\n"
"\n"
"If not in simulation, results in an \"empty\" object that evaluates to false\n"
"in a boolean context.\n"
"\n"
":param name: device name")
  )
  
  
  
    
  .def(py::init<const char*, int>(),
      py::arg("name"), py::arg("index"), release_gil(), py::doc(
    "Creates a simulated device.\n"
"\n"
"The device name must be unique.  Returns null if the device name\n"
"already exists.  This is a convenience method that appends index in\n"
"brackets to the device name, e.g. passing index=1 results in \"device[1]\"\n"
"for the device name.\n"
"\n"
"If not in simulation, results in an \"empty\" object that evaluates to false\n"
"in a boolean context.\n"
"\n"
":param name:  device name\n"
":param index: device index number to append to name")
  )
  
  
  
    
  .def(py::init<const char*, int, int>(),
      py::arg("name"), py::arg("index"), py::arg("channel"), release_gil(), py::doc(
    "Creates a simulated device.\n"
"\n"
"The device name must be unique.  Returns null if the device name\n"
"already exists.  This is a convenience method that appends index and\n"
"channel in brackets to the device name, e.g. passing index=1 and channel=2\n"
"results in \"device[1,2]\" for the device name.\n"
"\n"
"If not in simulation, results in an \"empty\" object that evaluates to false\n"
"in a boolean context.\n"
"\n"
":param name:    device name\n"
":param index:   device index number to append to name\n"
":param channel: device channel number to append to name")
  )
  
  
  
    
  .
def
("getName", &hal::SimDevice::GetName, release_gil(), py::doc(
    "Get the name of the simulated device.\n"
"\n"
":returns: name")
  )
  
  
  
    
  .
def
("createInt", &hal::SimDevice::CreateInt,
      py::arg("name"), py::arg("direction"), py::arg("initialValue"), release_gil(), py::doc(
    "Creates an int value on the simulated device.\n"
"\n"
"If not in simulation, results in an \"empty\" object that evaluates to false\n"
"in a boolean context.\n"
"\n"
":param name:         value name\n"
":param direction:    input/output/bidir (from perspective of user code)\n"
":param initialValue: initial value\n"
"\n"
":returns: simulated double value object")
  )
  
  
  
    
  .
def
("createLong", &hal::SimDevice::CreateLong,
      py::arg("name"), py::arg("direction"), py::arg("initialValue"), release_gil(), py::doc(
    "Creates a long value on the simulated device.\n"
"\n"
"If not in simulation, results in an \"empty\" object that evaluates to false\n"
"in a boolean context.\n"
"\n"
":param name:         value name\n"
":param direction:    input/output/bidir (from perspective of user code)\n"
":param initialValue: initial value\n"
"\n"
":returns: simulated double value object")
  )
  
  
  
    
  .
def
("createDouble", &hal::SimDevice::CreateDouble,
      py::arg("name"), py::arg("direction"), py::arg("initialValue"), release_gil(), py::doc(
    "Creates a double value on the simulated device.\n"
"\n"
"If not in simulation, results in an \"empty\" object that evaluates to false\n"
"in a boolean context.\n"
"\n"
":param name:         value name\n"
":param direction:    input/output/bidir (from perspective of user code)\n"
":param initialValue: initial value\n"
"\n"
":returns: simulated double value object")
  )
  
  
  
    
  .
def
("createEnum", [](SimDevice &self, const char * name, int32_t direction, const wpi::SmallVector<std::string, 8> &options, int32_t initialValue) {
  wpi::SmallVector<const char *, 8> coptions;
  coptions.reserve(options.size());
  for (auto s: options) {
    coptions.push_back(s.c_str());
  }
  return self.CreateEnum(name, direction, coptions, initialValue);
}
,
      py::arg("name"), py::arg("direction"), py::arg("options"), py::arg("initialValue"), py::doc(
    "Creates an enumerated value on the simulated device.\n"
"\n"
"Enumerated values are always in the range 0 to numOptions-1.\n"
"\n"
"If not in simulation, results in an \"empty\" object that evaluates to false\n"
"in a boolean context.\n"
"\n"
":param name:         value name\n"
":param direction:    input/output/bidir (from perspective of user code)\n"
":param options:      array of option descriptions\n"
":param initialValue: initial value (selection)\n"
"\n"
":returns: simulated enum value object")
  )
  
  
  
    
  .
def
("createEnumDouble", [](SimDevice &self, const char * name, int32_t direction, const wpi::SmallVector<std::string, 8> &options, const wpi::SmallVector<double, 8> &optionValues, int32_t initialValue) {
  wpi::SmallVector<const char *, 8> coptions;
  coptions.reserve(options.size());
  for (auto s: options) {
    coptions.push_back(s.c_str());
  }
  return self.CreateEnumDouble(name, direction, coptions, optionValues, initialValue);
}
,
      py::arg("name"), py::arg("direction"), py::arg("options"), py::arg("optionValues"), py::arg("initialValue"), py::doc(
    "Creates an enumerated value on the simulated device with double values.\n"
"\n"
"Enumerated values are always in the range 0 to numOptions-1.\n"
"\n"
"If not in simulation, results in an \"empty\" object that evaluates to false\n"
"in a boolean context.\n"
"\n"
":param name:         value name\n"
":param direction:    input/output/bidir (from perspective of user code)\n"
":param options:      array of option descriptions\n"
":param optionValues: array of option values (must be the same size as\n"
"                     options)\n"
":param initialValue: initial value (selection)\n"
"\n"
":returns: simulated enum value object")
  )
  
  
  
    
  .
def
("createBoolean", &hal::SimDevice::CreateBoolean,
      py::arg("name"), py::arg("direction"), py::arg("initialValue"), release_gil(), py::doc(
    "Creates a boolean value on the simulated device.\n"
"\n"
"If not in simulation, results in an \"empty\" object that evaluates to false\n"
"in a boolean context.\n"
"\n"
":param name:         value name\n"
":param direction:    input/output/bidir (from perspective of user code)\n"
":param initialValue: initial value\n"
"\n"
":returns: simulated boolean value object")
  )
  
  
  ;

  


  }







  
cls_SimValue
  .def_property_readonly("value", [](const hal::SimValue &self) -> py::object {
      HAL_Value value;
      {
        py::gil_scoped_release release;
        value = self.GetValue();
      }
      switch (value.type) {
      case HAL_BOOLEAN:
        return py::bool_(value.data.v_boolean);
      case HAL_DOUBLE:
        return py::float_(value.data.v_double);
      case HAL_ENUM:
        return py::int_(value.data.v_enum);
      case HAL_INT:
        return py::int_(value.data.v_int);
      case HAL_LONG:
        return py::int_(value.data.v_long);
      default: 
        return py::none();
      }
  })
  .def_property_readonly("type", [](const hal::SimValue &self) -> HAL_Type {
    py::gil_scoped_release release;
    return self.GetValue().type;
  })
  .def("__bool__", [](const hal::SimValue &self) -> bool {
    return (bool)self;
  })
  .def("__repr__", [](const hal::SimValue &self) -> py::str {
      if (!self) {
        return "<SimValue (invalid)>";
      }
      HAL_Value value;
      {
        py::gil_scoped_release release;
        value = self.GetValue();
      }
      switch (value.type) {
      case HAL_BOOLEAN:
        if (value.data.v_boolean) {
          return "<SimValue (bool) True>";
        } else {
          return "<SimValue (bool) False>";
        }
      case HAL_DOUBLE:
        return "<SimValue (double) " + std::to_string(value.data.v_double) + ">";
      case HAL_ENUM:
        return "<SimValue (enum) " + std::to_string(value.data.v_enum) + ">";
      case HAL_INT:
        return "<SimValue (int) " + std::to_string(value.data.v_int) + ">";
      case HAL_LONG:
        return "<SimValue (long) " + std::to_string(value.data.v_long) + ">";
      default:
        return "<SimValue (unknown)>";
      }
  });

cls_SimBoolean
  .def_property("value", &SimBoolean::Get, &SimBoolean::Set, release_gil())
  .def("__repr__", [](const SimBoolean &self) -> py::str {
    if (self) {
      py::gil_scoped_release release;
      return std::string("<SimBoolean value=") + (self.Get() ? "True" : "False") + ">";
    } else {
      return "<SimBoolean (invalid)>";
    }
  });

cls_SimDevice
  .def("__bool__", [](const hal::SimDevice &self) -> bool {
    return (bool)self;
  })
  .def_property_readonly("name", [](const hal::SimDevice &self) -> py::str {
    #ifdef __FRC_ROBORIO__
      return "<invalid>";
    #else
      if (!self) {
        return "<invalid>";
      } else {
        py::gil_scoped_release release;
        return HALSIM_GetSimDeviceName(self);
      }
    #endif
  })
  .def("__repr__", [](const hal::SimDevice &self) -> py::str {
    #ifdef __FRC_ROBORIO__
      return "<SimDevice (invalid)>";
    #else
      if (!self) {
        return "<SimDevice (invalid)>";
      }
      const char *name;
      {
        py::gil_scoped_release release;
        name = HALSIM_GetSimDeviceName(self);
      }
      return py::str("SimDevice(name={!r})").format(py::str(name));
    #endif
  });

cls_SimDouble
  .def_property("value", &SimDouble::Get, &SimDouble::Set, release_gil())
  .def("__repr__", [](const SimDouble &self) -> py::str {
    if (self) {
      py::gil_scoped_release release;
      return "<SimDouble value=" + std::to_string(self.Get()) + ">";
    } else {
      return "<SimDouble (invalid)>";
    }
  });

cls_SimEnum
  .def_property("value", &SimEnum::Get, &SimEnum::Set)
  .def("__repr__", [](const SimEnum &self) -> py::str {
    #ifdef __FRC_ROBORIO__
      return "<SimEnum (invalid)>";
    #else
      if (self) {
        int32_t value;
        int32_t numOptions;
        const char ** options;
        const char * option = "<unknown>";
        {
          py::gil_scoped_release release;
          value = self.Get();
          options = HALSIM_GetSimValueEnumOptions(self, &numOptions);
        }

        if (options && value >= 0 && value < numOptions) {
          option = options[value];
        }

        return "<SimEnum name=" + std::string(option) +
                      " value=" + std::to_string(value) + ">";
      } else {
        return "<SimEnum (invalid)>";
      }
    #endif
  });

cls_SimInt
  .def_property("value", &SimInt::Get, &SimInt::Set)
  .def("__repr__", [](const SimInt &self) -> py::str {
    if (self) {
      py::gil_scoped_release release;
      return "<SimInt value=" + std::to_string(self.Get()) + ">";
    } else {
      return "<SimInt (invalid)>";
    }
  });

cls_SimLong
  .def_property("value", &SimLong::Get, &SimLong::Set)
  .def("__repr__", [](const SimLong &self) -> py::str {
    if (self) {
      py::gil_scoped_release release;
      return "<SimLong value=" + std::to_string(self.Get()) + ">";
    } else {
      return "<SimLong (invalid)>";
    }
  });


}

}; // struct rpybuild_SimDevice_initializer

static std::unique_ptr<rpybuild_SimDevice_initializer> cls;

void begin_init_SimDevice(py::module &m) {
  cls = std::make_unique<rpybuild_SimDevice_initializer>(m);
}

void finish_init_SimDevice() {
  cls->finish();
  cls.reset();
}