
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <hal/HALBase.h>
















#include <type_traits>






struct rpybuild_HALBase_initializer {







  
  py::enum_<::HAL_RuntimeType> enum1;







  py::module &m;

  
  rpybuild_HALBase_initializer(py::module &m) :

  

  
    enum1
  (m, "RuntimeType"
  ),
  

  

  

    m(m)
  {
    
    
      enum1
  
    .value("HAL_Runtime_RoboRIO", ::HAL_RuntimeType::HAL_Runtime_RoboRIO)
  
    .value("HAL_Runtime_RoboRIO2", ::HAL_RuntimeType::HAL_Runtime_RoboRIO2)
  
    .value("HAL_Runtime_Simulation", ::HAL_RuntimeType::HAL_Runtime_Simulation)
  ;

    

    
  }

void finish() {







m
  .
def
("getLastError", []() {
                    int32_t status;
          auto __ret =::HAL_GetLastError(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Gets the last error set on this thread, or the message for the status code.\n"
"\n"
"If passed HAL_USE_LAST_ERROR, the last error set on the thread will be\n"
"returned.\n"
"\n"
":param out: status the status code, set to the error status code if input is\n"
"            HAL_USE_LAST_ERROR\n"
"\n"
":returns: the error message for the code. This does not need to be freed,\n"
"          but can be overwritten by another hal call on the same thread.")
  )
  
  ;
m
  .
def
("getErrorMessage", &::HAL_GetErrorMessage,
      py::arg("code"), release_gil(), py::doc(
    "Gets the error message for a specific status code.\n"
"\n"
":param code: the status code\n"
"\n"
":returns: the error message for the code. This does not need to be freed.")
  )
  
  ;
m
  .
def
("getFPGAVersion", []() {
                    int32_t status;
          auto __ret =::HAL_GetFPGAVersion(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Returns the FPGA Version number.\n"
"\n"
"For now, expect this to be competition year.\n"
"\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: FPGA Version number.")
  )
  
  ;
m
  .
def
("getFPGARevision", []() {
                    int32_t status;
          auto __ret =::HAL_GetFPGARevision(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Returns the FPGA Revision number.\n"
"\n"
"The format of the revision is 3 numbers.\n"
"The 12 most significant bits are the Major Revision.\n"
"the next 8 bits are the Minor Revision.\n"
"The 12 least significant bits are the Build Number.\n"
"\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: FPGA Revision number.")
  )
  
  ;
m
  .
def
("getSerialNumber", [](size_t size) {
                    char buffer;
          auto __ret =::HAL_GetSerialNumber(&buffer, std::move(size));
          return std::make_tuple(__ret,buffer);
        },
      py::arg("size"), release_gil(), py::doc(
    "Returns the roboRIO serial number.\n"
"\n"
":param out:  buffer The roboRIO serial number.\n"
":param size: The maximum characters to copy into buffer.\n"
"\n"
":returns: Number of characters copied into buffer.")
  )
  
  ;
m
  .
def
("getComments", [](size_t size) {
                    char buffer;
          auto __ret =::HAL_GetComments(&buffer, std::move(size));
          return std::make_tuple(__ret,buffer);
        },
      py::arg("size"), release_gil(), py::doc(
    "Returns the comments from the roboRIO web interface.\n"
"\n"
":param out:  buffer The comments string.\n"
":param size: The maximum characters to copy into buffer.\n"
"\n"
":returns: Number of characters copied into buffer.")
  )
  
  ;
m
  .
def
("getTeamNumber", &::HAL_GetTeamNumber, release_gil(), py::doc(
    "Returns the team number configured for the robot controller.\n"
"\n"
":returns: team number, or 0 if not found.")
  )
  
  ;
m
  .
def
("getRuntimeType", &::HAL_GetRuntimeType, release_gil(), py::doc(
    "Returns the runtime type of the HAL.\n"
"\n"
":returns: HAL Runtime Type")
  )
  
  ;
m
  .
def
("getFPGAButton", []() {
                    int32_t status;
          auto __ret =::HAL_GetFPGAButton(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Gets the state of the \"USER\" button on the roboRIO.\n"
"\n"
"@warning the User Button is used to stop user programs from automatically\n"
"loading if it is held for more then 5 seconds. Because of this, it's not\n"
"recommended to be used by teams for any other purpose.\n"
"\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: true if the button is currently pressed down")
  )
  
  ;
m
  .
def
("getSystemActive", []() {
                    int32_t status;
          auto __ret =::HAL_GetSystemActive(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Gets if the system outputs are currently active.\n"
"\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: true if the system outputs are active, false if disabled")
  )
  
  ;
m
  .
def
("getBrownedOut", []() {
                    int32_t status;
          auto __ret =::HAL_GetBrownedOut(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Gets if the system is in a browned out state.\n"
"\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: true if the system is in a low voltage brown out, false otherwise")
  )
  
  ;
m
  .
def
("getPort", &::HAL_GetPort,
      py::arg("channel"), release_gil(), py::doc(
    "Gets a port handle for a specific channel.\n"
"\n"
"The created handle does not need to be freed.\n"
"\n"
":param channel: the channel number\n"
"\n"
":returns: the created port")
  )
  
  ;
m
  .
def
("getPortWithModule", &::HAL_GetPortWithModule,
      py::arg("module"), py::arg("channel"), release_gil(), py::doc(
    "Gets a port handle for a specific channel and module.\n"
"\n"
"This is expected to be used for PCMs, as the roboRIO does not work with\n"
"modules anymore.\n"
"\n"
"The created handle does not need to be freed.\n"
"\n"
":param module:  the module number\n"
":param channel: the channel number\n"
"\n"
":returns: the created port")
  )
  
  ;
m
  .
def
("getFPGATime", []() {
                    int32_t status;
          auto __ret =::HAL_GetFPGATime(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Reads the microsecond-resolution timer on the FPGA.\n"
"\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: The current time in microseconds according to the FPGA (since FPGA\n"
"          reset).")
  )
  
  ;
m
  .
def
("expandFPGATime", [](uint32_t unexpandedLower) {
                    int32_t status;
          auto __ret =::HAL_ExpandFPGATime(std::move(unexpandedLower), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("unexpandedLower"), release_gil(), py::doc(
    "Given an 32 bit FPGA time, expand it to the nearest likely 64 bit FPGA time.\n"
"\n"
"Note: This is making the assumption that the timestamp being converted is\n"
"always in the past.  If you call this with a future timestamp, it probably\n"
"will make it in the past.  If you wait over 70 minutes between capturing the\n"
"bottom 32 bits of the timestamp and expanding it, you will be off by\n"
"multiples of 1<<32 microseconds.\n"
"\n"
":param in:  unexpandedLower 32 bit FPGA time\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: The current time in microseconds according to the FPGA (since FPGA\n"
"          reset) as a 64 bit number.")
  )
  
  ;
m
  .
def
("getRSLState", []() {
                    int32_t status;
          auto __ret =::HAL_GetRSLState(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Gets the current state of the Robot Signal Light (RSL).\n"
"\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: The current state of the RSL- true if on, false if off")
  )
  
  ;
m
  .
def
("getSystemTimeValid", []() {
                    int32_t status;
          auto __ret =::HAL_GetSystemTimeValid(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Gets if the system time is valid.\n"
"\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: True if the system time is valid, false otherwise")
  )
  
  ;
m
  .
def
("initialize", &::HAL_Initialize,
      py::arg("timeout"), py::arg("mode"), release_gil(), py::doc(
    "Call this to start up HAL. This is required for robot programs.\n"
"\n"
"This must be called before any other HAL functions. Failure to do so will\n"
"result in undefined behavior, and likely segmentation faults. This means that\n"
"any statically initialized variables in a program MUST call this function in\n"
"their constructors if they want to use other HAL calls.\n"
"\n"
"The common parameters are 500 for timeout and 0 for mode.\n"
"\n"
"This function is safe to call from any thread, and as many times as you wish.\n"
"It internally guards from any reentrancy.\n"
"\n"
"The applicable modes are:\n"
"0: Try to kill an existing HAL from another program, if not successful,\n"
"error.\n"
"1: Force kill a HAL from another program.\n"
"2: Just warn if another hal exists and cannot be killed. Will likely result\n"
"in undefined behavior.\n"
"\n"
":param timeout: the initialization timeout (ms)\n"
":param mode:    the initialization mode (see remarks)\n"
"\n"
":returns: true if initialization was successful, otherwise false.")
  )
  
  ;
m
  .
def
("shutdown", &::HAL_Shutdown, release_gil(), py::doc(
    "Call this to shut down HAL.\n"
"\n"
"This must be called at termination of the robot program to avoid potential\n"
"segmentation faults with simulation extensions at exit.")
  )
  
  ;
m
  .
def
("simPeriodicBefore", &::HAL_SimPeriodicBefore, release_gil(), py::doc(
    "Calls registered SimPeriodic \"before\" callbacks (only in simulation mode).\n"
"This should be called prior to user code periodic simulation functions.")
  )
  
  ;
m
  .
def
("simPeriodicAfter", &::HAL_SimPeriodicAfter, release_gil(), py::doc(
    "Calls registered SimPeriodic \"after\" callbacks (only in simulation mode).\n"
"This should be called after user code periodic simulation functions.")
  )
  
  ;



}

}; // struct rpybuild_HALBase_initializer

static std::unique_ptr<rpybuild_HALBase_initializer> cls;

void begin_init_HALBase(py::module &m) {
  cls = std::make_unique<rpybuild_HALBase_initializer>(m);
}

void finish_init_HALBase() {
  cls->finish();
  cls.reset();
}