
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <hal/Power.h>
















#include <type_traits>




struct rpybuild_Power_initializer {













  py::module &m;

  
  rpybuild_Power_initializer(py::module &m) :

  

  

  

  

    m(m)
  {
    
    

    
  }

void finish() {







m
  .
def
("getVinVoltage", []() {
                    int32_t status;
          auto __ret =::HAL_GetVinVoltage(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Gets the roboRIO input voltage.\n"
"\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: the input voltage (volts)")
  )
  
  ;
m
  .
def
("getVinCurrent", []() {
                    int32_t status;
          auto __ret =::HAL_GetVinCurrent(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Gets the roboRIO input current.\n"
"\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: the input current (amps)")
  )
  
  ;
m
  .
def
("getUserVoltage6V", []() {
                    int32_t status;
          auto __ret =::HAL_GetUserVoltage6V(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Gets the 6V rail voltage.\n"
"\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: the 6V rail voltage (volts)")
  )
  
  ;
m
  .
def
("getUserCurrent6V", []() {
                    int32_t status;
          auto __ret =::HAL_GetUserCurrent6V(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Gets the 6V rail current.\n"
"\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: the 6V rail current (amps)")
  )
  
  ;
m
  .
def
("getUserActive6V", []() {
                    int32_t status;
          auto __ret =::HAL_GetUserActive6V(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Gets the active state of the 6V rail.\n"
"\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: true if the rail is active, otherwise false")
  )
  
  ;
m
  .
def
("getUserCurrentFaults6V", []() {
                    int32_t status;
          auto __ret =::HAL_GetUserCurrentFaults6V(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Gets the fault count for the 6V rail. Capped at 255.\n"
"\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: the number of 6V fault counts")
  )
  
  ;
m
  .
def
("setUserRailEnabled6V", [](HAL_Bool enabled) {
                    int32_t status;
          ::HAL_SetUserRailEnabled6V(std::move(enabled), &status);
          return status;
        },
      py::arg("enabled"), release_gil(), py::doc(
    "Enables or disables the 6V rail.\n"
"\n"
":param enabled: whether the rail should be enabled\n"
":param out:     status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("getUserVoltage5V", []() {
                    int32_t status;
          auto __ret =::HAL_GetUserVoltage5V(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Gets the 5V rail voltage.\n"
"\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: the 5V rail voltage (volts)")
  )
  
  ;
m
  .
def
("getUserCurrent5V", []() {
                    int32_t status;
          auto __ret =::HAL_GetUserCurrent5V(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Gets the 5V rail current.\n"
"\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: the 5V rail current (amps)")
  )
  
  ;
m
  .
def
("getUserActive5V", []() {
                    int32_t status;
          auto __ret =::HAL_GetUserActive5V(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Gets the active state of the 5V rail.\n"
"\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: true if the rail is active, otherwise false")
  )
  
  ;
m
  .
def
("getUserCurrentFaults5V", []() {
                    int32_t status;
          auto __ret =::HAL_GetUserCurrentFaults5V(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Gets the fault count for the 5V rail. Capped at 255.\n"
"\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: the number of 5V fault counts")
  )
  
  ;
m
  .
def
("setUserRailEnabled5V", [](HAL_Bool enabled) {
                    int32_t status;
          ::HAL_SetUserRailEnabled5V(std::move(enabled), &status);
          return status;
        },
      py::arg("enabled"), release_gil(), py::doc(
    "Enables or disables the 5V rail.\n"
"\n"
":param enabled: whether the rail should be enabled\n"
":param out:     status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("getUserVoltage3V3", []() {
                    int32_t status;
          auto __ret =::HAL_GetUserVoltage3V3(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Gets the 3V3 rail voltage.\n"
"\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: the 3V3 rail voltage (volts)")
  )
  
  ;
m
  .
def
("getUserCurrent3V3", []() {
                    int32_t status;
          auto __ret =::HAL_GetUserCurrent3V3(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Gets the 3V3 rail current.\n"
"\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: the 3V3 rail current (amps)")
  )
  
  ;
m
  .
def
("getUserActive3V3", []() {
                    int32_t status;
          auto __ret =::HAL_GetUserActive3V3(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Gets the active state of the 3V3 rail.\n"
"\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: true if the rail is active, otherwise false")
  )
  
  ;
m
  .
def
("getUserCurrentFaults3V3", []() {
                    int32_t status;
          auto __ret =::HAL_GetUserCurrentFaults3V3(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Gets the fault count for the 3V3 rail. Capped at 255.\n"
"\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: the number of 3V3 fault counts")
  )
  
  ;
m
  .
def
("setUserRailEnabled3V3", [](HAL_Bool enabled) {
                    int32_t status;
          ::HAL_SetUserRailEnabled3V3(std::move(enabled), &status);
          return status;
        },
      py::arg("enabled"), release_gil(), py::doc(
    "Enables or disables the 3V3 rail.\n"
"\n"
":param enabled: whether the rail should be enabled\n"
":param out:     status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("resetUserCurrentFaults", []() {
                    int32_t status;
          ::HAL_ResetUserCurrentFaults(&status);
          return status;
        }, release_gil(), py::doc(
    "Resets the overcurrent fault counters for all user rails to 0.\n"
"\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("getBrownoutVoltage", []() {
                    int32_t status;
          auto __ret =::HAL_GetBrownoutVoltage(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Get the current brownout voltage setting.\n"
"\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: The brownout voltage")
  )
  
  ;
m
  .
def
("setBrownoutVoltage", [](double voltage) {
                    int32_t status;
          ::HAL_SetBrownoutVoltage(std::move(voltage), &status);
          return status;
        },
      py::arg("voltage"), release_gil(), py::doc(
    "Set the voltage the roboRIO will brownout and disable all outputs.\n"
"\n"
"Note that this only does anything on the roboRIO 2.\n"
"On the roboRIO it is a no-op.\n"
"\n"
":param in:  voltage The brownout voltage\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("getCPUTemp", []() {
                    int32_t status;
          auto __ret =::HAL_GetCPUTemp(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Get the current CPU temperature in degrees Celsius\n"
"\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: current CPU temperature in degrees Celsius")
  )
  
  ;



}

}; // struct rpybuild_Power_initializer

static std::unique_ptr<rpybuild_Power_initializer> cls;

void begin_init_Power(py::module &m) {
  cls = std::make_unique<rpybuild_Power_initializer>(m);
}

void finish_init_Power() {
  cls->finish();
  cls.reset();
}