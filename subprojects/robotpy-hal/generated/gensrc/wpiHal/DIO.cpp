
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <hal/DIO.h>
















#include <type_traits>






struct rpybuild_DIO_initializer {













  py::module &m;

  
  rpybuild_DIO_initializer(py::module &m) :

  

  

  

  

    m(m)
  {
    
    

    
  }

void finish() {







m
  .
def
("initializeDIOPort", [](HAL_PortHandle portHandle, HAL_Bool input, const char* allocationLocation) {
                    int32_t status;
          auto __ret =::HAL_InitializeDIOPort(std::move(portHandle), std::move(input), allocationLocation, &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("portHandle"), py::arg("input"), py::arg("allocationLocation"), release_gil(), py::doc(
    "Creates a new instance of a digital port.\n"
"\n"
":param in:  portHandle         the port handle to create from\n"
":param in:  input              true for input, false for output\n"
":param in:  allocationLocation the location where the allocation is occurring\n"
"            (can be null)\n"
":param out: status            Error status variable. 0 on success.\n"
"\n"
":returns: the created digital handle")
  )
  
  ;
m
  .
def
("checkDIOChannel", &::HAL_CheckDIOChannel,
      py::arg("channel"), release_gil(), py::doc(
    "Checks if a DIO channel is valid.\n"
"\n"
":param channel: the channel number to check\n"
"\n"
":returns: true if the channel is valid, otherwise false")
  )
  
  ;
m
  .
def
("freeDIOPort", &::HAL_FreeDIOPort,
      py::arg("dioPortHandle"), release_gil(), py::doc(
    "Frees a DIO port.\n"
"\n"
":param dioPortHandle: the DIO channel handle")
  )
  
  ;
m
  .
def
("setDIOSimDevice", &::HAL_SetDIOSimDevice,
      py::arg("handle"), py::arg("device"), release_gil(), py::doc(
    "Indicates the DIO channel is used by a simulated device.\n"
"\n"
":param handle: the DIO channel handle\n"
":param device: simulated device handle")
  )
  
  ;
m
  .
def
("allocateDigitalPWM", []() {
                    int32_t status;
          auto __ret =::HAL_AllocateDigitalPWM(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Allocates a DO PWM Generator.\n"
"\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: the allocated digital PWM handle")
  )
  
  ;
m
  .
def
("freeDigitalPWM", [](HAL_DigitalPWMHandle pwmGenerator) {
                    int32_t status;
          ::HAL_FreeDigitalPWM(std::move(pwmGenerator), &status);
          return status;
        },
      py::arg("pwmGenerator"), release_gil(), py::doc(
    "Frees the resource associated with a DO PWM generator.\n"
"\n"
":param in:  pwmGenerator the digital PWM handle\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setDigitalPWMRate", [](double rate) {
                    int32_t status;
          ::HAL_SetDigitalPWMRate(std::move(rate), &status);
          return status;
        },
      py::arg("rate"), release_gil(), py::doc(
    "Changes the frequency of the DO PWM generator.\n"
"\n"
"The valid range is from 0.6 Hz to 19 kHz.\n"
"\n"
"The frequency resolution is logarithmic.\n"
"\n"
":param in:  rate the frequency to output all digital output PWM signals\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setDigitalPWMDutyCycle", [](HAL_DigitalPWMHandle pwmGenerator, double dutyCycle) {
                    int32_t status;
          ::HAL_SetDigitalPWMDutyCycle(std::move(pwmGenerator), std::move(dutyCycle), &status);
          return status;
        },
      py::arg("pwmGenerator"), py::arg("dutyCycle"), release_gil(), py::doc(
    "Configures the duty-cycle of the PWM generator.\n"
"\n"
":param in:  pwmGenerator the digital PWM handle\n"
":param in:  dutyCycle    the percent duty cycle to output [0..1]\n"
":param out: status      Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setDigitalPWMPPS", [](HAL_DigitalPWMHandle pwmGenerator, double dutyCycle) {
                    int32_t status;
          ::HAL_SetDigitalPWMPPS(std::move(pwmGenerator), std::move(dutyCycle), &status);
          return status;
        },
      py::arg("pwmGenerator"), py::arg("dutyCycle"), release_gil(), py::doc(
    "Configures the digital PWM to be a PPS signal with specified duty cycle.\n"
"\n"
":param in:  pwmGenerator the digital PWM handle\n"
":param in:  dutyCycle    the percent duty cycle to output [0..1]\n"
":param out: status      Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setDigitalPWMOutputChannel", [](HAL_DigitalPWMHandle pwmGenerator, int32_t channel) {
                    int32_t status;
          ::HAL_SetDigitalPWMOutputChannel(std::move(pwmGenerator), std::move(channel), &status);
          return status;
        },
      py::arg("pwmGenerator"), py::arg("channel"), release_gil(), py::doc(
    "Configures which DO channel the PWM signal is output on.\n"
"\n"
":param in:  pwmGenerator the digital PWM handle\n"
":param in:  channel      the channel to output on\n"
":param out: status      Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setDIO", [](HAL_DigitalHandle dioPortHandle, HAL_Bool value) {
                    int32_t status;
          ::HAL_SetDIO(std::move(dioPortHandle), std::move(value), &status);
          return status;
        },
      py::arg("dioPortHandle"), py::arg("value"), release_gil(), py::doc(
    "Writes a digital value to a DIO channel.\n"
"\n"
":param in:  dioPortHandle the digital port handle\n"
":param in:  value         the state to set the digital channel (if it is\n"
"            configured as an output)\n"
":param out: status       Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setDIODirection", [](HAL_DigitalHandle dioPortHandle, HAL_Bool input) {
                    int32_t status;
          ::HAL_SetDIODirection(std::move(dioPortHandle), std::move(input), &status);
          return status;
        },
      py::arg("dioPortHandle"), py::arg("input"), release_gil(), py::doc(
    "Sets the direction of a DIO channel.\n"
"\n"
":param in:  dioPortHandle the digital port handle\n"
":param in:  input         true to set input, false for output\n"
":param out: status       Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("getDIO", [](HAL_DigitalHandle dioPortHandle) {
                    int32_t status;
          auto __ret =::HAL_GetDIO(std::move(dioPortHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("dioPortHandle"), release_gil(), py::doc(
    "Reads a digital value from a DIO channel.\n"
"\n"
":param in:  dioPortHandle the digital port handle\n"
":param out: status       Error status variable. 0 on success.\n"
"\n"
":returns: the state of the specified channel")
  )
  
  ;
m
  .
def
("getDIODirection", [](HAL_DigitalHandle dioPortHandle) {
                    int32_t status;
          auto __ret =::HAL_GetDIODirection(std::move(dioPortHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("dioPortHandle"), release_gil(), py::doc(
    "Reads the direction of a DIO channel.\n"
"\n"
":param in:  dioPortHandle the digital port handle\n"
":param out: status       Error status variable. 0 on success.\n"
"\n"
":returns: true for input, false for output")
  )
  
  ;
m
  .
def
("pulse", [](HAL_DigitalHandle dioPortHandle, double pulseLengthSeconds) {
                    int32_t status;
          ::HAL_Pulse(std::move(dioPortHandle), std::move(pulseLengthSeconds), &status);
          return status;
        },
      py::arg("dioPortHandle"), py::arg("pulseLengthSeconds"), release_gil(), py::doc(
    "Generates a single digital pulse.\n"
"\n"
"Write a pulse to the specified digital output channel. There can only be a\n"
"single pulse going at any time.\n"
"\n"
":param in:  dioPortHandle the digital port handle\n"
":param in:  pulseLengthSeconds   the active length of the pulse (in seconds)\n"
":param out: status       Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("pulseMultiple", [](uint32_t channelMask, double pulseLengthSeconds) {
                    int32_t status;
          ::HAL_PulseMultiple(std::move(channelMask), std::move(pulseLengthSeconds), &status);
          return status;
        },
      py::arg("channelMask"), py::arg("pulseLengthSeconds"), release_gil(), py::doc(
    "Generates a single digital pulse on multiple channels.\n"
"\n"
"Write a pulse to the channels enabled by the mask. There can only be a\n"
"single pulse going at any time.\n"
"\n"
":param in:  channelMask the channel mask\n"
":param in:  pulseLengthSeconds   the active length of the pulse (in seconds)\n"
":param out: status       Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("isPulsing", [](HAL_DigitalHandle dioPortHandle) {
                    int32_t status;
          auto __ret =::HAL_IsPulsing(std::move(dioPortHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("dioPortHandle"), release_gil(), py::doc(
    "Checks a DIO line to see if it is currently generating a pulse.\n"
"\n"
":param in:  dioPortHandle the digital port handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: true if a pulse is in progress, otherwise false")
  )
  
  ;
m
  .
def
("isAnyPulsing", []() {
                    int32_t status;
          auto __ret =::HAL_IsAnyPulsing(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Checks if any DIO line is currently generating a pulse.\n"
"\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: true if a pulse on some line is in progress")
  )
  
  ;
m
  .
def
("setFilterSelect", [](HAL_DigitalHandle dioPortHandle, int32_t filterIndex) {
                    int32_t status;
          ::HAL_SetFilterSelect(std::move(dioPortHandle), std::move(filterIndex), &status);
          return status;
        },
      py::arg("dioPortHandle"), py::arg("filterIndex"), release_gil(), py::doc(
    "Writes the filter index from the FPGA.\n"
"\n"
"Set the filter index used to filter out short pulses.\n"
"\n"
":param in:  dioPortHandle the digital port handle\n"
":param in:  filterIndex   the filter index (Must be in the range 0 - 3, where\n"
"            0 means \"none\" and 1 - 3 means filter # filterIndex\n"
"            - 1)\n"
":param out: status       Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("getFilterSelect", [](HAL_DigitalHandle dioPortHandle) {
                    int32_t status;
          auto __ret =::HAL_GetFilterSelect(std::move(dioPortHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("dioPortHandle"), release_gil(), py::doc(
    "Reads the filter index from the FPGA.\n"
"\n"
"Gets the filter index used to filter out short pulses.\n"
"\n"
":param in:  dioPortHandle the digital port handle\n"
":param out: status       Error status variable. 0 on success.\n"
"\n"
":returns: filterIndex  the filter index (Must be in the range 0 - 3, where 0\n"
"          means \"none\" and 1 - 3 means filter # filterIndex - 1)")
  )
  
  ;
m
  .
def
("setFilterPeriod", [](int32_t filterIndex, int64_t value) {
                    int32_t status;
          ::HAL_SetFilterPeriod(std::move(filterIndex), std::move(value), &status);
          return status;
        },
      py::arg("filterIndex"), py::arg("value"), release_gil(), py::doc(
    "Sets the filter period for the specified filter index.\n"
"\n"
"Sets the filter period in FPGA cycles.  Even though there are 2 different\n"
"filter index domains (MXP vs HDR), ignore that distinction for now since it\n"
"complicates the interface.  That can be changed later.\n"
"\n"
":param in:  filterIndex the filter index, 0 - 2\n"
":param in:  value       the number of cycles that the signal must not\n"
"            transition to be counted as a transition.\n"
":param out: status     Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("getFilterPeriod", [](int32_t filterIndex) {
                    int32_t status;
          auto __ret =::HAL_GetFilterPeriod(std::move(filterIndex), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("filterIndex"), release_gil(), py::doc(
    "Gets the filter period for the specified filter index.\n"
"\n"
"Gets the filter period in FPGA cycles.  Even though there are 2 different\n"
"filter index domains (MXP vs HDR), ignore that distinction for now since it\n"
"complicates the interface.  Set status to NiFpga_Status_SoftwareFault if the\n"
"filter values mismatch.\n"
"\n"
":param in:  filterIndex the filter index, 0 - 2\n"
":param out: status     Error status variable. 0 on success.\n"
"\n"
":returns: The number of FPGA cycles of the filter period.")
  )
  
  ;



}

}; // struct rpybuild_DIO_initializer

static std::unique_ptr<rpybuild_DIO_initializer> cls;

void begin_init_DIO(py::module &m) {
  cls = std::make_unique<rpybuild_DIO_initializer>(m);
}

void finish_init_DIO() {
  cls->finish();
  cls.reset();
}