
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <hal/I2C.h>
















#include <type_traits>




struct rpybuild_I2C_initializer {













  py::module &m;

  
  rpybuild_I2C_initializer(py::module &m) :

  

  

  

  

    m(m)
  {
    
    

    
  }

void finish() {







m
  .
def
("initializeI2C", [](HAL_I2CPort port) {
                    int32_t status;
          ::HAL_InitializeI2C(std::move(port), &status);
          return status;
        },
      py::arg("port"), release_gil(), py::doc(
    "Initializes the I2C port.\n"
"\n"
"Opens the port if necessary and saves the handle.\n"
"If opening the MXP port, also sets up the channel functions appropriately.\n"
"\n"
":param in:  port    The port to open, 0 for the on-board, 1 for the MXP.\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("transactionI2C", [](HAL_I2CPort port, int32_t deviceAddress, const py::buffer& dataToSend, const py::buffer& dataReceived) {
                    int32_t sendSize;
          int32_t receiveSize;
          auto __dataToSend = dataToSend.request(false);
          sendSize = __dataToSend.size * __dataToSend.itemsize;
          auto __dataReceived = dataReceived.request(true);
          receiveSize = __dataReceived.size * __dataReceived.itemsize;
          auto __ret =::HAL_TransactionI2C(std::move(port), std::move(deviceAddress), (const uint8_t*)__dataToSend.ptr, sendSize, (uint8_t*)__dataReceived.ptr, receiveSize);
          return __ret;
        },
      py::arg("port"), py::arg("deviceAddress"), py::arg("dataToSend"), py::arg("dataReceived"), release_gil(), py::doc(
    "Generic I2C read/write transaction.\n"
"\n"
"This is a lower-level interface to the I2C hardware giving you more control\n"
"over each transaction.\n"
"\n"
":param port:          The I2C port, 0 for the on-board, 1 for the MXP.\n"
":param deviceAddress: The address of the register on the device to be\n"
"                      read/written.\n"
":param dataToSend:    Buffer of data to send as part of the transaction.\n"
":param sendSize:      Number of bytes to send as part of the transaction.\n"
":param dataReceived:  Buffer to read data into.\n"
":param receiveSize:   Number of bytes to read from the device.\n"
"\n"
":returns: 0 on success or -1 on transfer abort.")
  )
  
  ;
m
  .
def
("writeI2C", [](HAL_I2CPort port, int32_t deviceAddress, const py::buffer& dataToSend) {
                    int32_t sendSize;
          auto __dataToSend = dataToSend.request(false);
          sendSize = __dataToSend.size * __dataToSend.itemsize;
          auto __ret =::HAL_WriteI2C(std::move(port), std::move(deviceAddress), (const uint8_t*)__dataToSend.ptr, sendSize);
          return __ret;
        },
      py::arg("port"), py::arg("deviceAddress"), py::arg("dataToSend"), release_gil(), py::doc(
    "Executes a write transaction with the device.\n"
"\n"
"Writes a single byte to a register on a device and wait until the\n"
"transaction is complete.\n"
"\n"
":param port:          The I2C port, 0 for the on-board, 1 for the MXP.\n"
":param deviceAddress: The address of the register on the device to be\n"
"                      written.\n"
":param dataToSend:    The byte to write to the register on the device.\n"
":param sendSize:      Number of bytes to send.\n"
"\n"
":returns: 0 on success or -1 on transfer abort.")
  )
  
  ;
m
  .
def
("readI2C", [](HAL_I2CPort port, int32_t deviceAddress, const py::buffer& buffer) {
                    int32_t count;
          auto __buffer = buffer.request(true);
          count = __buffer.size * __buffer.itemsize;
          auto __ret =::HAL_ReadI2C(std::move(port), std::move(deviceAddress), (uint8_t*)__buffer.ptr, count);
          return __ret;
        },
      py::arg("port"), py::arg("deviceAddress"), py::arg("buffer"), release_gil(), py::doc(
    "Executes a read transaction with the device.\n"
"\n"
"Reads bytes from a device.\n"
"Most I2C devices will auto-increment the register pointer internally allowing\n"
"you to read consecutive registers on a device in a single transaction.\n"
"\n"
":param port:          The I2C port, 0 for the on-board, 1 for the MXP.\n"
":param deviceAddress: The register to read first in the transaction.\n"
":param count:         The number of bytes to read in the transaction.\n"
":param buffer:        A pointer to the array of bytes to store the data read from the\n"
"                      device.\n"
"\n"
":returns: 0 on success or -1 on transfer abort.")
  )
  
  ;
m
  .
def
("closeI2C", &::HAL_CloseI2C,
      py::arg("port"), release_gil(), py::doc(
    "Closes an I2C port\n"
"\n"
":param port: The I2C port, 0 for the on-board, 1 for the MXP.")
  )
  
  ;



}

}; // struct rpybuild_I2C_initializer

static std::unique_ptr<rpybuild_I2C_initializer> cls;

void begin_init_I2C(py::module &m) {
  cls = std::make_unique<rpybuild_I2C_initializer>(m);
}

void finish_init_I2C() {
  cls->finish();
  cls.reset();
}