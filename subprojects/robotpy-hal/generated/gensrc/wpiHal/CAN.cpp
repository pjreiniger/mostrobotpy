
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <hal/CAN.h>
















#include <type_traits>




struct rpybuild_CAN_initializer {


  

  












  py::class_<typename ::HAL_CANStreamMessage> cls_HAL_CANStreamMessage;

    

    
    

  py::module &m;

  
  rpybuild_CAN_initializer(py::module &m) :

  

  

  

  
    cls_HAL_CANStreamMessage(m, "CANStreamMessage"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_HAL_CANStreamMessage.doc() =
    "Storage for CAN Stream Messages.";

  cls_HAL_CANStreamMessage
  
    .def(py::init<>(), release_gil())
  
    .def_readwrite("messageID", &::HAL_CANStreamMessage::messageID, py::doc(
    "The message ID"))
  
    .def_readwrite("timeStamp", &::HAL_CANStreamMessage::timeStamp, py::doc(
    "The packet received timestamp (based off of CLOCK_MONOTONIC)"))
  
    .def_property_readonly("data", [](::HAL_CANStreamMessage& inst) {
        return py::memoryview::from_buffer(
          &inst.data, sizeof(uint8_t),
          py::format_descriptor<uint8_t>::value,
          {8}, {sizeof(uint8_t)},
          false
        );
    }, py::doc(
    "The message data"))
  
    .def_readwrite("dataSize", &::HAL_CANStreamMessage::dataSize, py::doc(
    "The size of the data received (0-8 bytes)"))
  ;

  


  }



m
  .
def
("CAN_SendMessage", [](uint32_t messageID, const py::buffer& data, int32_t periodMs) {
                    uint8_t dataSize;
          int32_t status;
          auto __data = data.request(false);
          dataSize = __data.size * __data.itemsize;
          ::HAL_CAN_SendMessage(std::move(messageID), (const uint8_t*)__data.ptr, dataSize, std::move(periodMs), &status);
          return status;
        },
      py::arg("messageID"), py::arg("data"), py::arg("periodMs"), release_gil(), py::doc(
    "Sends a CAN message.\n"
"\n"
":param in:  messageID the CAN ID to send\n"
":param in:  data      the data to send (0-8 bytes)\n"
":param in:  dataSize  the size of the data to send (0-8 bytes)\n"
":param in:  periodMs  the period to repeat the packet at. Use\n"
"            HAL_CAN_SEND_PERIOD_NO_REPEAT to not repeat.\n"
":param out: status    Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("CAN_ReceiveMessage", [](uint32_t messageIDMask, const py::buffer& data) {
                    uint32_t messageID;
          uint8_t dataSize;
          uint32_t timeStamp;
          int32_t status;
          auto __data = data.request(true);
          dataSize = __data.size * __data.itemsize;
          if (dataSize < 8) throw py::value_error("data: minimum buffer size is 8");
          ::HAL_CAN_ReceiveMessage(&messageID, std::move(messageIDMask), (uint8_t*)__data.ptr, &dataSize, &timeStamp, &status);
          return std::make_tuple(messageID,dataSize,timeStamp,status);
        },
      py::arg("messageIDMask"), py::arg("data"), release_gil(), py::doc(
    "Receives a CAN message.\n"
"\n"
":param out: messageID     store for the received message ID\n"
":param in:  messageIDMask the message ID mask to look for\n"
":param out: data          data output (8 bytes)\n"
":param out: dataSize      data length (0-8 bytes)\n"
":param out: timeStamp     the packet received timestamp (based off of\n"
"            CLOCK_MONOTONIC)\n"
":param out: status        Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("CAN_GetCANStatus", []() {
                    float percentBusUtilization;
          uint32_t busOffCount;
          uint32_t txFullCount;
          uint32_t receiveErrorCount;
          uint32_t transmitErrorCount;
          int32_t status;
          ::HAL_CAN_GetCANStatus(&percentBusUtilization, &busOffCount, &txFullCount, &receiveErrorCount, &transmitErrorCount, &status);
          return std::make_tuple(percentBusUtilization,busOffCount,txFullCount,receiveErrorCount,transmitErrorCount,status);
        }, release_gil(), py::doc(
    "Gets CAN status information.\n"
"\n"
":param out: percentBusUtilization the bus utilization\n"
":param out: busOffCount           the number of bus off errors\n"
":param out: txFullCount           the number of tx full errors\n"
":param out: receiveErrorCount     the number of receive errors\n"
":param out: transmitErrorCount    the number of transmit errors\n"
":param out: status                Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("CAN_OpenStreamSession", [](uint32_t messageID, uint32_t messageIDMask, uint32_t maxMessages) {
                    uint32_t sessionHandle;
          int32_t status;
          ::HAL_CAN_OpenStreamSession(&sessionHandle, std::move(messageID), std::move(messageIDMask), std::move(maxMessages), &status);
          return std::make_tuple(sessionHandle,status);
        },
      py::arg("messageID"), py::arg("messageIDMask"), py::arg("maxMessages"), release_gil(), py::doc(
    "Opens a CAN stream.\n"
"\n"
":param out: sessionHandle output for the session handle\n"
":param in:  messageID     the message ID to read\n"
":param in:  messageIDMask the message ID mask\n"
":param in:  maxMessages   the maximum number of messages to stream\n"
":param out: status        Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("CAN_CloseStreamSession", &::HAL_CAN_CloseStreamSession,
      py::arg("sessionHandle"), release_gil(), py::doc(
    "Closes a CAN stream.\n"
"\n"
":param sessionHandle: the session to close")
  )
  
  ;



}

}; // struct rpybuild_CAN_initializer

static std::unique_ptr<rpybuild_CAN_initializer> cls;

void begin_init_CAN(py::module &m) {
  cls = std::make_unique<rpybuild_CAN_initializer>(m);
}

void finish_init_CAN() {
  cls->finish();
  cls.reset();
}