
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <hal/SPI.h>
















#include <type_traits>




struct rpybuild_SPI_initializer {













  py::module &m;

  
  rpybuild_SPI_initializer(py::module &m) :

  

  

  

  

    m(m)
  {
    
    

    
  }

void finish() {







m
  .
def
("initializeSPI", [](HAL_SPIPort port) {
                    int32_t status;
          ::HAL_InitializeSPI(std::move(port), &status);
          return status;
        },
      py::arg("port"), release_gil(), py::doc(
    "Initializes the SPI port. Opens the port if necessary and saves the handle.\n"
"\n"
"If opening the MXP port, also sets up the channel functions appropriately.\n"
"\n"
":param in:  port    The number of the port to use. 0-3 for Onboard CS0-CS3, 4\n"
"            for MXP\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("transactionSPI", [](HAL_SPIPort port, const py::buffer& dataToSend, const py::buffer& dataReceived) {
                    int32_t size;
          auto __dataToSend = dataToSend.request(false);
          size = __dataToSend.size * __dataToSend.itemsize;
          auto __dataReceived = dataReceived.request(true);
          size = __dataReceived.size * __dataReceived.itemsize;
          auto __ret =::HAL_TransactionSPI(std::move(port), (const uint8_t*)__dataToSend.ptr, (uint8_t*)__dataReceived.ptr, size);
          return __ret;
        },
      py::arg("port"), py::arg("dataToSend"), py::arg("dataReceived"), release_gil(), py::doc(
    "Performs an SPI send/receive transaction.\n"
"\n"
"This is a lower-level interface to the spi hardware giving you more control\n"
"over each transaction.\n"
"\n"
":param port:         The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n"
"                     for MXP\n"
":param dataToSend:   Buffer of data to send as part of the transaction.\n"
":param dataReceived: Buffer to read data into.\n"
":param size:         Number of bytes to transfer. [0..7]\n"
"\n"
":returns: Number of bytes transferred, -1 for error")
  )
  
  ;
m
  .
def
("writeSPI", [](HAL_SPIPort port, const py::buffer& dataToSend) {
                    int32_t sendSize;
          auto __dataToSend = dataToSend.request(false);
          sendSize = __dataToSend.size * __dataToSend.itemsize;
          auto __ret =::HAL_WriteSPI(std::move(port), (const uint8_t*)__dataToSend.ptr, sendSize);
          return __ret;
        },
      py::arg("port"), py::arg("dataToSend"), release_gil(), py::doc(
    "Executes a write transaction with the device.\n"
"\n"
"Writes to a device and wait until the transaction is complete.\n"
"\n"
":param port:       The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n"
"                   for MXP\n"
":param dataToSend: The data to write to the register on the device.\n"
":param sendSize:   The number of bytes to be written\n"
"\n"
":returns: The number of bytes written. -1 for an error")
  )
  
  ;
m
  .
def
("readSPI", [](HAL_SPIPort port, const py::buffer& buffer) {
                    int32_t count;
          auto __buffer = buffer.request(true);
          count = __buffer.size * __buffer.itemsize;
          auto __ret =::HAL_ReadSPI(std::move(port), (uint8_t*)__buffer.ptr, count);
          return __ret;
        },
      py::arg("port"), py::arg("buffer"), release_gil(), py::doc(
    "Executes a read from the device.\n"
"\n"
"This method does not write any data out to the device.\n"
"\n"
"Most spi devices will require a register address to be written before they\n"
"begin returning data.\n"
"\n"
":param port:   The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n"
"               MXP\n"
":param buffer: A pointer to the array of bytes to store the data read from the\n"
"               device.\n"
":param count:  The number of bytes to read in the transaction. [1..7]\n"
"\n"
":returns: Number of bytes read. -1 for error.")
  )
  
  ;
m
  .
def
("closeSPI", &::HAL_CloseSPI,
      py::arg("port"), release_gil(), py::doc(
    "Closes the SPI port.\n"
"\n"
":param port: The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for MXP")
  )
  
  ;
m
  .
def
("setSPISpeed", &::HAL_SetSPISpeed,
      py::arg("port"), py::arg("speed"), release_gil(), py::doc(
    "Sets the clock speed for the SPI bus.\n"
"\n"
":param port:  The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n"
"              MXP\n"
":param speed: The speed in Hz (500KHz-10MHz)")
  )
  
  ;
m
  .
def
("setSPIMode", &::HAL_SetSPIMode,
      py::arg("port"), py::arg("mode"), release_gil(), py::doc(
    "Sets the SPI Mode.\n"
"\n"
":param port: The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n"
"             MXP\n"
":param mode: The SPI mode to use")
  )
  
  ;
m
  .
def
("getSPIMode", &::HAL_GetSPIMode,
      py::arg("port"), release_gil(), py::doc(
    "Gets the SPI Mode.\n"
"\n"
":param port: The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n"
"             MXP\n"
"\n"
":returns: The SPI mode currently set")
  )
  
  ;
m
  .
def
("setSPIChipSelectActiveHigh", [](HAL_SPIPort port) {
                    int32_t status;
          ::HAL_SetSPIChipSelectActiveHigh(std::move(port), &status);
          return status;
        },
      py::arg("port"), release_gil(), py::doc(
    "Sets the CS Active high for a SPI port.\n"
"\n"
":param in:  port The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n"
"            MXP\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("setSPIChipSelectActiveLow", [](HAL_SPIPort port) {
                    int32_t status;
          ::HAL_SetSPIChipSelectActiveLow(std::move(port), &status);
          return status;
        },
      py::arg("port"), release_gil(), py::doc(
    "Sets the CS Active low for a SPI port.\n"
"\n"
":param in:  port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n"
"            for MXP\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("getSPIHandle", &::HAL_GetSPIHandle,
      py::arg("port"), release_gil(), py::doc(
    "Gets the stored handle for a SPI port.\n"
"\n"
":param port: The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for MXP\n"
"\n"
":returns: The stored handle for the SPI port. 0 represents no stored\n"
"          handle.")
  )
  
  ;
m
  .
def
("setSPIHandle", &::HAL_SetSPIHandle,
      py::arg("port"), py::arg("handle"), release_gil(), py::doc(
    "Sets the stored handle for a SPI port.\n"
"\n"
":param port:   The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n"
"               MXP.\n"
":param handle: The value of the handle for the port.")
  )
  
  ;
m
  .
def
("initSPIAuto", [](HAL_SPIPort port, int32_t bufferSize) {
                    int32_t status;
          ::HAL_InitSPIAuto(std::move(port), std::move(bufferSize), &status);
          return status;
        },
      py::arg("port"), py::arg("bufferSize"), release_gil(), py::doc(
    "Initializes the SPI automatic accumulator.\n"
"\n"
":param in:  port       The number of the port to use. 0-3 for Onboard CS0-CS2,\n"
"            4 for MXP.\n"
":param in:  bufferSize The accumulator buffer size.\n"
":param out: status    the error code, or 0 for success")
  )
  
  ;
m
  .
def
("freeSPIAuto", [](HAL_SPIPort port) {
                    int32_t status;
          ::HAL_FreeSPIAuto(std::move(port), &status);
          return status;
        },
      py::arg("port"), release_gil(), py::doc(
    "Frees an SPI automatic accumulator.\n"
"\n"
":param in:  port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n"
"            for MXP.\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("startSPIAutoRate", [](HAL_SPIPort port, double period) {
                    int32_t status;
          ::HAL_StartSPIAutoRate(std::move(port), std::move(period), &status);
          return status;
        },
      py::arg("port"), py::arg("period"), release_gil(), py::doc(
    "Sets the period for automatic SPI accumulation.\n"
"\n"
":param in:  port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n"
"            for MXP.\n"
":param in:  period  The accumulation period (seconds).\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("startSPIAutoTrigger", [](HAL_SPIPort port, HAL_Handle digitalSourceHandle, HAL_AnalogTriggerType analogTriggerType, HAL_Bool triggerRising, HAL_Bool triggerFalling) {
                    int32_t status;
          ::HAL_StartSPIAutoTrigger(std::move(port), std::move(digitalSourceHandle), std::move(analogTriggerType), std::move(triggerRising), std::move(triggerFalling), &status);
          return status;
        },
      py::arg("port"), py::arg("digitalSourceHandle"), py::arg("analogTriggerType"), py::arg("triggerRising"), py::arg("triggerFalling"), release_gil(), py::doc(
    "Starts the auto SPI accumulator on a specific trigger.\n"
"\n"
"Note that triggering on both rising and falling edges is a valid\n"
"configuration.\n"
"\n"
":param in:  port                The number of the port to use. 0-3 for Onboard\n"
"            CS0-CS2, 4 for MXP.\n"
":param in:  digitalSourceHandle The trigger source to use (Either\n"
"            HAL_AnalogTriggerHandle or HAL_DigitalHandle).\n"
":param in:  analogTriggerType   The analog trigger type, if the source is an\n"
"            analog trigger.\n"
":param in:  triggerRising       Trigger on the rising edge if true.\n"
":param in:  triggerFalling      Trigger on the falling edge if true.\n"
":param out: status             the error code, or 0 for success")
  )
  
  ;
m
  .
def
("stopSPIAuto", [](HAL_SPIPort port) {
                    int32_t status;
          ::HAL_StopSPIAuto(std::move(port), &status);
          return status;
        },
      py::arg("port"), release_gil(), py::doc(
    "Stops an automatic SPI accumulation.\n"
"\n"
":param in:  port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n"
"            for MXP.\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("setSPIAutoTransmitData", [](HAL_SPIPort port, const py::buffer& dataToSend, int32_t zeroSize) {
                    int32_t dataSize;
          int32_t status;
          auto __dataToSend = dataToSend.request(false);
          dataSize = __dataToSend.size * __dataToSend.itemsize;
          ::HAL_SetSPIAutoTransmitData(std::move(port), (const uint8_t*)__dataToSend.ptr, dataSize, std::move(zeroSize), &status);
          return status;
        },
      py::arg("port"), py::arg("dataToSend"), py::arg("zeroSize"), release_gil(), py::doc(
    "Sets the data to be transmitted to the device to initiate a read.\n"
"\n"
":param in:  port       The number of the port to use. 0-3 for Onboard CS0-CS2,\n"
"            4 for MXP.\n"
":param in:  dataToSend Pointer to the data to send (Gets copied for continue\n"
"            use, so no need to keep alive).\n"
":param in:  dataSize   The length of the data to send.\n"
":param in:  zeroSize   The number of zeros to send after the data.\n"
":param out: status    the error code, or 0 for success")
  )
  
  ;
m
  .
def
("forceSPIAutoRead", [](HAL_SPIPort port) {
                    int32_t status;
          ::HAL_ForceSPIAutoRead(std::move(port), &status);
          return status;
        },
      py::arg("port"), release_gil(), py::doc(
    "Immediately forces an SPI read to happen.\n"
"\n"
":param in:  port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n"
"            for MXP.\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("readSPIAutoReceivedData", [](HAL_SPIPort port, const py::buffer& buffer, double timeout) {
                    int32_t numToRead;
          int32_t status;
          auto __buffer = buffer.request(true);
          numToRead = __buffer.size * __buffer.itemsize;
          auto __ret =::HAL_ReadSPIAutoReceivedData(std::move(port), (uint32_t*)__buffer.ptr, numToRead, std::move(timeout), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("port"), py::arg("buffer"), py::arg("timeout"), release_gil(), py::doc(
    "Reads data received by the SPI accumulator.  Each received data sequence\n"
"consists of a timestamp followed by the received data bytes, one byte per\n"
"word (in the least significant byte).  The length of each received data\n"
"sequence is the same as the combined dataSize + zeroSize set in\n"
"HAL_SetSPIAutoTransmitData.\n"
"\n"
":param in:  port      The number of the port to use. 0-3 for Onboard CS0-CS2,\n"
"            4 for MXP.\n"
":param out: buffer   The buffer to store the data into.\n"
":param in:  numToRead The number of words to read.\n"
":param in:  timeout   The read timeout (in seconds).\n"
":param out: status   the error code, or 0 for success\n"
"\n"
":returns: The number of words actually read.")
  )
  
  ;
m
  .
def
("getSPIAutoDroppedCount", [](HAL_SPIPort port) {
                    int32_t status;
          auto __ret =::HAL_GetSPIAutoDroppedCount(std::move(port), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("port"), release_gil(), py::doc(
    "Gets the count of how many SPI accumulations have been missed.\n"
"\n"
":param in:  port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n"
"            for MXP.\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: The number of missed accumulations.")
  )
  
  ;
m
  .
def
("configureSPIAutoStall", [](HAL_SPIPort port, int32_t csToSclkTicks, int32_t stallTicks, int32_t pow2BytesPerRead) {
                    int32_t status;
          ::HAL_ConfigureSPIAutoStall(std::move(port), std::move(csToSclkTicks), std::move(stallTicks), std::move(pow2BytesPerRead), &status);
          return status;
        },
      py::arg("port"), py::arg("csToSclkTicks"), py::arg("stallTicks"), py::arg("pow2BytesPerRead"), release_gil(), py::doc(
    "Configure the Auto SPI Stall time between reads.\n"
"\n"
":param in:  port             The number of the port to use. 0-3 for Onboard\n"
"            CS0-CS2, 4 for MXP.\n"
":param in:  csToSclkTicks    the number of ticks to wait before asserting the\n"
"            cs pin\n"
":param in:  stallTicks       the number of ticks to stall for\n"
":param in:  pow2BytesPerRead the number of bytes to read before stalling\n"
":param out: status          the error code, or 0 for success")
  )
  
  ;



}

}; // struct rpybuild_SPI_initializer

static std::unique_ptr<rpybuild_SPI_initializer> cls;

void begin_init_SPI(py::module &m) {
  cls = std::make_unique<rpybuild_SPI_initializer>(m);
}

void finish_init_SPI() {
  cls->finish();
  cls.reset();
}