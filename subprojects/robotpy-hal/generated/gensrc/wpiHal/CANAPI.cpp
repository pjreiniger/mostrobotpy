
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <hal/CANAPI.h>
















#include <type_traits>






struct rpybuild_CANAPI_initializer {













  py::module &m;

  
  rpybuild_CANAPI_initializer(py::module &m) :

  

  

  

  

    m(m)
  {
    
    

    
  }

void finish() {







m
  .
def
("getCANPacketBaseTime", &::HAL_GetCANPacketBaseTime, release_gil(), py::doc(
    "Reads the current value of the millisecond-resolution timer that the CAN API\n"
"functions use as a time base.\n"
"\n"
":returns: Current value of timer used as a base time by the CAN API in\n"
"          milliseconds.")
  )
  
  ;
m
  .
def
("initializeCAN", [](HAL_CANManufacturer manufacturer, int32_t deviceId, HAL_CANDeviceType deviceType) {
                    int32_t status;
          auto __ret =::HAL_InitializeCAN(std::move(manufacturer), std::move(deviceId), std::move(deviceType), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("manufacturer"), py::arg("deviceId"), py::arg("deviceType"), release_gil(), py::doc(
    "Initializes a CAN device.\n"
"\n"
"These follow the FIRST standard CAN layout.\n"
"https://docs.wpilib.org/en/stable/docs/software/can-devices/can-addressing.html\n"
"\n"
":param in:  manufacturer the can manufacturer\n"
":param in:  deviceId     the device ID (0-63)\n"
":param in:  deviceType   the device type\n"
":param out: status      Error status variable. 0 on success.\n"
"\n"
":returns: the created CAN handle")
  )
  
  ;
m
  .
def
("cleanCAN", &::HAL_CleanCAN,
      py::arg("handle"), release_gil(), py::doc(
    "Frees a CAN device\n"
"\n"
":param in: out] handle the CAN handle")
  )
  
  ;
m
  .
def
("writeCANPacket", [](HAL_CANHandle handle, const py::buffer& data, int32_t apiId) {
                    int32_t length;
          int32_t status;
          auto __data = data.request(false);
          length = __data.size * __data.itemsize;
          ::HAL_WriteCANPacket(std::move(handle), (const uint8_t*)__data.ptr, length, std::move(apiId), &status);
          return status;
        },
      py::arg("handle"), py::arg("data"), py::arg("apiId"), release_gil(), py::doc(
    "Writes a packet to the CAN device with a specific ID.\n"
"\n"
"This ID is 10 bits.\n"
"\n"
":param in:  handle  the CAN handle\n"
":param in:  data    the data to write (0-8 bytes)\n"
":param in:  length  the length of data (0-8)\n"
":param in:  apiId   the ID to write (0-1023 bits)\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("writeCANPacketRepeating", [](HAL_CANHandle handle, const py::buffer& data, int32_t apiId, int32_t repeatMs) {
                    int32_t length;
          int32_t status;
          auto __data = data.request(false);
          length = __data.size * __data.itemsize;
          ::HAL_WriteCANPacketRepeating(std::move(handle), (const uint8_t*)__data.ptr, length, std::move(apiId), std::move(repeatMs), &status);
          return status;
        },
      py::arg("handle"), py::arg("data"), py::arg("apiId"), py::arg("repeatMs"), release_gil(), py::doc(
    "Writes a repeating packet to the CAN device with a specific ID.\n"
"\n"
"This ID is 10 bits.\n"
"\n"
"The RoboRIO will automatically repeat the packet at the specified interval\n"
"\n"
":param in:  handle   the CAN handle\n"
":param in:  data     the data to write (0-8 bytes)\n"
":param in:  length   the length of data (0-8)\n"
":param in:  apiId    the ID to write (0-1023)\n"
":param in:  repeatMs the period to repeat in ms\n"
":param out: status  Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("writeCANRTRFrame", [](HAL_CANHandle handle, int32_t length, int32_t apiId) {
                    int32_t status;
          ::HAL_WriteCANRTRFrame(std::move(handle), std::move(length), std::move(apiId), &status);
          return status;
        },
      py::arg("handle"), py::arg("length"), py::arg("apiId"), release_gil(), py::doc(
    "Writes an RTR frame of the specified length to the CAN device with the\n"
"specific ID.\n"
"\n"
"By spec, the length must be equal to the length sent by the other device,\n"
"otherwise behavior is unspecified.\n"
"\n"
":param in:  handle   the CAN handle\n"
":param in:  length   the length of data to request (0-8)\n"
":param in:  apiId    the ID to write (0-1023)\n"
":param out: status  Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("stopCANPacketRepeating", [](HAL_CANHandle handle, int32_t apiId) {
                    int32_t status;
          ::HAL_StopCANPacketRepeating(std::move(handle), std::move(apiId), &status);
          return status;
        },
      py::arg("handle"), py::arg("apiId"), release_gil(), py::doc(
    "Stops a repeating packet with a specific ID.\n"
"\n"
"This ID is 10 bits.\n"
"\n"
":param in:  handle  the CAN handle\n"
":param in:  apiId   the ID to stop repeating (0-1023)\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("readCANPacketNew", [](HAL_CANHandle handle, int32_t apiId, const py::buffer& data) {
                    int32_t length;
          uint64_t receivedTimestamp;
          int32_t status;
          auto __data = data.request(true);
          length = __data.size * __data.itemsize;
          if (length < 8) throw py::value_error("data: minimum buffer size is 8");
          ::HAL_ReadCANPacketNew(std::move(handle), std::move(apiId), (uint8_t*)__data.ptr, &length, &receivedTimestamp, &status);
          return std::make_tuple(length,receivedTimestamp,status);
        },
      py::arg("handle"), py::arg("apiId"), py::arg("data"), release_gil(), py::doc(
    "Reads a new CAN packet.\n"
"\n"
"This will only return properly once per packet received. Multiple calls\n"
"without receiving another packet will return an error code.\n"
"\n"
":param in:  handle             the CAN handle\n"
":param in:  apiId              the ID to read (0-1023)\n"
":param out: data              the packet data (8 bytes)\n"
":param out: length            the received length (0-8 bytes)\n"
":param out: receivedTimestamp the packet received timestamp in ms (based off\n"
"            of CLOCK_MONOTONIC)\n"
":param out: status            Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("readCANPacketLatest", [](HAL_CANHandle handle, int32_t apiId, const py::buffer& data) {
                    int32_t length;
          uint64_t receivedTimestamp;
          int32_t status;
          auto __data = data.request(true);
          length = __data.size * __data.itemsize;
          if (length < 8) throw py::value_error("data: minimum buffer size is 8");
          ::HAL_ReadCANPacketLatest(std::move(handle), std::move(apiId), (uint8_t*)__data.ptr, &length, &receivedTimestamp, &status);
          return std::make_tuple(length,receivedTimestamp,status);
        },
      py::arg("handle"), py::arg("apiId"), py::arg("data"), release_gil(), py::doc(
    "Reads a CAN packet. The will continuously return the last packet received,\n"
"without accounting for packet age.\n"
"\n"
":param in:  handle             the CAN handle\n"
":param in:  apiId              the ID to read (0-1023)\n"
":param out: data              the packet data (8 bytes)\n"
":param out: length            the received length (0-8 bytes)\n"
":param out: receivedTimestamp the packet received timestamp in ms (based off\n"
"            of CLOCK_MONOTONIC)\n"
":param out: status            Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("readCANPacketTimeout", [](HAL_CANHandle handle, int32_t apiId, const py::buffer& data, int32_t timeoutMs) {
                    int32_t length;
          uint64_t receivedTimestamp;
          int32_t status;
          auto __data = data.request(true);
          length = __data.size * __data.itemsize;
          if (length < 8) throw py::value_error("data: minimum buffer size is 8");
          ::HAL_ReadCANPacketTimeout(std::move(handle), std::move(apiId), (uint8_t*)__data.ptr, &length, &receivedTimestamp, std::move(timeoutMs), &status);
          return std::make_tuple(length,receivedTimestamp,status);
        },
      py::arg("handle"), py::arg("apiId"), py::arg("data"), py::arg("timeoutMs"), release_gil(), py::doc(
    "Reads a CAN packet. The will return the last packet received until the\n"
"packet is older then the requested timeout. Then it will return an error\n"
"code.\n"
"\n"
":param in:  handle             the CAN handle\n"
":param in:  apiId              the ID to read (0-1023)\n"
":param out: data              the packet data (8 bytes)\n"
":param out: length            the received length (0-8 bytes)\n"
":param out: receivedTimestamp the packet received timestamp in ms (based off\n"
"            of CLOCK_MONOTONIC)\n"
":param out: timeoutMs         the timeout time for the packet\n"
":param out: status            Error status variable. 0 on success.")
  )
  
  ;



}

}; // struct rpybuild_CANAPI_initializer

static std::unique_ptr<rpybuild_CANAPI_initializer> cls;

void begin_init_CANAPI(py::module &m) {
  cls = std::make_unique<rpybuild_CANAPI_initializer>(m);
}

void finish_init_CANAPI() {
  cls->finish();
  cls.reset();
}