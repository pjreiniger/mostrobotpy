
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <hal/AnalogAccumulator.h>
















#include <type_traits>






struct rpybuild_AnalogAccumulator_initializer {













  py::module &m;

  
  rpybuild_AnalogAccumulator_initializer(py::module &m) :

  

  

  

  

    m(m)
  {
    
    

    
  }

void finish() {







m
  .
def
("isAccumulatorChannel", [](HAL_AnalogInputHandle analogPortHandle) {
                    int32_t status;
          auto __ret =::HAL_IsAccumulatorChannel(std::move(analogPortHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("analogPortHandle"), release_gil(), py::doc(
    "Is the channel attached to an accumulator.\n"
"\n"
":param in:  analogPortHandle Handle to the analog port.\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: The analog channel is attached to an accumulator.")
  )
  
  ;
m
  .
def
("initAccumulator", [](HAL_AnalogInputHandle analogPortHandle) {
                    int32_t status;
          ::HAL_InitAccumulator(std::move(analogPortHandle), &status);
          return status;
        },
      py::arg("analogPortHandle"), release_gil(), py::doc(
    "Initialize the accumulator.\n"
"\n"
":param in:  analogPortHandle Handle to the analog port.\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("resetAccumulator", [](HAL_AnalogInputHandle analogPortHandle) {
                    int32_t status;
          ::HAL_ResetAccumulator(std::move(analogPortHandle), &status);
          return status;
        },
      py::arg("analogPortHandle"), release_gil(), py::doc(
    "Resets the accumulator to the initial value.\n"
"\n"
":param in:  analogPortHandle Handle to the analog port.\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setAccumulatorCenter", [](HAL_AnalogInputHandle analogPortHandle, int32_t center) {
                    int32_t status;
          ::HAL_SetAccumulatorCenter(std::move(analogPortHandle), std::move(center), &status);
          return status;
        },
      py::arg("analogPortHandle"), py::arg("center"), release_gil(), py::doc(
    "Set the center value of the accumulator.\n"
"\n"
"The center value is subtracted from each A/D value before it is added to the\n"
"accumulator. This is used for the center value of devices like gyros and\n"
"accelerometers to make integration work and to take the device offset into\n"
"account when integrating.\n"
"\n"
"This center value is based on the output of the oversampled and averaged\n"
"source from channel 1. Because of this, any non-zero oversample bits will\n"
"affect the size of the value for this field.\n"
"\n"
":param in:  analogPortHandle Handle to the analog port.\n"
":param in:  center The center value of the accumulator.\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setAccumulatorDeadband", [](HAL_AnalogInputHandle analogPortHandle, int32_t deadband) {
                    int32_t status;
          ::HAL_SetAccumulatorDeadband(std::move(analogPortHandle), std::move(deadband), &status);
          return status;
        },
      py::arg("analogPortHandle"), py::arg("deadband"), release_gil(), py::doc(
    "Set the accumulator's deadband.\n"
"\n"
":param in:  analogPortHandle Handle to the analog port.\n"
":param in:  deadband The deadband of the accumulator.\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("getAccumulatorValue", [](HAL_AnalogInputHandle analogPortHandle) {
                    int32_t status;
          auto __ret =::HAL_GetAccumulatorValue(std::move(analogPortHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("analogPortHandle"), release_gil(), py::doc(
    "Read the accumulated value.\n"
"\n"
"Read the value that has been accumulating on channel 1.\n"
"The accumulator is attached after the oversample and average engine.\n"
"\n"
":param in:  analogPortHandle Handle to the analog port.\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: The 64-bit value accumulated since the last Reset().")
  )
  
  ;
m
  .
def
("getAccumulatorCount", [](HAL_AnalogInputHandle analogPortHandle) {
                    int32_t status;
          auto __ret =::HAL_GetAccumulatorCount(std::move(analogPortHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("analogPortHandle"), release_gil(), py::doc(
    "Read the number of accumulated values.\n"
"\n"
"Read the count of the accumulated values since the accumulator was last\n"
"Reset().\n"
"\n"
":param in:  analogPortHandle Handle to the analog port.\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: The number of times samples from the channel were accumulated.")
  )
  
  ;
m
  .
def
("getAccumulatorOutput", [](HAL_AnalogInputHandle analogPortHandle) {
                    int64_t value;
          int64_t count;
          int32_t status;
          ::HAL_GetAccumulatorOutput(std::move(analogPortHandle), &value, &count, &status);
          return std::make_tuple(value,count,status);
        },
      py::arg("analogPortHandle"), release_gil(), py::doc(
    "Read the accumulated value and the number of accumulated values atomically.\n"
"\n"
"This function reads the value and count from the FPGA atomically.\n"
"This can be used for averaging.\n"
"\n"
":param in:  analogPortHandle Handle to the analog port.\n"
":param in:  value Pointer to the 64-bit accumulated output.\n"
":param in:  count Pointer to the number of accumulation cycles.\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;



}

}; // struct rpybuild_AnalogAccumulator_initializer

static std::unique_ptr<rpybuild_AnalogAccumulator_initializer> cls;

void begin_init_AnalogAccumulator(py::module &m) {
  cls = std::make_unique<rpybuild_AnalogAccumulator_initializer>(m);
}

void finish_init_AnalogAccumulator() {
  cls->finish();
  cls.reset();
}