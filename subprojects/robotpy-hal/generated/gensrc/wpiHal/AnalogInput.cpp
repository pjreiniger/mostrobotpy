
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <hal/AnalogInput.h>
















#include <type_traits>






struct rpybuild_AnalogInput_initializer {













  py::module &m;

  
  rpybuild_AnalogInput_initializer(py::module &m) :

  

  

  

  

    m(m)
  {
    
    

    
  }

void finish() {







m
  .
def
("initializeAnalogInputPort", [](HAL_PortHandle portHandle, const char* allocationLocation) {
                    int32_t status;
          auto __ret =::HAL_InitializeAnalogInputPort(std::move(portHandle), allocationLocation, &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("portHandle"), py::arg("allocationLocation"), release_gil(), py::doc(
    "Initializes the analog input port using the given port object.\n"
"\n"
":param in:  portHandle Handle to the port to initialize.\n"
":param in:  allocationLocation the location where the allocation is occurring\n"
"            (can be null)\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: the created analog input handle")
  )
  
  ;
m
  .
def
("freeAnalogInputPort", &::HAL_FreeAnalogInputPort,
      py::arg("analogPortHandle"), release_gil(), py::doc(
    "Frees an analog input port.\n"
"\n"
":param in: out] analogPortHandle Handle to the analog port.")
  )
  
  ;
m
  .
def
("checkAnalogModule", &::HAL_CheckAnalogModule,
      py::arg("module"), release_gil(), py::doc(
    "Checks that the analog module number is valid.\n"
"\n"
":param in: module The analog module number.\n"
"\n"
":returns: Analog module is valid and present")
  )
  
  ;
m
  .
def
("checkAnalogInputChannel", &::HAL_CheckAnalogInputChannel,
      py::arg("channel"), release_gil(), py::doc(
    "Checks that the analog output channel number is valid.\n"
"Verifies that the analog channel number is one of the legal channel numbers.\n"
"Channel numbers are 0-based.\n"
"\n"
":param in: channel The analog output channel number.\n"
"\n"
":returns: Analog channel is valid")
  )
  
  ;
m
  .
def
("setAnalogInputSimDevice", &::HAL_SetAnalogInputSimDevice,
      py::arg("handle"), py::arg("device"), release_gil(), py::doc(
    "Indicates the analog input is used by a simulated device.\n"
"\n"
":param handle: the analog input handle\n"
":param device: simulated device handle")
  )
  
  ;
m
  .
def
("setAnalogSampleRate", [](double samplesPerSecond) {
                    int32_t status;
          ::HAL_SetAnalogSampleRate(std::move(samplesPerSecond), &status);
          return status;
        },
      py::arg("samplesPerSecond"), release_gil(), py::doc(
    "Sets the sample rate.\n"
"\n"
"This is a global setting for the Athena and effects all channels.\n"
"\n"
":param in:  samplesPerSecond The number of samples per channel per second.\n"
":param out: status          the error code, or 0 for success")
  )
  
  ;
m
  .
def
("getAnalogSampleRate", []() {
                    int32_t status;
          auto __ret =::HAL_GetAnalogSampleRate(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Gets the current sample rate.\n"
"\n"
"This assumes one entry in the scan list.\n"
"This is a global setting for the Athena and effects all channels.\n"
"\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: Sample rate.")
  )
  
  ;
m
  .
def
("setAnalogAverageBits", [](HAL_AnalogInputHandle analogPortHandle, int32_t bits) {
                    int32_t status;
          ::HAL_SetAnalogAverageBits(std::move(analogPortHandle), std::move(bits), &status);
          return status;
        },
      py::arg("analogPortHandle"), py::arg("bits"), release_gil(), py::doc(
    "Sets the number of averaging bits.\n"
"\n"
"This sets the number of averaging bits. The actual number of averaged samples\n"
"is 2**bits. Use averaging to improve the stability of your measurement at the\n"
"expense of sampling rate. The averaging is done automatically in the FPGA.\n"
"\n"
":param in:  analogPortHandle Handle to the analog port to configure.\n"
":param in:  bits Number of bits to average.\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("getAnalogAverageBits", [](HAL_AnalogInputHandle analogPortHandle) {
                    int32_t status;
          auto __ret =::HAL_GetAnalogAverageBits(std::move(analogPortHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("analogPortHandle"), release_gil(), py::doc(
    "Gets the number of averaging bits.\n"
"\n"
"This gets the number of averaging bits from the FPGA. The actual number of\n"
"averaged samples is 2**bits. The averaging is done automatically in the FPGA.\n"
"\n"
":param in:  analogPortHandle Handle to the analog port to use.\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: Bits to average.")
  )
  
  ;
m
  .
def
("setAnalogOversampleBits", [](HAL_AnalogInputHandle analogPortHandle, int32_t bits) {
                    int32_t status;
          ::HAL_SetAnalogOversampleBits(std::move(analogPortHandle), std::move(bits), &status);
          return status;
        },
      py::arg("analogPortHandle"), py::arg("bits"), release_gil(), py::doc(
    "Sets the number of oversample bits.\n"
"\n"
"This sets the number of oversample bits. The actual number of oversampled\n"
"values is 2**bits. Use oversampling to improve the resolution of your\n"
"measurements at the expense of sampling rate. The oversampling is done\n"
"automatically in the FPGA.\n"
"\n"
":param in:  analogPortHandle Handle to the analog port to use.\n"
":param in:  bits Number of bits to oversample.\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("getAnalogOversampleBits", [](HAL_AnalogInputHandle analogPortHandle) {
                    int32_t status;
          auto __ret =::HAL_GetAnalogOversampleBits(std::move(analogPortHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("analogPortHandle"), release_gil(), py::doc(
    "Gets the number of oversample bits.\n"
"\n"
"This gets the number of oversample bits from the FPGA. The actual number of\n"
"oversampled values is 2**bits. The oversampling is done automatically in the\n"
"FPGA.\n"
"\n"
":param in:  analogPortHandle Handle to the analog port to use.\n"
":param out: status          the error code, or 0 for success\n"
"\n"
":returns: Bits to oversample.")
  )
  
  ;
m
  .
def
("getAnalogValue", [](HAL_AnalogInputHandle analogPortHandle) {
                    int32_t status;
          auto __ret =::HAL_GetAnalogValue(std::move(analogPortHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("analogPortHandle"), release_gil(), py::doc(
    "Gets a sample straight from the channel on this module.\n"
"\n"
"The sample is a 12-bit value representing the 0V to 5V range of the A/D\n"
"converter in the module. The units are in A/D converter codes.  Use\n"
"GetVoltage() to get the analog value in calibrated units.\n"
"\n"
":param in:  analogPortHandle Handle to the analog port to use.\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: A sample straight from the channel on this module.")
  )
  
  ;
m
  .
def
("getAnalogAverageValue", [](HAL_AnalogInputHandle analogPortHandle) {
                    int32_t status;
          auto __ret =::HAL_GetAnalogAverageValue(std::move(analogPortHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("analogPortHandle"), release_gil(), py::doc(
    "Gets a sample from the output of the oversample and average engine for the\n"
"channel.\n"
"\n"
"The sample is 12-bit + the value configured in SetOversampleBits().\n"
"The value configured in SetAverageBits() will cause this value to be averaged\n"
"2**bits number of samples. This is not a sliding window.  The sample will not\n"
"change until 2**(OversampleBits + AverageBits) samples have been acquired\n"
"from the module on this channel. Use GetAverageVoltage() to get the analog\n"
"value in calibrated units.\n"
"\n"
":param in:  analogPortHandle Handle to the analog port to use.\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: A sample from the oversample and average engine for the channel.")
  )
  
  ;
m
  .
def
("getAnalogVoltsToValue", [](HAL_AnalogInputHandle analogPortHandle, double voltage) {
                    int32_t status;
          auto __ret =::HAL_GetAnalogVoltsToValue(std::move(analogPortHandle), std::move(voltage), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("analogPortHandle"), py::arg("voltage"), release_gil(), py::doc(
    "Converts a voltage to a raw value for a specified channel.\n"
"\n"
"This process depends on the calibration of each channel, so the channel must\n"
"be specified.\n"
"\n"
"@todo This assumes raw values.  Oversampling not supported as is.\n"
"\n"
":param in:  analogPortHandle Handle to the analog port to use.\n"
":param in:  voltage The voltage to convert.\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: The raw value for the channel.")
  )
  
  ;
m
  .
def
("getAnalogVoltage", [](HAL_AnalogInputHandle analogPortHandle) {
                    int32_t status;
          auto __ret =::HAL_GetAnalogVoltage(std::move(analogPortHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("analogPortHandle"), release_gil(), py::doc(
    "Gets a scaled sample straight from the channel on this module.\n"
"\n"
"The value is scaled to units of Volts using the calibrated scaling data from\n"
"GetLSBWeight() and GetOffset().\n"
"\n"
":param in:  analogPortHandle Handle to the analog port to use.\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: A scaled sample straight from the channel on this module.")
  )
  
  ;
m
  .
def
("getAnalogAverageVoltage", [](HAL_AnalogInputHandle analogPortHandle) {
                    int32_t status;
          auto __ret =::HAL_GetAnalogAverageVoltage(std::move(analogPortHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("analogPortHandle"), release_gil(), py::doc(
    "Gets a scaled sample from the output of the oversample and average engine for\n"
"the channel.\n"
"\n"
"The value is scaled to units of Volts using the calibrated scaling data from\n"
"GetLSBWeight() and GetOffset(). Using oversampling will cause this value to\n"
"be higher resolution, but it will update more slowly. Using averaging will\n"
"cause this value to be more stable, but it will update more slowly.\n"
"\n"
":param in:  analogPortHandle Handle to the analog port to use.\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: A scaled sample from the output of the oversample and average engine\n"
"          for the channel.")
  )
  
  ;
m
  .
def
("getAnalogLSBWeight", [](HAL_AnalogInputHandle analogPortHandle) {
                    int32_t status;
          auto __ret =::HAL_GetAnalogLSBWeight(std::move(analogPortHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("analogPortHandle"), release_gil(), py::doc(
    "Gets the factory scaling least significant bit weight constant.\n"
"The least significant bit weight constant for the channel that was calibrated\n"
"in manufacturing and stored in an eeprom in the module.\n"
"\n"
"Volts = ((LSB_Weight * 1e-9) * raw) - (Offset * 1e-9)\n"
"\n"
":param in:  analogPortHandle Handle to the analog port to use.\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: Least significant bit weight.")
  )
  
  ;
m
  .
def
("getAnalogOffset", [](HAL_AnalogInputHandle analogPortHandle) {
                    int32_t status;
          auto __ret =::HAL_GetAnalogOffset(std::move(analogPortHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("analogPortHandle"), release_gil(), py::doc(
    "Gets the factory scaling offset constant.\n"
"The offset constant for the channel that was calibrated in manufacturing and\n"
"stored in an eeprom in the module.\n"
"\n"
"Volts = ((LSB_Weight * 1e-9) * raw) - (Offset * 1e-9)\n"
"\n"
":param in:  analogPortHandle Handle to the analog port to use.\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: Offset constant.")
  )
  
  ;
m
  .
def
("getAnalogValueToVolts", [](HAL_AnalogInputHandle analogPortHandle, int32_t rawValue) {
                    int32_t status;
          auto __ret =::HAL_GetAnalogValueToVolts(std::move(analogPortHandle), std::move(rawValue), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("analogPortHandle"), py::arg("rawValue"), release_gil(), py::doc(
    "Get the analog voltage from a raw value.\n"
"\n"
":param in:  analogPortHandle  Handle to the analog port the values were read\n"
"            from.\n"
":param in:  rawValue          The raw analog value\n"
":param out: status           Error status variable. 0 on success.\n"
"\n"
":returns: The voltage relating to the value")
  )
  
  ;



}

}; // struct rpybuild_AnalogInput_initializer

static std::unique_ptr<rpybuild_AnalogInput_initializer> cls;

void begin_init_AnalogInput(py::module &m) {
  cls = std::make_unique<rpybuild_AnalogInput_initializer>(m);
}

void finish_init_AnalogInput() {
  cls->finish();
  cls.reset();
}