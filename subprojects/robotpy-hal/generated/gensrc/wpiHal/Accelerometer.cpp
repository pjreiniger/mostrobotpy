
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <hal/Accelerometer.h>
















#include <type_traits>






struct rpybuild_Accelerometer_initializer {







  
  py::enum_<::HAL_AccelerometerRange> enum1;







  py::module &m;

  
  rpybuild_Accelerometer_initializer(py::module &m) :

  

  
    enum1
  (m, "AccelerometerRange"
  ,
    "The acceptable accelerometer ranges."),
  

  

  

    m(m)
  {
    
    
      enum1
  
    .value("k2G", ::HAL_AccelerometerRange::HAL_AccelerometerRange_k2G)
  
    .value("k4G", ::HAL_AccelerometerRange::HAL_AccelerometerRange_k4G)
  
    .value("k8G", ::HAL_AccelerometerRange::HAL_AccelerometerRange_k8G)
  ;

    

    
  }

void finish() {







m
  .
def
("setAccelerometerActive", &::HAL_SetAccelerometerActive,
      py::arg("active"), release_gil(), py::doc(
    "Sets the accelerometer to active or standby mode.\n"
"\n"
"It must be in standby mode to change any configuration.\n"
"\n"
":param active: true to set to active, false for standby")
  )
  
  ;
m
  .
def
("setAccelerometerRange", &::HAL_SetAccelerometerRange,
      py::arg("range"), release_gil(), py::doc(
    "Sets the range of values that can be measured (either 2, 4, or 8 g-forces).\n"
"\n"
"The accelerometer should be in standby mode when this is called.\n"
"\n"
":param range: the accelerometer range")
  )
  
  ;
m
  .
def
("getAccelerometerX", &::HAL_GetAccelerometerX, release_gil(), py::doc(
    "Gets the x-axis acceleration.\n"
"\n"
"This is a floating point value in units of 1 g-force.\n"
"\n"
":returns: the X acceleration")
  )
  
  ;
m
  .
def
("getAccelerometerY", &::HAL_GetAccelerometerY, release_gil(), py::doc(
    "Gets the y-axis acceleration.\n"
"\n"
"This is a floating point value in units of 1 g-force.\n"
"\n"
":returns: the Y acceleration")
  )
  
  ;
m
  .
def
("getAccelerometerZ", &::HAL_GetAccelerometerZ, release_gil(), py::doc(
    "Gets the z-axis acceleration.\n"
"\n"
"This is a floating point value in units of 1 g-force.\n"
"\n"
":returns: the Z acceleration")
  )
  
  ;



}

}; // struct rpybuild_Accelerometer_initializer

static std::unique_ptr<rpybuild_Accelerometer_initializer> cls;

void begin_init_Accelerometer(py::module &m) {
  cls = std::make_unique<rpybuild_Accelerometer_initializer>(m);
}

void finish_init_Accelerometer() {
  cls->finish();
  cls.reset();
}