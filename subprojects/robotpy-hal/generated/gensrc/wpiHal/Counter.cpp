
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <hal/Counter.h>
















#include <type_traits>






struct rpybuild_Counter_initializer {







  
  py::enum_<::HAL_Counter_Mode> enum1;







  py::module &m;

  
  rpybuild_Counter_initializer(py::module &m) :

  

  
    enum1
  (m, "CounterMode"
  ,
    "The counter mode."),
  

  

  

    m(m)
  {
    
    
      enum1
  
    .value("kTwoPulse", ::HAL_Counter_Mode::HAL_Counter_kTwoPulse)
  
    .value("kSemiperiod", ::HAL_Counter_Mode::HAL_Counter_kSemiperiod)
  
    .value("kPulseLength", ::HAL_Counter_Mode::HAL_Counter_kPulseLength)
  
    .value("kExternalDirection", ::HAL_Counter_Mode::HAL_Counter_kExternalDirection)
  ;

    

    
  }

void finish() {







m
  .
def
("initializeCounter", [](HAL_Counter_Mode mode) {
                    int32_t index;
          int32_t status;
          auto __ret =::HAL_InitializeCounter(std::move(mode), &index, &status);
          return std::make_tuple(__ret,index,status);
        },
      py::arg("mode"), release_gil(), py::doc(
    "Initializes a counter.\n"
"\n"
":param in:  mode    the counter mode\n"
":param in:  index   the compressor index (output)\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: the created handle")
  )
  
  ;
m
  .
def
("freeCounter", [](HAL_CounterHandle counterHandle) {
                    int32_t status;
          ::HAL_FreeCounter(std::move(counterHandle), &status);
          return status;
        },
      py::arg("counterHandle"), release_gil(), py::doc(
    "Frees a counter.\n"
"\n"
":param in:  counterHandle the counter handle\n"
":param out: status       Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setCounterAverageSize", [](HAL_CounterHandle counterHandle, int32_t size) {
                    int32_t status;
          ::HAL_SetCounterAverageSize(std::move(counterHandle), std::move(size), &status);
          return status;
        },
      py::arg("counterHandle"), py::arg("size"), release_gil(), py::doc(
    "Sets the average sample size of a counter.\n"
"\n"
":param in:  counterHandle  the counter handle\n"
":param in:  size           the size of samples to average\n"
":param out: status        Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setCounterUpSource", [](HAL_CounterHandle counterHandle, HAL_Handle digitalSourceHandle, HAL_AnalogTriggerType analogTriggerType) {
                    int32_t status;
          ::HAL_SetCounterUpSource(std::move(counterHandle), std::move(digitalSourceHandle), std::move(analogTriggerType), &status);
          return status;
        },
      py::arg("counterHandle"), py::arg("digitalSourceHandle"), py::arg("analogTriggerType"), release_gil(), py::doc(
    "Sets the source object that causes the counter to count up.\n"
"\n"
":param in:  counterHandle       the counter handle\n"
":param in:  digitalSourceHandle the digital source handle (either a\n"
"            HAL_AnalogTriggerHandle or a\n"
"            HAL_DigitalHandle)\n"
":param in:  analogTriggerType   the analog trigger type if the source is an\n"
"            analog trigger\n"
":param out: status             Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setCounterUpSourceEdge", [](HAL_CounterHandle counterHandle, HAL_Bool risingEdge, HAL_Bool fallingEdge) {
                    int32_t status;
          ::HAL_SetCounterUpSourceEdge(std::move(counterHandle), std::move(risingEdge), std::move(fallingEdge), &status);
          return status;
        },
      py::arg("counterHandle"), py::arg("risingEdge"), py::arg("fallingEdge"), release_gil(), py::doc(
    "Sets the up source to either detect rising edges or falling edges.\n"
"\n"
"Note that both are allowed to be set true at the same time without issues.\n"
"\n"
":param in:  counterHandle  the counter handle\n"
":param in:  risingEdge     true to trigger on rising\n"
":param in:  fallingEdge    true to trigger on falling\n"
":param out: status        Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("clearCounterUpSource", [](HAL_CounterHandle counterHandle) {
                    int32_t status;
          ::HAL_ClearCounterUpSource(std::move(counterHandle), &status);
          return status;
        },
      py::arg("counterHandle"), release_gil(), py::doc(
    "Disables the up counting source to the counter.\n"
"\n"
":param in:  counterHandle the counter handle\n"
":param out: status       Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setCounterDownSource", [](HAL_CounterHandle counterHandle, HAL_Handle digitalSourceHandle, HAL_AnalogTriggerType analogTriggerType) {
                    int32_t status;
          ::HAL_SetCounterDownSource(std::move(counterHandle), std::move(digitalSourceHandle), std::move(analogTriggerType), &status);
          return status;
        },
      py::arg("counterHandle"), py::arg("digitalSourceHandle"), py::arg("analogTriggerType"), release_gil(), py::doc(
    "Sets the source object that causes the counter to count down.\n"
"\n"
":param in:  counterHandle       the counter handle\n"
":param in:  digitalSourceHandle the digital source handle (either a\n"
"            HAL_AnalogTriggerHandle or a\n"
"            HAL_DigitalHandle)\n"
":param in:  analogTriggerType   the analog trigger type if the source is an\n"
"            analog trigger\n"
":param out: status             Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setCounterDownSourceEdge", [](HAL_CounterHandle counterHandle, HAL_Bool risingEdge, HAL_Bool fallingEdge) {
                    int32_t status;
          ::HAL_SetCounterDownSourceEdge(std::move(counterHandle), std::move(risingEdge), std::move(fallingEdge), &status);
          return status;
        },
      py::arg("counterHandle"), py::arg("risingEdge"), py::arg("fallingEdge"), release_gil(), py::doc(
    "Sets the down source to either detect rising edges or falling edges.\n"
"Note that both are allowed to be set true at the same time without issues.\n"
"\n"
":param in:  counterHandle  the counter handle\n"
":param in:  risingEdge     true to trigger on rising\n"
":param in:  fallingEdge    true to trigger on falling\n"
":param out: status        Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("clearCounterDownSource", [](HAL_CounterHandle counterHandle) {
                    int32_t status;
          ::HAL_ClearCounterDownSource(std::move(counterHandle), &status);
          return status;
        },
      py::arg("counterHandle"), release_gil(), py::doc(
    "Disables the down counting source to the counter.\n"
"\n"
":param in:  counterHandle the counter handle\n"
":param out: status       Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setCounterUpDownMode", [](HAL_CounterHandle counterHandle) {
                    int32_t status;
          ::HAL_SetCounterUpDownMode(std::move(counterHandle), &status);
          return status;
        },
      py::arg("counterHandle"), release_gil(), py::doc(
    "Sets standard up / down counting mode on this counter.\n"
"\n"
"Up and down counts are sourced independently from two inputs.\n"
"\n"
":param in:  counterHandle the counter handle\n"
":param out: status       Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setCounterExternalDirectionMode", [](HAL_CounterHandle counterHandle) {
                    int32_t status;
          ::HAL_SetCounterExternalDirectionMode(std::move(counterHandle), &status);
          return status;
        },
      py::arg("counterHandle"), release_gil(), py::doc(
    "Sets directional counting mode on this counter.\n"
"\n"
"The direction is determined by the B input, with counting happening with the\n"
"A input.\n"
"\n"
":param in:  counterHandle the counter handle\n"
":param out: status       Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setCounterSemiPeriodMode", [](HAL_CounterHandle counterHandle, HAL_Bool highSemiPeriod) {
                    int32_t status;
          ::HAL_SetCounterSemiPeriodMode(std::move(counterHandle), std::move(highSemiPeriod), &status);
          return status;
        },
      py::arg("counterHandle"), py::arg("highSemiPeriod"), release_gil(), py::doc(
    "Sets Semi-period mode on this counter.\n"
"\n"
"The counter counts up based on the time the input is triggered. High or Low\n"
"depends on the highSemiPeriod parameter.\n"
"\n"
":param in:  counterHandle  the counter handle\n"
":param in:  highSemiPeriod true for counting when the input is high, false for\n"
"            low\n"
":param out: status        Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setCounterPulseLengthMode", [](HAL_CounterHandle counterHandle, double threshold) {
                    int32_t status;
          ::HAL_SetCounterPulseLengthMode(std::move(counterHandle), std::move(threshold), &status);
          return status;
        },
      py::arg("counterHandle"), py::arg("threshold"), release_gil(), py::doc(
    "Configures the counter to count in up or down based on the length of the\n"
"input pulse.\n"
"\n"
"This mode is most useful for direction sensitive gear tooth sensors.\n"
"\n"
":param in:  counterHandle the counter handle\n"
":param in:  threshold     The pulse length beyond which the counter counts the\n"
"            opposite direction (seconds)\n"
":param out: status       Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("getCounterSamplesToAverage", [](HAL_CounterHandle counterHandle) {
                    int32_t status;
          auto __ret =::HAL_GetCounterSamplesToAverage(std::move(counterHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("counterHandle"), release_gil(), py::doc(
    "Gets the Samples to Average which specifies the number of samples of the\n"
"timer to average when calculating the period. Perform averaging to account\n"
"for mechanical imperfections or as oversampling to increase resolution.\n"
"\n"
":param in:  counterHandle the counter handle\n"
":param out: status       Error status variable. 0 on success.\n"
"\n"
":returns: SamplesToAverage The number of samples being averaged (from 1 to 127)")
  )
  
  ;
m
  .
def
("setCounterSamplesToAverage", [](HAL_CounterHandle counterHandle, int32_t samplesToAverage) {
                    int32_t status;
          ::HAL_SetCounterSamplesToAverage(std::move(counterHandle), std::move(samplesToAverage), &status);
          return status;
        },
      py::arg("counterHandle"), py::arg("samplesToAverage"), release_gil(), py::doc(
    "Sets the Samples to Average which specifies the number of samples of the\n"
"timer to average when calculating the period. Perform averaging to account\n"
"for mechanical imperfections or as oversampling to increase resolution.\n"
"\n"
":param in:  counterHandle    the counter handle\n"
":param in:  samplesToAverage The number of samples to average from 1 to 127\n"
":param out: status          Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("resetCounter", [](HAL_CounterHandle counterHandle) {
                    int32_t status;
          ::HAL_ResetCounter(std::move(counterHandle), &status);
          return status;
        },
      py::arg("counterHandle"), release_gil(), py::doc(
    "Resets the Counter to zero.\n"
"\n"
"Sets the counter value to zero. This does not effect the running state of the\n"
"counter, just sets the current value to zero.\n"
"\n"
":param in:  counterHandle the counter handle\n"
":param out: status       Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("getCounter", [](HAL_CounterHandle counterHandle) {
                    int32_t status;
          auto __ret =::HAL_GetCounter(std::move(counterHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("counterHandle"), release_gil(), py::doc(
    "Reads the current counter value.\n"
"\n"
"Reads the value at this instant. It may still be running, so it reflects the\n"
"current value. Next time it is read, it might have a different value.\n"
"\n"
":param in:  counterHandle the counter handle\n"
":param out: status       Error status variable. 0 on success.\n"
"\n"
":returns: the current counter value")
  )
  
  ;
m
  .
def
("getCounterPeriod", [](HAL_CounterHandle counterHandle) {
                    int32_t status;
          auto __ret =::HAL_GetCounterPeriod(std::move(counterHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("counterHandle"), release_gil(), py::doc(
    "Gets the Period of the most recent count.\n"
"\n"
"Returns the time interval of the most recent count. This can be used for\n"
"velocity calculations to determine shaft speed.\n"
"\n"
":param in:  counterHandle the counter handle\n"
":param out: status       Error status variable. 0 on success.\n"
"\n"
":returns: the period of the last two pulses in units of seconds")
  )
  
  ;
m
  .
def
("setCounterMaxPeriod", [](HAL_CounterHandle counterHandle, double maxPeriod) {
                    int32_t status;
          ::HAL_SetCounterMaxPeriod(std::move(counterHandle), std::move(maxPeriod), &status);
          return status;
        },
      py::arg("counterHandle"), py::arg("maxPeriod"), release_gil(), py::doc(
    "Sets the maximum period where the device is still considered \"moving\".\n"
"\n"
"Sets the maximum period where the device is considered moving. This value is\n"
"used to determine the \"stopped\" state of the counter using the\n"
"HAL_GetCounterStopped method.\n"
"\n"
":param in:  counterHandle the counter handle\n"
":param in:  maxPeriod     the maximum period where the counted device is\n"
"            considered moving in seconds\n"
":param out: status       Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setCounterUpdateWhenEmpty", [](HAL_CounterHandle counterHandle, HAL_Bool enabled) {
                    int32_t status;
          ::HAL_SetCounterUpdateWhenEmpty(std::move(counterHandle), std::move(enabled), &status);
          return status;
        },
      py::arg("counterHandle"), py::arg("enabled"), release_gil(), py::doc(
    "Selects whether you want to continue updating the event timer output when\n"
"there are no samples captured.\n"
"\n"
"The output of the event timer has a buffer of periods that are averaged and\n"
"posted to a register on the FPGA.  When the timer detects that the event\n"
"source has stopped (based on the MaxPeriod) the buffer of samples to be\n"
"averaged is emptied.\n"
"\n"
"If you enable the update when empty, you will be\n"
"notified of the stopped source and the event time will report 0 samples.\n"
"\n"
"If you disable update when empty, the most recent average will remain on the\n"
"output until a new sample is acquired.\n"
"\n"
"You will never see 0 samples output (except when there have been no events\n"
"since an FPGA reset) and you will likely not see the stopped bit become true\n"
"(since it is updated at the end of an average and there are no samples to\n"
"average).\n"
"\n"
":param in:  counterHandle the counter handle\n"
":param in:  enabled       true to enable counter updating with no samples\n"
":param out: status       Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("getCounterStopped", [](HAL_CounterHandle counterHandle) {
                    int32_t status;
          auto __ret =::HAL_GetCounterStopped(std::move(counterHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("counterHandle"), release_gil(), py::doc(
    "Determines if the clock is stopped.\n"
"\n"
"Determine if the clocked input is stopped based on the MaxPeriod value set\n"
"using the SetMaxPeriod method. If the clock exceeds the MaxPeriod, then the\n"
"device (and counter) are assumed to be stopped and it returns true.\n"
"\n"
":param in:  counterHandle the counter handle\n"
":param out: status       Error status variable. 0 on success.\n"
"\n"
":returns: true if the most recent counter period exceeds the MaxPeriod value\n"
"          set by SetMaxPeriod")
  )
  
  ;
m
  .
def
("getCounterDirection", [](HAL_CounterHandle counterHandle) {
                    int32_t status;
          auto __ret =::HAL_GetCounterDirection(std::move(counterHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("counterHandle"), release_gil(), py::doc(
    "Gets the last direction the counter value changed.\n"
"\n"
":param in:  counterHandle the counter handle\n"
":param out: status       Error status variable. 0 on success.\n"
"\n"
":returns: the last direction the counter value changed")
  )
  
  ;
m
  .
def
("setCounterReverseDirection", [](HAL_CounterHandle counterHandle, HAL_Bool reverseDirection) {
                    int32_t status;
          ::HAL_SetCounterReverseDirection(std::move(counterHandle), std::move(reverseDirection), &status);
          return status;
        },
      py::arg("counterHandle"), py::arg("reverseDirection"), release_gil(), py::doc(
    "Sets the Counter to return reversed sensing on the direction.\n"
"\n"
"This allows counters to change the direction they are counting in the case of\n"
"1X and 2X quadrature encoding only. Any other counter mode isn't supported.\n"
"\n"
":param in:  counterHandle    the counter handle\n"
":param in:  reverseDirection true if the value counted should be negated.\n"
":param out: status          Error status variable. 0 on success.")
  )
  
  ;



}

}; // struct rpybuild_Counter_initializer

static std::unique_ptr<rpybuild_Counter_initializer> cls;

void begin_init_Counter(py::module &m) {
  cls = std::make_unique<rpybuild_Counter_initializer>(m);
}

void finish_init_Counter() {
  cls->finish();
  cls.reset();
}