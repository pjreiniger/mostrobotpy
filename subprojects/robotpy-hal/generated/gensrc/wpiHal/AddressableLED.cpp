
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <hal/AddressableLED.h>
















#include <type_traits>






struct rpybuild_AddressableLED_initializer {













  py::module &m;

  
  rpybuild_AddressableLED_initializer(py::module &m) :

  

  

  

  

    m(m)
  {
    
    

    
  }

void finish() {







m
  .
def
("initializeAddressableLED", [](HAL_DigitalHandle outputPort) {
                    int32_t status;
          auto __ret =::HAL_InitializeAddressableLED(std::move(outputPort), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("outputPort"), release_gil(), py::doc(
    "Initialize Addressable LED using a PWM Digital handle.\n"
"\n"
":param in:  outputPort handle of the digital port for PWM\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: Addressable LED handle")
  )
  
  ;
m
  .
def
("freeAddressableLED", &::HAL_FreeAddressableLED,
      py::arg("handle"), release_gil(), py::doc(
    "Free the Addressable LED Handle.\n"
"\n"
":param in: handle the Addressable LED handle to free")
  )
  
  ;
m
  .
def
("setAddressableLEDOutputPort", [](HAL_AddressableLEDHandle handle, HAL_DigitalHandle outputPort) {
                    int32_t status;
          ::HAL_SetAddressableLEDOutputPort(std::move(handle), std::move(outputPort), &status);
          return status;
        },
      py::arg("handle"), py::arg("outputPort"), release_gil(), py::doc(
    "Set the Addressable LED PWM Digital port.\n"
"\n"
":param in:  handle the Addressable LED handle\n"
":param in:  outputPort The digital handle of the PWM port\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("setAddressableLEDLength", [](HAL_AddressableLEDHandle handle, int32_t length) {
                    int32_t status;
          ::HAL_SetAddressableLEDLength(std::move(handle), std::move(length), &status);
          return status;
        },
      py::arg("handle"), py::arg("length"), release_gil(), py::doc(
    "Sets the length of the LED strip.\n"
"\n"
"The max length is 5460 LEDs.\n"
"\n"
":param in:  handle the Addressable LED handle\n"
":param in:  length the strip length\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("writeAddressableLEDData", [](HAL_AddressableLEDHandle handle, const struct HAL_AddressableLEDData* data, int32_t length) {
                    int32_t status;
          ::HAL_WriteAddressableLEDData(std::move(handle), data, std::move(length), &status);
          return status;
        },
      py::arg("handle"), py::arg("data"), py::arg("length"), release_gil(), py::doc(
    "Sets the led output data.\n"
"\n"
"If the output is enabled, this will start writing the next data cycle.\n"
"It is safe to call, even while output is enabled.\n"
"\n"
":param in:  handle the Addressable LED handle\n"
":param in:  data the buffer to write\n"
":param in:  length the strip length\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("setAddressableLEDBitTiming", [](HAL_AddressableLEDHandle handle, int32_t highTime0NanoSeconds, int32_t lowTime0NanoSeconds, int32_t highTime1NanoSeconds, int32_t lowTime1NanoSeconds) {
                    int32_t status;
          ::HAL_SetAddressableLEDBitTiming(std::move(handle), std::move(highTime0NanoSeconds), std::move(lowTime0NanoSeconds), std::move(highTime1NanoSeconds), std::move(lowTime1NanoSeconds), &status);
          return status;
        },
      py::arg("handle"), py::arg("highTime0NanoSeconds"), py::arg("lowTime0NanoSeconds"), py::arg("highTime1NanoSeconds"), py::arg("lowTime1NanoSeconds"), release_gil(), py::doc(
    "Sets the bit timing.\n"
"\n"
"By default, the driver is set up to drive WS2812Bs, so nothing needs to\n"
"be set for those.\n"
"\n"
":param in:  handle the Addressable LED handle\n"
":param in:  highTime0NanoSeconds high time for 0 bit (default 400ns)\n"
":param in:  lowTime0NanoSeconds low time for 0 bit (default 900ns)\n"
":param in:  highTime1NanoSeconds high time for 1 bit (default 900ns)\n"
":param in:  lowTime1NanoSeconds low time for 1 bit (default 600ns)\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("setAddressableLEDSyncTime", [](HAL_AddressableLEDHandle handle, int32_t syncTimeMicroSeconds) {
                    int32_t status;
          ::HAL_SetAddressableLEDSyncTime(std::move(handle), std::move(syncTimeMicroSeconds), &status);
          return status;
        },
      py::arg("handle"), py::arg("syncTimeMicroSeconds"), release_gil(), py::doc(
    "Sets the sync time.\n"
"\n"
"The sync time is the time to hold output so LEDs enable. Default set for\n"
"WS2812B.\n"
"\n"
":param in:  handle the Addressable LED handle\n"
":param in:  syncTimeMicroSeconds the sync time (default 280us)\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("startAddressableLEDOutput", [](HAL_AddressableLEDHandle handle) {
                    int32_t status;
          ::HAL_StartAddressableLEDOutput(std::move(handle), &status);
          return status;
        },
      py::arg("handle"), release_gil(), py::doc(
    "Starts the output.\n"
"\n"
"The output writes continuously.\n"
"\n"
":param in:  handle the Addressable LED handle\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("stopAddressableLEDOutput", [](HAL_AddressableLEDHandle handle) {
                    int32_t status;
          ::HAL_StopAddressableLEDOutput(std::move(handle), &status);
          return status;
        },
      py::arg("handle"), release_gil(), py::doc(
    "Stops the output.\n"
"\n"
":param in:  handle the Addressable LED handle\n"
":param out: status the error code, or 0 for success")
  )
  
  ;



}

}; // struct rpybuild_AddressableLED_initializer

static std::unique_ptr<rpybuild_AddressableLED_initializer> cls;

void begin_init_AddressableLED(py::module &m) {
  cls = std::make_unique<rpybuild_AddressableLED_initializer>(m);
}

void finish_init_AddressableLED() {
  cls->finish();
  cls.reset();
}