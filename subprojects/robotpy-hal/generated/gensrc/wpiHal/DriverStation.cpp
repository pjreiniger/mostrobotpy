
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <hal/DriverStation.h>
















#include <type_traits>




struct rpybuild_DriverStation_initializer {













  py::module &m;

  
  rpybuild_DriverStation_initializer(py::module &m) :

  

  

  

  

    m(m)
  {
    
    

    
  }

void finish() {







m
  .
def
("sendError", &::HAL_SendError,
      py::arg("isError"), py::arg("errorCode"), py::arg("isLVCode"), py::arg("details"), py::arg("location"), py::arg("callStack"), py::arg("printMsg"), release_gil(), py::doc(
    "Sends an error to the driver station.\n"
"\n"
":param isError:   true for error, false for warning\n"
":param errorCode: the error code\n"
":param isLVCode:  true for a LV error code, false for a standard error code\n"
":param details:   the details of the error\n"
":param location:  the file location of the error\n"
":param callStack: the callstack of the error\n"
":param printMsg:  true to print the error message to stdout as well as to the\n"
"                  DS\n"
"\n"
":returns: the error code, or 0 for success")
  )
  
  ;
m
  .
def
("sendConsoleLine", &::HAL_SendConsoleLine,
      py::arg("line"), release_gil(), py::doc(
    "Sends a line to the driver station console.\n"
"\n"
":param line: the line to send (null terminated)\n"
"\n"
":returns: the error code, or 0 for success")
  )
  
  ;
m
  .
def
("getControlWord", &::HAL_GetControlWord,
      py::arg("controlWord"), release_gil(), py::doc(
    "Gets the current control word of the driver station.\n"
"\n"
"The control word contains the robot state.\n"
"\n"
":param controlWord: the control word (out)\n"
"\n"
":returns: the error code, or 0 for success")
  )
  
  ;
m
  .
def
("getAllianceStation", []() {
                    int32_t status;
          auto __ret =::HAL_GetAllianceStation(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Gets the current alliance station ID.\n"
"\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: the alliance station ID")
  )
  
  ;
m
  .
def
("getJoystickAxes", &::HAL_GetJoystickAxes,
      py::arg("joystickNum"), py::arg("axes"), release_gil(), py::doc(
    "Gets the axes of a specific joystick.\n"
"\n"
":param joystickNum: the joystick number\n"
":param axes:        the axes values (output)\n"
"\n"
":returns: the error code, or 0 for success")
  )
  
  ;
m
  .
def
("getJoystickPOVs", &::HAL_GetJoystickPOVs,
      py::arg("joystickNum"), py::arg("povs"), release_gil(), py::doc(
    "Gets the POVs of a specific joystick.\n"
"\n"
":param joystickNum: the joystick number\n"
":param povs:        the POV values (output)\n"
"\n"
":returns: the error code, or 0 for success")
  )
  
  ;
m
  .
def
("getJoystickButtons", &::HAL_GetJoystickButtons,
      py::arg("joystickNum"), py::arg("buttons"), release_gil(), py::doc(
    "Gets the buttons of a specific joystick.\n"
"\n"
":param joystickNum: the joystick number\n"
":param buttons:     the button values (output)\n"
"\n"
":returns: the error code, or 0 for success")
  )
  
  ;
m
  .
def
("getAllJoystickData", &::HAL_GetAllJoystickData,
      py::arg("axes"), py::arg("povs"), py::arg("buttons"), release_gil()
  )
  
  ;
m
  .
def
("getJoystickDescriptor", &::HAL_GetJoystickDescriptor,
      py::arg("joystickNum"), py::arg("desc"), release_gil(), py::doc(
    "Retrieves the Joystick Descriptor for particular slot.\n"
"\n"
":param joystickNum: the joystick number\n"
":param out:         desc   descriptor (data transfer object) to fill in. desc is\n"
"                    filled in regardless of success. In other words, if\n"
"                    descriptor is not available, desc is filled in with\n"
"                    default values matching the init-values in Java and C++\n"
"                    Driver Station for when caller requests a too-large\n"
"                    joystick index.\n"
"\n"
":returns: error code reported from Network Comm back-end.  Zero is good,\n"
"          nonzero is bad.")
  )
  
  ;
m
  .
def
("getJoystickIsXbox", &::HAL_GetJoystickIsXbox,
      py::arg("joystickNum"), release_gil(), py::doc(
    "Gets whether a specific joystick is considered to be an XBox controller.\n"
"\n"
":param joystickNum: the joystick number\n"
"\n"
":returns: true if xbox, false otherwise")
  )
  
  ;
m
  .
def
("getJoystickType", &::HAL_GetJoystickType,
      py::arg("joystickNum"), release_gil(), py::doc(
    "Gets the type of joystick connected.\n"
"\n"
"This is device specific, and different depending on what system input type\n"
"the joystick uses.\n"
"\n"
":param joystickNum: the joystick number\n"
"\n"
":returns: the enumerated joystick type")
  )
  
  ;
m
  .
def
("getJoystickName", [](int32_t joystickNum) {
  WPI_String name;
  HAL_GetJoystickName(&name, joystickNum);
  std::string sname(wpi::to_string_view(&name));
  WPI_FreeString(&name);
  return sname;
}
,
      py::arg("joystickNum"), py::doc(
    "Gets the name of a joystick.\n"
"\n"
"The returned string must be freed with WPI_FreeString\n"
"\n"
":param name:        the joystick name string\n"
":param joystickNum: the joystick number")
  )
  
  ;
m
  .
def
("getJoystickAxisType", &::HAL_GetJoystickAxisType,
      py::arg("joystickNum"), py::arg("axis"), release_gil(), py::doc(
    "Gets the type of a specific joystick axis.\n"
"\n"
"This is device specific, and different depending on what system input type\n"
"the joystick uses.\n"
"\n"
":param joystickNum: the joystick number\n"
":param axis:        the axis number\n"
"\n"
":returns: the enumerated axis type")
  )
  
  ;
m
  .
def
("setJoystickOutputs", &::HAL_SetJoystickOutputs,
      py::arg("joystickNum"), py::arg("outputs"), py::arg("leftRumble"), py::arg("rightRumble"), release_gil(), py::doc(
    "Set joystick outputs.\n"
"\n"
":param joystickNum: the joystick number\n"
":param outputs:     bitmask of outputs, 1 for on 0 for off\n"
":param leftRumble:  the left rumble value (0-FFFF)\n"
":param rightRumble: the right rumble value (0-FFFF)\n"
"\n"
":returns: the error code, or 0 for success")
  )
  
  ;
m
  .
def
("getMatchTime", []() {
                    int32_t status;
          auto __ret =::HAL_GetMatchTime(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Return the approximate match time. The FMS does not send an official match\n"
"time to the robots, but does send an approximate match time. The value will\n"
"count down the time remaining in the current period (auto or teleop).\n"
"Warning: This is not an official time (so it cannot be used to dispute ref\n"
"calls or guarantee that a function will trigger before the match ends).\n"
"\n"
"When connected to the real field, this number only changes in full integer\n"
"increments, and always counts down.\n"
"\n"
"When the DS is in practice mode, this number is a floating point number,\n"
"and counts down.\n"
"\n"
"When the DS is in teleop or autonomous mode, this number is a floating\n"
"point number, and counts up.\n"
"\n"
"Simulation matches DS behavior without an FMS connected.\n"
"\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: Time remaining in current match period (auto or teleop) in seconds")
  )
  
  ;
m
  .
def
("getOutputsEnabled", &::HAL_GetOutputsEnabled, release_gil(), py::doc(
    "Gets if outputs are enabled by the control system.\n"
"\n"
":returns: true if outputs are enabled")
  )
  
  ;
m
  .
def
("getMatchInfo", &::HAL_GetMatchInfo,
      py::arg("info"), release_gil(), py::doc(
    "Gets info about a specific match.\n"
"\n"
":param in: info the match info (output)\n"
"\n"
":returns: the error code, or 0 for success")
  )
  
  ;
m
  .
def
("refreshDSData", &::HAL_RefreshDSData, release_gil(), py::doc(
    "Refresh the DS control word.\n"
"\n"
":returns: true if updated")
  )
  
  ;
m
  .
def
("provideNewDataEventHandle", &::HAL_ProvideNewDataEventHandle,
      py::arg("handle"), release_gil(), py::doc(
    "Adds an event handle to be signalled when new data arrives.\n"
"\n"
":param handle: the event handle to be signalled")
  )
  
  ;
m
  .
def
("removeNewDataEventHandle", &::HAL_RemoveNewDataEventHandle,
      py::arg("handle"), release_gil(), py::doc(
    "Removes the event handle from being signalled when new data arrives.\n"
"\n"
":param handle: the event handle to remove")
  )
  
  ;
m
  .
def
("observeUserProgramStarting", &::HAL_ObserveUserProgramStarting, release_gil(), py::doc(
    "Sets the program starting flag in the DS.\n"
"\n"
"This is what changes the DS to showing robot code ready.")
  )
  
  ;
m
  .
def
("observeUserProgramDisabled", &::HAL_ObserveUserProgramDisabled, release_gil(), py::doc(
    "Sets the disabled flag in the DS.\n"
"\n"
"This is used for the DS to ensure the robot is properly responding to its\n"
"state request. Ensure this gets called about every 50ms, or the robot will be\n"
"disabled by the DS.")
  )
  
  ;
m
  .
def
("observeUserProgramAutonomous", &::HAL_ObserveUserProgramAutonomous, release_gil(), py::doc(
    "Sets the autonomous enabled flag in the DS.\n"
"\n"
"This is used for the DS to ensure the robot is properly responding to its\n"
"state request. Ensure this gets called about every 50ms, or the robot will be\n"
"disabled by the DS.")
  )
  
  ;
m
  .
def
("observeUserProgramTeleop", &::HAL_ObserveUserProgramTeleop, release_gil(), py::doc(
    "Sets the teleoperated enabled flag in the DS.\n"
"\n"
"This is used for the DS to ensure the robot is properly responding to its\n"
"state request. Ensure this gets called about every 50ms, or the robot will be\n"
"disabled by the DS.")
  )
  
  ;
m
  .
def
("observeUserProgramTest", &::HAL_ObserveUserProgramTest, release_gil(), py::doc(
    "Sets the test mode flag in the DS.\n"
"\n"
"This is used for the DS to ensure the robot is properly responding to its\n"
"state request. Ensure this gets called about every 50ms, or the robot will be\n"
"disabled by the DS.")
  )
  
  ;



}

}; // struct rpybuild_DriverStation_initializer

static std::unique_ptr<rpybuild_DriverStation_initializer> cls;

void begin_init_DriverStation(py::module &m) {
  cls = std::make_unique<rpybuild_DriverStation_initializer>(m);
}

void finish_init_DriverStation() {
  cls->finish();
  cls.reset();
}