
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <hal/Relay.h>
















#include <type_traits>




struct rpybuild_Relay_initializer {













  py::module &m;

  
  rpybuild_Relay_initializer(py::module &m) :

  

  

  

  

    m(m)
  {
    
    

    
  }

void finish() {







m
  .
def
("initializeRelayPort", [](HAL_PortHandle portHandle, HAL_Bool fwd, const char* allocationLocation) {
                    int32_t status;
          auto __ret =::HAL_InitializeRelayPort(std::move(portHandle), std::move(fwd), allocationLocation, &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("portHandle"), py::arg("fwd"), py::arg("allocationLocation"), release_gil(), py::doc(
    "Initializes a relay.\n"
"\n"
"Note this call will only initialize either the forward or reverse port of the\n"
"relay. If you need both, you will need to initialize 2 relays.\n"
"\n"
":param in:  portHandle         the port handle to initialize\n"
":param in:  fwd                true for the forward port, false for the\n"
"            reverse port\n"
":param in:  allocationLocation the location where the allocation is occurring\n"
"            (can be null)\n"
":param out: status            Error status variable. 0 on success.\n"
"\n"
":returns: the created relay handle")
  )
  
  ;
m
  .
def
("freeRelayPort", &::HAL_FreeRelayPort,
      py::arg("relayPortHandle"), release_gil(), py::doc(
    "Frees a relay port.\n"
"\n"
":param relayPortHandle: the relay handle")
  )
  
  ;
m
  .
def
("checkRelayChannel", &::HAL_CheckRelayChannel,
      py::arg("channel"), release_gil(), py::doc(
    "Checks if a relay channel is valid.\n"
"\n"
":param channel: the channel to check\n"
"\n"
":returns: true if the channel is valid, otherwise false")
  )
  
  ;
m
  .
def
("setRelay", [](HAL_RelayHandle relayPortHandle, HAL_Bool on) {
                    int32_t status;
          ::HAL_SetRelay(std::move(relayPortHandle), std::move(on), &status);
          return status;
        },
      py::arg("relayPortHandle"), py::arg("on"), release_gil(), py::doc(
    "Sets the state of a relay output.\n"
"\n"
":param in:  relayPortHandle the relay handle\n"
":param in:  on              true for on, false for off\n"
":param out: status         Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("getRelay", [](HAL_RelayHandle relayPortHandle) {
                    int32_t status;
          auto __ret =::HAL_GetRelay(std::move(relayPortHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("relayPortHandle"), release_gil(), py::doc(
    "Gets the current state of the relay channel.\n"
"\n"
":param in:  relayPortHandle the relay handle\n"
":param out: status         Error status variable. 0 on success.\n"
"\n"
":returns: true for on, false for off")
  )
  
  ;



}

}; // struct rpybuild_Relay_initializer

static std::unique_ptr<rpybuild_Relay_initializer> cls;

void begin_init_Relay(py::module &m) {
  cls = std::make_unique<rpybuild_Relay_initializer>(m);
}

void finish_init_Relay() {
  cls->finish();
  cls.reset();
}