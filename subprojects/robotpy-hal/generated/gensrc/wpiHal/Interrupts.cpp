
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <hal/Interrupts.h>
















#include <type_traits>




struct rpybuild_Interrupts_initializer {













  py::module &m;

  
  rpybuild_Interrupts_initializer(py::module &m) :

  

  

  

  

    m(m)
  {
    
    

    
  }

void finish() {







m
  .
def
("initializeInterrupts", []() {
                    int32_t status;
          auto __ret =::HAL_InitializeInterrupts(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Initializes an interrupt.\n"
"\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: the created interrupt handle")
  )
  
  ;
m
  .
def
("cleanInterrupts", &::HAL_CleanInterrupts,
      py::arg("interruptHandle"), release_gil(), py::doc(
    "Frees an interrupt.\n"
"\n"
":param interruptHandle: the interrupt handle")
  )
  
  ;
m
  .
def
("waitForInterrupt", [](HAL_InterruptHandle interruptHandle, double timeout, HAL_Bool ignorePrevious) {
                    int32_t status;
          auto __ret =::HAL_WaitForInterrupt(std::move(interruptHandle), std::move(timeout), std::move(ignorePrevious), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("interruptHandle"), py::arg("timeout"), py::arg("ignorePrevious"), release_gil(), py::doc(
    "Waits for the defined interrupt to occur.\n"
"\n"
":param in:  interruptHandle the interrupt handle\n"
":param in:  timeout         timeout in seconds\n"
":param in:  ignorePrevious  if true, ignore interrupts that happened before\n"
"            waitForInterrupt was called\n"
":param out: status         Error status variable. 0 on success.\n"
"\n"
":returns: the mask of interrupts that fired")
  )
  
  ;
m
  .
def
("waitForMultipleInterrupts", [](HAL_InterruptHandle interruptHandle, int64_t mask, double timeout, HAL_Bool ignorePrevious) {
                    int32_t status;
          auto __ret =::HAL_WaitForMultipleInterrupts(std::move(interruptHandle), std::move(mask), std::move(timeout), std::move(ignorePrevious), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("interruptHandle"), py::arg("mask"), py::arg("timeout"), py::arg("ignorePrevious"), release_gil(), py::doc(
    "Waits for any interrupt covered by the mask to occur.\n"
"\n"
":param in:  interruptHandle the interrupt handle to use for the context\n"
":param in:  mask            the mask of interrupts to wait for\n"
":param in:  timeout         timeout in seconds\n"
":param in:  ignorePrevious  if true, ignore interrupts that happened before\n"
"            waitForInterrupt was called\n"
":param out: status         Error status variable. 0 on success.\n"
"\n"
":returns: the mask of interrupts that fired")
  )
  
  ;
m
  .
def
("readInterruptRisingTimestamp", [](HAL_InterruptHandle interruptHandle) {
                    int32_t status;
          auto __ret =::HAL_ReadInterruptRisingTimestamp(std::move(interruptHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("interruptHandle"), release_gil(), py::doc(
    "Returns the timestamp for the rising interrupt that occurred most recently.\n"
"\n"
"This is in the same time domain as HAL_GetFPGATime().  It only contains the\n"
"bottom 32 bits of the timestamp.  If your robot has been running for over 1\n"
"hour, you will need to fill in the upper 32 bits yourself.\n"
"\n"
":param in:  interruptHandle the interrupt handle\n"
":param out: status         Error status variable. 0 on success.\n"
"\n"
":returns: timestamp in microseconds since FPGA Initialization")
  )
  
  ;
m
  .
def
("readInterruptFallingTimestamp", [](HAL_InterruptHandle interruptHandle) {
                    int32_t status;
          auto __ret =::HAL_ReadInterruptFallingTimestamp(std::move(interruptHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("interruptHandle"), release_gil(), py::doc(
    "Returns the timestamp for the falling interrupt that occurred most recently.\n"
"\n"
"This is in the same time domain as HAL_GetFPGATime().  It only contains the\n"
"bottom 32 bits of the timestamp.  If your robot has been running for over 1\n"
"hour, you will need to fill in the upper 32 bits yourself.\n"
"\n"
":param in:  interruptHandle the interrupt handle\n"
":param out: status         Error status variable. 0 on success.\n"
"\n"
":returns: timestamp in microseconds since FPGA Initialization")
  )
  
  ;
m
  .
def
("requestInterrupts", [](HAL_InterruptHandle interruptHandle, HAL_Handle digitalSourceHandle, HAL_AnalogTriggerType analogTriggerType) {
                    int32_t status;
          ::HAL_RequestInterrupts(std::move(interruptHandle), std::move(digitalSourceHandle), std::move(analogTriggerType), &status);
          return status;
        },
      py::arg("interruptHandle"), py::arg("digitalSourceHandle"), py::arg("analogTriggerType"), release_gil(), py::doc(
    "Requests interrupts on a specific digital source.\n"
"\n"
":param in:  interruptHandle     the interrupt handle\n"
":param in:  digitalSourceHandle the digital source handle (either a\n"
"            HAL_AnalogTriggerHandle or a\n"
"            HAL_DigitalHandle)\n"
":param in:  analogTriggerType   the trigger type if the source is an\n"
"            AnalogTrigger\n"
":param out: status             Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setInterruptUpSourceEdge", [](HAL_InterruptHandle interruptHandle, HAL_Bool risingEdge, HAL_Bool fallingEdge) {
                    int32_t status;
          ::HAL_SetInterruptUpSourceEdge(std::move(interruptHandle), std::move(risingEdge), std::move(fallingEdge), &status);
          return status;
        },
      py::arg("interruptHandle"), py::arg("risingEdge"), py::arg("fallingEdge"), release_gil(), py::doc(
    "Sets the edges to trigger the interrupt on.\n"
"\n"
"Note that both edges triggered is a valid configuration.\n"
"\n"
":param in:  interruptHandle the interrupt handle\n"
":param in:  risingEdge      true for triggering on rising edge\n"
":param in:  fallingEdge     true for triggering on falling edge\n"
":param out: status         Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("releaseWaitingInterrupt", [](HAL_InterruptHandle interruptHandle) {
                    int32_t status;
          ::HAL_ReleaseWaitingInterrupt(std::move(interruptHandle), &status);
          return status;
        },
      py::arg("interruptHandle"), release_gil(), py::doc(
    "Releases a waiting interrupt.\n"
"\n"
"This will release both rising and falling waiters.\n"
"\n"
":param in:  interruptHandle the interrupt handle to release\n"
":param out: status         Error status variable. 0 on success.")
  )
  
  ;



}

}; // struct rpybuild_Interrupts_initializer

static std::unique_ptr<rpybuild_Interrupts_initializer> cls;

void begin_init_Interrupts(py::module &m) {
  cls = std::make_unique<rpybuild_Interrupts_initializer>(m);
}

void finish_init_Interrupts() {
  cls->finish();
  cls.reset();
}