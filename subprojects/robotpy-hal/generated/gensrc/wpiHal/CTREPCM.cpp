
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <hal/CTREPCM.h>
















#include <type_traits>




struct rpybuild_CTREPCM_initializer {













  py::module &m;

  
  rpybuild_CTREPCM_initializer(py::module &m) :

  

  

  

  

    m(m)
  {
    
    

    
  }

void finish() {







m
  .
def
("initializeCTREPCM", [](int32_t module, const char* allocationLocation) {
                    int32_t status;
          auto __ret =::HAL_InitializeCTREPCM(std::move(module), allocationLocation, &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("module"), py::arg("allocationLocation"), release_gil(), py::doc(
    "Initializes a PCM.\n"
"\n"
":param in:  module             the CAN ID to initialize\n"
":param in:  allocationLocation the location where the allocation is occurring\n"
"            (can be null)\n"
":param out: status            Error status variable. 0 on success.\n"
"\n"
":returns: the created PH handle")
  )
  
  ;
m
  .
def
("freeCTREPCM", &::HAL_FreeCTREPCM,
      py::arg("handle"), release_gil(), py::doc(
    "Frees a PCM handle.\n"
"\n"
":param in: handle the PCMhandle")
  )
  
  ;
m
  .
def
("checkCTREPCMSolenoidChannel", &::HAL_CheckCTREPCMSolenoidChannel,
      py::arg("channel"), release_gil(), py::doc(
    "Checks if a solenoid channel number is valid.\n"
"\n"
":param in: channel the channel to check\n"
"\n"
":returns: true if the channel is valid, otherwise false")
  )
  
  ;
m
  .
def
("getCTREPCMCompressor", [](HAL_CTREPCMHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetCTREPCMCompressor(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Get whether compressor is turned on.\n"
"\n"
":param in:  handle  the PCM handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: true if the compressor is turned on")
  )
  
  ;
m
  .
def
("setCTREPCMClosedLoopControl", [](HAL_CTREPCMHandle handle, HAL_Bool enabled) {
                    int32_t status;
          ::HAL_SetCTREPCMClosedLoopControl(std::move(handle), std::move(enabled), &status);
          return status;
        },
      py::arg("handle"), py::arg("enabled"), release_gil(), py::doc(
    "Enables the compressor closed loop control using the digital pressure switch.\n"
"The compressor will turn on when the pressure switch indicates that the\n"
"system is not full, and will turn off when the pressure switch indicates that\n"
"the system is full.\n"
"\n"
":param in:  handle  the PCM handle\n"
":param in:  enabled true to enable closed loop control\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("getCTREPCMClosedLoopControl", [](HAL_CTREPCMHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetCTREPCMClosedLoopControl(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Get whether the PCM closed loop control is enabled.\n"
"\n"
":param in:  handle  the PCM handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: True if closed loop control is enabled, otherwise false.")
  )
  
  ;
m
  .
def
("getCTREPCMPressureSwitch", [](HAL_CTREPCMHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetCTREPCMPressureSwitch(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Returns the state of the pressure switch.\n"
"\n"
":param in:  handle  the PCM handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: True if pressure switch indicates that the system is full,\n"
"          otherwise false.")
  )
  
  ;
m
  .
def
("getCTREPCMCompressorCurrent", [](HAL_CTREPCMHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetCTREPCMCompressorCurrent(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Returns the current drawn by the compressor.\n"
"\n"
":param in:  handle  the PCM handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: The current drawn by the compressor in amps.")
  )
  
  ;
m
  .
def
("getCTREPCMCompressorCurrentTooHighFault", [](HAL_CTREPCMHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetCTREPCMCompressorCurrentTooHighFault(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Return whether the compressor current is currently too high.\n"
"\n"
":param in:  handle  the PCM handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: True if the compressor current is too high, otherwise false.\n"
"          @see HAL_GetCTREPCMCompressorShortedStickyFault")
  )
  
  ;
m
  .
def
("getCTREPCMCompressorCurrentTooHighStickyFault", [](HAL_CTREPCMHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetCTREPCMCompressorCurrentTooHighStickyFault(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Returns whether the compressor current has been too high since sticky\n"
"faults were last cleared. This fault is persistent and can be cleared by\n"
"HAL_ClearAllCTREPCMStickyFaults()\n"
"\n"
":param in:  handle  the PCM handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: True if the compressor current has been too high since sticky\n"
"          faults were last cleared.\n"
"          @see HAL_GetCTREPCMCompressorCurrentTooHighFault()")
  )
  
  ;
m
  .
def
("getCTREPCMCompressorShortedStickyFault", [](HAL_CTREPCMHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetCTREPCMCompressorShortedStickyFault(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Returns whether the compressor has been shorted since sticky faults were\n"
"last cleared. This fault is persistent and can be cleared by\n"
"HAL_ClearAllCTREPCMStickyFaults()\n"
"\n"
":param in:  handle  the PCM handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: True if the compressor has been shorted since sticky faults were\n"
"          last cleared, otherwise false.\n"
"          @see HAL_GetCTREPCMCompressorShortedFault()")
  )
  
  ;
m
  .
def
("getCTREPCMCompressorShortedFault", [](HAL_CTREPCMHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetCTREPCMCompressorShortedFault(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Returns whether the compressor is currently shorted.\n"
"\n"
":param in:  handle  the PCM handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: True if the compressor is currently shorted, otherwise false.\n"
"          @see HAL_GetCTREPCMCompressorShortedStickyFault")
  )
  
  ;
m
  .
def
("getCTREPCMCompressorNotConnectedStickyFault", [](HAL_CTREPCMHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetCTREPCMCompressorNotConnectedStickyFault(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Returns whether the compressor has been disconnected since sticky faults\n"
"were last cleared. This fault is persistent and can be cleared by\n"
"HAL_ClearAllCTREPCMStickyFaults()\n"
"\n"
":param in:  handle  the PCM handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: True if the compressor has been disconnected since sticky faults\n"
"          were last cleared, otherwise false.\n"
"          @see HAL_GetCTREPCMCompressorShortedFault()")
  )
  
  ;
m
  .
def
("getCTREPCMCompressorNotConnectedFault", [](HAL_CTREPCMHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetCTREPCMCompressorNotConnectedFault(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Returns whether the compressor is currently disconnected.\n"
"\n"
":param in:  handle  the PCM handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: True if compressor is currently disconnected, otherwise false.\n"
"          @see HAL_GetCTREPCMCompressorNotConnectedStickyFault()")
  )
  
  ;
m
  .
def
("getCTREPCMSolenoids", [](HAL_CTREPCMHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetCTREPCMSolenoids(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Gets a bitmask of solenoid values.\n"
"\n"
":param in:  handle  the PCM handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: Bitmask containing the state of the solenoids. The LSB represents\n"
"          solenoid 0.")
  )
  
  ;
m
  .
def
("setCTREPCMSolenoids", [](HAL_CTREPCMHandle handle, int32_t mask, int32_t values) {
                    int32_t status;
          ::HAL_SetCTREPCMSolenoids(std::move(handle), std::move(mask), std::move(values), &status);
          return status;
        },
      py::arg("handle"), py::arg("mask"), py::arg("values"), release_gil(), py::doc(
    "Sets solenoids on a pneumatics module.\n"
"\n"
":param in:  handle  the PCM handle\n"
":param in:  mask Bitmask indicating which solenoids to set. The LSB represents\n"
"            solenoid 0.\n"
":param in:  values Bitmask indicating the desired states of the solenoids. The\n"
"            LSB represents solenoid 0.\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("getCTREPCMSolenoidDisabledList", [](HAL_CTREPCMHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetCTREPCMSolenoidDisabledList(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Get a bitmask of disabled solenoids.\n"
"\n"
":param in:  handle  the PCM handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: Bitmask indicating disabled solenoids. The LSB represents solenoid 0.")
  )
  
  ;
m
  .
def
("getCTREPCMSolenoidVoltageStickyFault", [](HAL_CTREPCMHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetCTREPCMSolenoidVoltageStickyFault(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Returns whether the solenoid has reported a voltage fault since sticky faults\n"
"were last cleared. This fault is persistent and can be cleared by\n"
"HAL_ClearAllCTREPCMStickyFaults()\n"
"\n"
":param in:  handle  the PCM handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: True if solenoid is reporting a fault, otherwise false.\n"
"          @see HAL_GetCTREPCMSolenoidVoltageFault()")
  )
  
  ;
m
  .
def
("getCTREPCMSolenoidVoltageFault", [](HAL_CTREPCMHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetCTREPCMSolenoidVoltageFault(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Returns whether the solenoid is currently reporting a voltage fault.\n"
"\n"
":param in:  handle  the PCM handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: True if solenoid is reporting a fault, otherwise false.\n"
"          @see HAL_GetCTREPCMSolenoidVoltageStickyFault()")
  )
  
  ;
m
  .
def
("clearAllCTREPCMStickyFaults", [](HAL_CTREPCMHandle handle) {
                    int32_t status;
          ::HAL_ClearAllCTREPCMStickyFaults(std::move(handle), &status);
          return status;
        },
      py::arg("handle"), release_gil(), py::doc(
    "Clears all sticky faults on this device.\n"
"\n"
":param in:  handle  the PCM handle\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("fireCTREPCMOneShot", [](HAL_CTREPCMHandle handle, int32_t index) {
                    int32_t status;
          ::HAL_FireCTREPCMOneShot(std::move(handle), std::move(index), &status);
          return status;
        },
      py::arg("handle"), py::arg("index"), release_gil(), py::doc(
    "Fire a single solenoid shot.\n"
"\n"
":param in:  handle  the PCM handle\n"
":param in:  index solenoid index\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setCTREPCMOneShotDuration", [](HAL_CTREPCMHandle handle, int32_t index, int32_t durMs) {
                    int32_t status;
          ::HAL_SetCTREPCMOneShotDuration(std::move(handle), std::move(index), std::move(durMs), &status);
          return status;
        },
      py::arg("handle"), py::arg("index"), py::arg("durMs"), release_gil(), py::doc(
    "Set the duration for a single solenoid shot.\n"
"\n"
":param in:  handle  the PCM handle\n"
":param in:  index solenoid index\n"
":param in:  durMs shot duration in ms\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;



}

}; // struct rpybuild_CTREPCM_initializer

static std::unique_ptr<rpybuild_CTREPCM_initializer> cls;

void begin_init_CTREPCM(py::module &m) {
  cls = std::make_unique<rpybuild_CTREPCM_initializer>(m);
}

void finish_init_CTREPCM() {
  cls->finish();
  cls.reset();
}