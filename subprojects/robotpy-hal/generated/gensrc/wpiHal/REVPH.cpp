
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <hal/REVPH.h>
















#include <type_traits>




struct rpybuild_REVPH_initializer {


  

  


  

  


  

  


  

  







  
  py::enum_<::HAL_REVPHCompressorConfigType> enum1;






  py::class_<typename ::HAL_REVPHVersion> cls_HAL_REVPHVersion;

    

    
    
  py::class_<typename ::HAL_REVPHCompressorConfig> cls_HAL_REVPHCompressorConfig;

    

    
    
  py::class_<typename ::HAL_REVPHFaults> cls_HAL_REVPHFaults;

    

    
    
  py::class_<typename ::HAL_REVPHStickyFaults> cls_HAL_REVPHStickyFaults;

    

    
    

  py::module &m;

  
  rpybuild_REVPH_initializer(py::module &m) :

  

  
    enum1
  (m, "REVPHCompressorConfigType"
  ,
    "The compressor configuration type"),
  

  

  
    cls_HAL_REVPHVersion(m, "REVPHVersion"),

  

  
  
  
    cls_HAL_REVPHCompressorConfig(m, "REVPHCompressorConfig"),

  

  
  
  
    cls_HAL_REVPHFaults(m, "REVPHFaults"),

  

  
  
  
    cls_HAL_REVPHStickyFaults(m, "REVPHStickyFaults"),

  

  
  
  

    m(m)
  {
    
    
      enum1
  
    .value("kDisabled", ::HAL_REVPHCompressorConfigType::HAL_REVPHCompressorConfigType_kDisabled,
      "Disabled.")
  
    .value("kDigital", ::HAL_REVPHCompressorConfigType::HAL_REVPHCompressorConfigType_kDigital,
      "Digital.")
  
    .value("kAnalog", ::HAL_REVPHCompressorConfigType::HAL_REVPHCompressorConfigType_kAnalog,
      "Analog.")
  
    .value("kHybrid", ::HAL_REVPHCompressorConfigType::HAL_REVPHCompressorConfigType_kHybrid,
      "Hybrid.")
  ;

    

    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_HAL_REVPHVersion.doc() =
    "Storage for REV PH Version";

  cls_HAL_REVPHVersion
  
    .def(py::init<>(), release_gil())
  
    .def_readwrite("firmwareMajor", &::HAL_REVPHVersion::firmwareMajor, py::doc(
    "The firmware major version."))
  
    .def_readwrite("firmwareMinor", &::HAL_REVPHVersion::firmwareMinor, py::doc(
    "The firmware minor version."))
  
    .def_readwrite("firmwareFix", &::HAL_REVPHVersion::firmwareFix, py::doc(
    "The firmware fix version."))
  
    .def_readwrite("hardwareMinor", &::HAL_REVPHVersion::hardwareMinor, py::doc(
    "The hardware minor version."))
  
    .def_readwrite("hardwareMajor", &::HAL_REVPHVersion::hardwareMajor, py::doc(
    "The hardware major version."))
  
    .def_readwrite("uniqueId", &::HAL_REVPHVersion::uniqueId, py::doc(
    "The device's unique ID."))
  ;

  


  }

  {
  
  
  


  

  cls_HAL_REVPHCompressorConfig.doc() =
    "Storage for compressor config";

  cls_HAL_REVPHCompressorConfig
  
    .def(py::init<>(), release_gil())
  
    .def_readwrite("minAnalogVoltage", &::HAL_REVPHCompressorConfig::minAnalogVoltage)
  
    .def_readwrite("maxAnalogVoltage", &::HAL_REVPHCompressorConfig::maxAnalogVoltage)
  
    .def_readwrite("forceDisable", &::HAL_REVPHCompressorConfig::forceDisable)
  
    .def_readwrite("useDigital", &::HAL_REVPHCompressorConfig::useDigital)
  ;

  


  }

  {
  
  
  


  

  cls_HAL_REVPHFaults.doc() =
    "Storage for REV PH Faults";

  cls_HAL_REVPHFaults
  
    .def(py::init<>(), release_gil())
  
    .def_property("channel0Fault",  
        [](const ::HAL_REVPHFaults& inst) -> uint32_t { return inst.channel0Fault; },
        [](::HAL_REVPHFaults& inst, uint32_t v) {inst.channel0Fault = v; }, py::doc(
    "Fault on channel 0.")
    )
  
    .def_property("channel1Fault",  
        [](const ::HAL_REVPHFaults& inst) -> uint32_t { return inst.channel1Fault; },
        [](::HAL_REVPHFaults& inst, uint32_t v) {inst.channel1Fault = v; }, py::doc(
    "Fault on channel 1.")
    )
  
    .def_property("channel2Fault",  
        [](const ::HAL_REVPHFaults& inst) -> uint32_t { return inst.channel2Fault; },
        [](::HAL_REVPHFaults& inst, uint32_t v) {inst.channel2Fault = v; }, py::doc(
    "Fault on channel 2.")
    )
  
    .def_property("channel3Fault",  
        [](const ::HAL_REVPHFaults& inst) -> uint32_t { return inst.channel3Fault; },
        [](::HAL_REVPHFaults& inst, uint32_t v) {inst.channel3Fault = v; }, py::doc(
    "Fault on channel 3.")
    )
  
    .def_property("channel4Fault",  
        [](const ::HAL_REVPHFaults& inst) -> uint32_t { return inst.channel4Fault; },
        [](::HAL_REVPHFaults& inst, uint32_t v) {inst.channel4Fault = v; }, py::doc(
    "Fault on channel 4.")
    )
  
    .def_property("channel5Fault",  
        [](const ::HAL_REVPHFaults& inst) -> uint32_t { return inst.channel5Fault; },
        [](::HAL_REVPHFaults& inst, uint32_t v) {inst.channel5Fault = v; }, py::doc(
    "Fault on channel 5.")
    )
  
    .def_property("channel6Fault",  
        [](const ::HAL_REVPHFaults& inst) -> uint32_t { return inst.channel6Fault; },
        [](::HAL_REVPHFaults& inst, uint32_t v) {inst.channel6Fault = v; }, py::doc(
    "Fault on channel 6.")
    )
  
    .def_property("channel7Fault",  
        [](const ::HAL_REVPHFaults& inst) -> uint32_t { return inst.channel7Fault; },
        [](::HAL_REVPHFaults& inst, uint32_t v) {inst.channel7Fault = v; }, py::doc(
    "Fault on channel 7.")
    )
  
    .def_property("channel8Fault",  
        [](const ::HAL_REVPHFaults& inst) -> uint32_t { return inst.channel8Fault; },
        [](::HAL_REVPHFaults& inst, uint32_t v) {inst.channel8Fault = v; }, py::doc(
    "Fault on channel 8.")
    )
  
    .def_property("channel9Fault",  
        [](const ::HAL_REVPHFaults& inst) -> uint32_t { return inst.channel9Fault; },
        [](::HAL_REVPHFaults& inst, uint32_t v) {inst.channel9Fault = v; }, py::doc(
    "Fault on channel 9.")
    )
  
    .def_property("channel10Fault",  
        [](const ::HAL_REVPHFaults& inst) -> uint32_t { return inst.channel10Fault; },
        [](::HAL_REVPHFaults& inst, uint32_t v) {inst.channel10Fault = v; }, py::doc(
    "Fault on channel 10.")
    )
  
    .def_property("channel11Fault",  
        [](const ::HAL_REVPHFaults& inst) -> uint32_t { return inst.channel11Fault; },
        [](::HAL_REVPHFaults& inst, uint32_t v) {inst.channel11Fault = v; }, py::doc(
    "Fault on channel 11.")
    )
  
    .def_property("channel12Fault",  
        [](const ::HAL_REVPHFaults& inst) -> uint32_t { return inst.channel12Fault; },
        [](::HAL_REVPHFaults& inst, uint32_t v) {inst.channel12Fault = v; }, py::doc(
    "Fault on channel 12.")
    )
  
    .def_property("channel13Fault",  
        [](const ::HAL_REVPHFaults& inst) -> uint32_t { return inst.channel13Fault; },
        [](::HAL_REVPHFaults& inst, uint32_t v) {inst.channel13Fault = v; }, py::doc(
    "Fault on channel 13.")
    )
  
    .def_property("channel14Fault",  
        [](const ::HAL_REVPHFaults& inst) -> uint32_t { return inst.channel14Fault; },
        [](::HAL_REVPHFaults& inst, uint32_t v) {inst.channel14Fault = v; }, py::doc(
    "Fault on channel 14.")
    )
  
    .def_property("channel15Fault",  
        [](const ::HAL_REVPHFaults& inst) -> uint32_t { return inst.channel15Fault; },
        [](::HAL_REVPHFaults& inst, uint32_t v) {inst.channel15Fault = v; }, py::doc(
    "Fault on channel 15.")
    )
  
    .def_property("compressorOverCurrent",  
        [](const ::HAL_REVPHFaults& inst) -> uint32_t { return inst.compressorOverCurrent; },
        [](::HAL_REVPHFaults& inst, uint32_t v) {inst.compressorOverCurrent = v; }, py::doc(
    "An overcurrent event occurred on the compressor output.")
    )
  
    .def_property("compressorOpen",  
        [](const ::HAL_REVPHFaults& inst) -> uint32_t { return inst.compressorOpen; },
        [](::HAL_REVPHFaults& inst, uint32_t v) {inst.compressorOpen = v; }, py::doc(
    "The compressor output has an open circuit.")
    )
  
    .def_property("solenoidOverCurrent",  
        [](const ::HAL_REVPHFaults& inst) -> uint32_t { return inst.solenoidOverCurrent; },
        [](::HAL_REVPHFaults& inst, uint32_t v) {inst.solenoidOverCurrent = v; }, py::doc(
    "An overcurrent event occurred on a solenoid output.")
    )
  
    .def_property("brownout",  
        [](const ::HAL_REVPHFaults& inst) -> uint32_t { return inst.brownout; },
        [](::HAL_REVPHFaults& inst, uint32_t v) {inst.brownout = v; }, py::doc(
    "The input voltage is below the minimum voltage.")
    )
  
    .def_property("canWarning",  
        [](const ::HAL_REVPHFaults& inst) -> uint32_t { return inst.canWarning; },
        [](::HAL_REVPHFaults& inst, uint32_t v) {inst.canWarning = v; }, py::doc(
    "A warning was raised by the device's CAN controller.")
    )
  
    .def_property("hardwareFault",  
        [](const ::HAL_REVPHFaults& inst) -> uint32_t { return inst.hardwareFault; },
        [](::HAL_REVPHFaults& inst, uint32_t v) {inst.hardwareFault = v; }, py::doc(
    "The hardware on the device has malfunctioned.")
    )
  ;

  


  }

  {
  
  
  


  

  cls_HAL_REVPHStickyFaults.doc() =
    "Storage for REV PH Sticky Faults";

  cls_HAL_REVPHStickyFaults
  
    .def(py::init<>(), release_gil())
  
    .def_property("compressorOverCurrent",  
        [](const ::HAL_REVPHStickyFaults& inst) -> uint32_t { return inst.compressorOverCurrent; },
        [](::HAL_REVPHStickyFaults& inst, uint32_t v) {inst.compressorOverCurrent = v; }, py::doc(
    "An overcurrent event occurred on the compressor output.")
    )
  
    .def_property("compressorOpen",  
        [](const ::HAL_REVPHStickyFaults& inst) -> uint32_t { return inst.compressorOpen; },
        [](::HAL_REVPHStickyFaults& inst, uint32_t v) {inst.compressorOpen = v; }, py::doc(
    "The compressor output has an open circuit.")
    )
  
    .def_property("solenoidOverCurrent",  
        [](const ::HAL_REVPHStickyFaults& inst) -> uint32_t { return inst.solenoidOverCurrent; },
        [](::HAL_REVPHStickyFaults& inst, uint32_t v) {inst.solenoidOverCurrent = v; }, py::doc(
    "An overcurrent event occurred on a solenoid output.")
    )
  
    .def_property("brownout",  
        [](const ::HAL_REVPHStickyFaults& inst) -> uint32_t { return inst.brownout; },
        [](::HAL_REVPHStickyFaults& inst, uint32_t v) {inst.brownout = v; }, py::doc(
    "The input voltage is below the minimum voltage.")
    )
  
    .def_property("canWarning",  
        [](const ::HAL_REVPHStickyFaults& inst) -> uint32_t { return inst.canWarning; },
        [](::HAL_REVPHStickyFaults& inst, uint32_t v) {inst.canWarning = v; }, py::doc(
    "A warning was raised by the device's CAN controller.")
    )
  
    .def_property("canBusOff",  
        [](const ::HAL_REVPHStickyFaults& inst) -> uint32_t { return inst.canBusOff; },
        [](::HAL_REVPHStickyFaults& inst, uint32_t v) {inst.canBusOff = v; }, py::doc(
    "The device's CAN controller experienced a \"Bus Off\" event.")
    )
  
    .def_property("hardwareFault",  
        [](const ::HAL_REVPHStickyFaults& inst) -> uint32_t { return inst.hardwareFault; },
        [](::HAL_REVPHStickyFaults& inst, uint32_t v) {inst.hardwareFault = v; }, py::doc(
    "The hardware on the device has malfunctioned.")
    )
  
    .def_property("firmwareFault",  
        [](const ::HAL_REVPHStickyFaults& inst) -> uint32_t { return inst.firmwareFault; },
        [](::HAL_REVPHStickyFaults& inst, uint32_t v) {inst.firmwareFault = v; }, py::doc(
    "The firmware on the device has malfunctioned.")
    )
  
    .def_property("hasReset",  
        [](const ::HAL_REVPHStickyFaults& inst) -> uint32_t { return inst.hasReset; },
        [](::HAL_REVPHStickyFaults& inst, uint32_t v) {inst.hasReset = v; }, py::doc(
    "The device has rebooted.")
    )
  ;

  


  }



m
  .
def
("initializeREVPH", [](int32_t module, const char* allocationLocation) {
                    int32_t status;
          auto __ret =::HAL_InitializeREVPH(std::move(module), allocationLocation, &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("module"), py::arg("allocationLocation"), release_gil(), py::doc(
    "Initializes a PH.\n"
"\n"
":param in:  module             the CAN ID to initialize\n"
":param in:  allocationLocation the location where the allocation is occurring\n"
"            (can be null)\n"
":param out: status            Error status variable. 0 on success.\n"
"\n"
":returns: the created PH handle")
  )
  
  ;
m
  .
def
("freeREVPH", &::HAL_FreeREVPH,
      py::arg("handle"), release_gil(), py::doc(
    "Frees a PH handle.\n"
"\n"
":param in: handle the PH handle")
  )
  
  ;
m
  .
def
("checkREVPHSolenoidChannel", &::HAL_CheckREVPHSolenoidChannel,
      py::arg("channel"), release_gil(), py::doc(
    "Checks if a solenoid channel number is valid.\n"
"\n"
":param in: channel the channel to check\n"
"\n"
":returns: true if the channel is valid, otherwise false")
  )
  
  ;
m
  .
def
("checkREVPHModuleNumber", &::HAL_CheckREVPHModuleNumber,
      py::arg("module"), release_gil(), py::doc(
    "Checks if a PH module (CAN ID) is valid.\n"
"\n"
":param in: module the module to check\n"
"\n"
":returns: true if the module is valid, otherwise false")
  )
  
  ;
m
  .
def
("getREVPHCompressor", [](HAL_REVPHHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetREVPHCompressor(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Get whether compressor is turned on.\n"
"\n"
":param in:  handle  the PH handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: true if the compressor is turned on")
  )
  
  ;
m
  .
def
("setREVPHCompressorConfig", [](HAL_REVPHHandle handle, const HAL_REVPHCompressorConfig* config) {
                    int32_t status;
          ::HAL_SetREVPHCompressorConfig(std::move(handle), config, &status);
          return status;
        },
      py::arg("handle"), py::arg("config"), release_gil(), py::doc(
    "Send compressor configuration to the PH.\n"
"\n"
":param in:  handle  the PH handle\n"
":param in:  config  compressor configuration\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setREVPHClosedLoopControlDisabled", [](HAL_REVPHHandle handle) {
                    int32_t status;
          ::HAL_SetREVPHClosedLoopControlDisabled(std::move(handle), &status);
          return status;
        },
      py::arg("handle"), release_gil(), py::doc(
    "Disable Compressor.\n"
"\n"
":param in:  handle  the PH handle\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setREVPHClosedLoopControlDigital", [](HAL_REVPHHandle handle) {
                    int32_t status;
          ::HAL_SetREVPHClosedLoopControlDigital(std::move(handle), &status);
          return status;
        },
      py::arg("handle"), release_gil(), py::doc(
    "Enables the compressor in digital mode using the digital pressure switch. The\n"
"compressor will turn on when the pressure switch indicates that the system is\n"
"not full, and will turn off when the pressure switch indicates that the\n"
"system is full.\n"
"\n"
":param in:  handle  the PH handle\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setREVPHClosedLoopControlAnalog", [](HAL_REVPHHandle handle, double minAnalogVoltage, double maxAnalogVoltage) {
                    int32_t status;
          ::HAL_SetREVPHClosedLoopControlAnalog(std::move(handle), std::move(minAnalogVoltage), std::move(maxAnalogVoltage), &status);
          return status;
        },
      py::arg("handle"), py::arg("minAnalogVoltage"), py::arg("maxAnalogVoltage"), release_gil(), py::doc(
    "Enables the compressor in analog mode. This mode uses an analog\n"
"pressure sensor connected to analog channel 0 to cycle the compressor. The\n"
"compressor will turn on when the pressure drops below minAnalogVoltage and\n"
"will turn off when the pressure reaches maxAnalogVoltage. This mode is only\n"
"supported by the REV PH with the REV Analog Pressure Sensor connected to\n"
"analog channel 0.\n"
"\n"
":param in:  handle  the PH handle\n"
":param in:  minAnalogVoltage The compressor will turn on when the analog\n"
"            pressure sensor voltage drops below this value\n"
":param in:  maxAnalogVoltage The compressor will turn off when the analog\n"
"            pressure sensor reaches this value.\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setREVPHClosedLoopControlHybrid", [](HAL_REVPHHandle handle, double minAnalogVoltage, double maxAnalogVoltage) {
                    int32_t status;
          ::HAL_SetREVPHClosedLoopControlHybrid(std::move(handle), std::move(minAnalogVoltage), std::move(maxAnalogVoltage), &status);
          return status;
        },
      py::arg("handle"), py::arg("minAnalogVoltage"), py::arg("maxAnalogVoltage"), release_gil(), py::doc(
    "Enables the compressor in hybrid mode. This mode uses both a digital\n"
"pressure switch and an analog pressure sensor connected to analog channel 0\n"
"to cycle the compressor.\n"
"\n"
"The compressor will turn on when \\a both:\n"
"\n"
"- The digital pressure switch indicates the system is not full AND\n"
"- The analog pressure sensor indicates that the pressure in the system is\n"
"below the specified minimum pressure.\n"
"\n"
"The compressor will turn off when \\a either:\n"
"\n"
"- The digital pressure switch is disconnected or indicates that the system\n"
"is full OR\n"
"- The pressure detected by the analog sensor is greater than the specified\n"
"maximum pressure.\n"
"\n"
":param in:  handle  the PH handle\n"
":param in:  minAnalogVoltage The compressor will turn on when the analog\n"
"            pressure sensor voltage drops below this value and the pressure switch\n"
"            indicates that the system is not full.\n"
":param in:  maxAnalogVoltage The compressor will turn off when the analog\n"
"            pressure sensor reaches this value or the pressure switch is disconnected or\n"
"            indicates that the system is full.\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("getREVPHCompressorConfig", [](HAL_REVPHHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetREVPHCompressorConfig(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Get compressor configuration from the PH.\n"
"\n"
":param in:  handle  the PH handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: compressor configuration")
  )
  
  ;
m
  .
def
("getREVPHPressureSwitch", [](HAL_REVPHHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetREVPHPressureSwitch(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Returns the state of the digital pressure switch.\n"
"\n"
":param in:  handle  the PH handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: True if pressure switch indicates that the system is full,\n"
"          otherwise false.")
  )
  
  ;
m
  .
def
("getREVPHCompressorCurrent", [](HAL_REVPHHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetREVPHCompressorCurrent(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Returns the current drawn by the compressor.\n"
"\n"
":param in:  handle  the PH handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: The current drawn by the compressor in amps.")
  )
  
  ;
m
  .
def
("getREVPHAnalogVoltage", [](HAL_REVPHHandle handle, int32_t channel) {
                    int32_t status;
          auto __ret =::HAL_GetREVPHAnalogVoltage(std::move(handle), std::move(channel), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), py::arg("channel"), release_gil(), py::doc(
    "Returns the raw voltage of the specified analog\n"
"input channel.\n"
"\n"
":param in:  handle  the PH handle\n"
":param in:  channel The analog input channel to read voltage from.\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: The voltage of the specified analog input channel in volts.")
  )
  
  ;
m
  .
def
("getREVPHVoltage", [](HAL_REVPHHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetREVPHVoltage(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Returns the current input voltage for the PH.\n"
"\n"
":param in:  handle  the PH handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: The input voltage in volts.")
  )
  
  ;
m
  .
def
("getREVPH5VVoltage", [](HAL_REVPHHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetREVPH5VVoltage(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Returns the current voltage of the regulated 5v supply.\n"
"\n"
":param in:  handle  the PH handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: The current voltage of the 5v supply in volts.")
  )
  
  ;
m
  .
def
("getREVPHSolenoidCurrent", [](HAL_REVPHHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetREVPHSolenoidCurrent(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Returns the total current drawn by all solenoids.\n"
"\n"
":param in:  handle  the PH handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: Total current drawn by all solenoids in amps.")
  )
  
  ;
m
  .
def
("getREVPHSolenoidVoltage", [](HAL_REVPHHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetREVPHSolenoidVoltage(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Returns the current voltage of the solenoid power supply.\n"
"\n"
":param in:  handle  the PH handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: The current voltage of the solenoid power supply in volts.")
  )
  
  ;
m
  .
def
("getREVPHVersion", [](HAL_REVPHHandle handle, HAL_REVPHVersion* version) {
                    int32_t status;
          ::HAL_GetREVPHVersion(std::move(handle), version, &status);
          return status;
        },
      py::arg("handle"), py::arg("version"), release_gil(), py::doc(
    "Returns the hardware and firmware versions of the PH.\n"
"\n"
":param in:  handle  the PH handle\n"
":param out: version The hardware and firmware versions.\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("getREVPHSolenoids", [](HAL_REVPHHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetREVPHSolenoids(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Gets a bitmask of solenoid values.\n"
"\n"
":param in:  handle  the PH handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: Bitmask containing the state of the solenoids. The LSB represents\n"
"          solenoid 0.")
  )
  
  ;
m
  .
def
("setREVPHSolenoids", [](HAL_REVPHHandle handle, int32_t mask, int32_t values) {
                    int32_t status;
          ::HAL_SetREVPHSolenoids(std::move(handle), std::move(mask), std::move(values), &status);
          return status;
        },
      py::arg("handle"), py::arg("mask"), py::arg("values"), release_gil(), py::doc(
    "Sets solenoids on a PH.\n"
"\n"
":param in:  handle  the PH handle\n"
":param in:  mask Bitmask indicating which solenoids to set. The LSB represents\n"
"            solenoid 0.\n"
":param in:  values Bitmask indicating the desired states of the solenoids. The\n"
"            LSB represents solenoid 0.\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("fireREVPHOneShot", [](HAL_REVPHHandle handle, int32_t index, int32_t durMs) {
                    int32_t status;
          ::HAL_FireREVPHOneShot(std::move(handle), std::move(index), std::move(durMs), &status);
          return status;
        },
      py::arg("handle"), py::arg("index"), py::arg("durMs"), release_gil(), py::doc(
    "Fire a single solenoid shot for the specified duration.\n"
"\n"
":param in:  handle  the PH handle\n"
":param in:  index solenoid index\n"
":param in:  durMs shot duration in ms\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("getREVPHFaults", [](HAL_REVPHHandle handle, HAL_REVPHFaults* faults) {
                    int32_t status;
          ::HAL_GetREVPHFaults(std::move(handle), faults, &status);
          return status;
        },
      py::arg("handle"), py::arg("faults"), release_gil(), py::doc(
    "Returns the faults currently active on the PH.\n"
"\n"
":param in:  handle  the PH handle\n"
":param out: faults The faults.\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("getREVPHStickyFaults", [](HAL_REVPHHandle handle, HAL_REVPHStickyFaults* stickyFaults) {
                    int32_t status;
          ::HAL_GetREVPHStickyFaults(std::move(handle), stickyFaults, &status);
          return status;
        },
      py::arg("handle"), py::arg("stickyFaults"), release_gil(), py::doc(
    "Returns the sticky faults currently active on this device.\n"
"\n"
":param in:  handle  the PH handle\n"
":param out: stickyFaults The sticky faults.\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("clearREVPHStickyFaults", [](HAL_REVPHHandle handle) {
                    int32_t status;
          ::HAL_ClearREVPHStickyFaults(std::move(handle), &status);
          return status;
        },
      py::arg("handle"), release_gil(), py::doc(
    "Clears the sticky faults.\n"
"\n"
":param in:  handle  the PH handle\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("getREVPHSolenoidDisabledList", [](HAL_REVPHHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetREVPHSolenoidDisabledList(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Get a bitmask of disabled solenoids.\n"
"\n"
":param in:  handle  the PH handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: Bitmask indicating disabled solenoids. The LSB represents solenoid 0.")
  )
  
  ;



}

}; // struct rpybuild_REVPH_initializer

static std::unique_ptr<rpybuild_REVPH_initializer> cls;

void begin_init_REVPH(py::module &m) {
  cls = std::make_unique<rpybuild_REVPH_initializer>(m);
}

void finish_init_REVPH() {
  cls->finish();
  cls.reset();
}