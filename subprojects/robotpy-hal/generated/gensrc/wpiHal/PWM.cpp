
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <hal/PWM.h>
















#include <type_traits>




struct rpybuild_PWM_initializer {













  py::module &m;

  
  rpybuild_PWM_initializer(py::module &m) :

  

  

  

  

    m(m)
  {
    
    

    
  }

void finish() {







m
  .
def
("initializePWMPort", [](HAL_PortHandle portHandle, const char* allocationLocation) {
                    int32_t status;
          auto __ret =::HAL_InitializePWMPort(std::move(portHandle), allocationLocation, &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("portHandle"), py::arg("allocationLocation"), release_gil(), py::doc(
    "Initializes a PWM port.\n"
"\n"
":param in:  portHandle the port to initialize\n"
":param in:  allocationLocation  the location where the allocation is occurring\n"
"            (can be null)\n"
":param out: status             Error status variable. 0 on success.\n"
"\n"
":returns: the created pwm handle")
  )
  
  ;
m
  .
def
("freePWMPort", &::HAL_FreePWMPort,
      py::arg("pwmPortHandle"), release_gil(), py::doc(
    "Frees a PWM port.\n"
"\n"
":param in: pwmPortHandle the pwm handle")
  )
  
  ;
m
  .
def
("checkPWMChannel", &::HAL_CheckPWMChannel,
      py::arg("channel"), release_gil(), py::doc(
    "Checks if a pwm channel is valid.\n"
"\n"
":param channel: the channel to check\n"
"\n"
":returns: true if the channel is valid, otherwise false")
  )
  
  ;
m
  .
def
("setPWMConfigMicroseconds", [](HAL_DigitalHandle pwmPortHandle, int32_t maxPwm, int32_t deadbandMaxPwm, int32_t centerPwm, int32_t deadbandMinPwm, int32_t minPwm) {
                    int32_t status;
          ::HAL_SetPWMConfigMicroseconds(std::move(pwmPortHandle), std::move(maxPwm), std::move(deadbandMaxPwm), std::move(centerPwm), std::move(deadbandMinPwm), std::move(minPwm), &status);
          return status;
        },
      py::arg("pwmPortHandle"), py::arg("maxPwm"), py::arg("deadbandMaxPwm"), py::arg("centerPwm"), py::arg("deadbandMinPwm"), py::arg("minPwm"), release_gil(), py::doc(
    "Sets the configuration settings for the PWM channel.\n"
"\n"
"All values are in microseconds.\n"
"\n"
":param in:  pwmPortHandle  the PWM handle\n"
":param in:  maxPwm         the maximum PWM value\n"
":param in:  deadbandMaxPwm the high range of the center deadband\n"
":param in:  centerPwm      the center PWM value\n"
":param in:  deadbandMinPwm the low range of the center deadband\n"
":param in:  minPwm         the minimum PWM value\n"
":param out: status        Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("getPWMConfigMicroseconds", [](HAL_DigitalHandle pwmPortHandle) {
                    int32_t maxPwm;
          int32_t deadbandMaxPwm;
          int32_t centerPwm;
          int32_t deadbandMinPwm;
          int32_t minPwm;
          int32_t status;
          ::HAL_GetPWMConfigMicroseconds(std::move(pwmPortHandle), &maxPwm, &deadbandMaxPwm, &centerPwm, &deadbandMinPwm, &minPwm, &status);
          return std::make_tuple(maxPwm,deadbandMaxPwm,centerPwm,deadbandMinPwm,minPwm,status);
        },
      py::arg("pwmPortHandle"), release_gil(), py::doc(
    "Gets the pwm configuration settings for the PWM channel.\n"
"\n"
"Values are in microseconds.\n"
"\n"
":param in:  pwmPortHandle  the PWM handle\n"
":param in:  maxPwm         the maximum PWM value\n"
":param in:  deadbandMaxPwm the high range of the center deadband\n"
":param in:  centerPwm      the center PWM value\n"
":param in:  deadbandMinPwm the low range of the center deadband\n"
":param in:  minPwm         the minimum PWM value\n"
":param out: status        Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setPWMEliminateDeadband", [](HAL_DigitalHandle pwmPortHandle, HAL_Bool eliminateDeadband) {
                    int32_t status;
          ::HAL_SetPWMEliminateDeadband(std::move(pwmPortHandle), std::move(eliminateDeadband), &status);
          return status;
        },
      py::arg("pwmPortHandle"), py::arg("eliminateDeadband"), release_gil(), py::doc(
    "Sets if the FPGA should output the center value if the input value is within\n"
"the deadband.\n"
"\n"
":param in:  pwmPortHandle     the PWM handle\n"
":param in:  eliminateDeadband true to eliminate deadband, otherwise false\n"
":param out: status           Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("getPWMEliminateDeadband", [](HAL_DigitalHandle pwmPortHandle) {
                    int32_t status;
          auto __ret =::HAL_GetPWMEliminateDeadband(std::move(pwmPortHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("pwmPortHandle"), release_gil(), py::doc(
    "Gets the current eliminate deadband value.\n"
"\n"
":param in:  pwmPortHandle the PWM handle\n"
":param out: status       Error status variable. 0 on success.\n"
"\n"
":returns: true if set, otherwise false")
  )
  
  ;
m
  .
def
("setPWMPulseTimeMicroseconds", [](HAL_DigitalHandle pwmPortHandle, int32_t microsecondPulseTime) {
                    int32_t status;
          ::HAL_SetPWMPulseTimeMicroseconds(std::move(pwmPortHandle), std::move(microsecondPulseTime), &status);
          return status;
        },
      py::arg("pwmPortHandle"), py::arg("microsecondPulseTime"), release_gil(), py::doc(
    "Sets a PWM channel to the desired pulse width in microseconds.\n"
"\n"
":param in:  pwmPortHandle the PWM handle\n"
":param in:  microsecondPulseTime  the PWM value to set\n"
":param out: status       Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setPWMSpeed", [](HAL_DigitalHandle pwmPortHandle, double speed) {
                    int32_t status;
          ::HAL_SetPWMSpeed(std::move(pwmPortHandle), std::move(speed), &status);
          return status;
        },
      py::arg("pwmPortHandle"), py::arg("speed"), release_gil(), py::doc(
    "Sets a PWM channel to the desired scaled value.\n"
"\n"
"The values range from -1 to 1 and the period is controlled by the PWM Period\n"
"and MinHigh registers.\n"
"\n"
":param in:  pwmPortHandle the PWM handle\n"
":param in:  speed         the scaled PWM value to set\n"
":param out: status       Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setPWMPosition", [](HAL_DigitalHandle pwmPortHandle, double position) {
                    int32_t status;
          ::HAL_SetPWMPosition(std::move(pwmPortHandle), std::move(position), &status);
          return status;
        },
      py::arg("pwmPortHandle"), py::arg("position"), release_gil(), py::doc(
    "Sets a PWM channel to the desired position value.\n"
"\n"
"The values range from 0 to 1 and the period is controlled by the PWM Period\n"
"and MinHigh registers.\n"
"\n"
":param in:  pwmPortHandle the PWM handle\n"
":param in:  position      the positional PWM value to set\n"
":param out: status       Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setPWMDisabled", [](HAL_DigitalHandle pwmPortHandle) {
                    int32_t status;
          ::HAL_SetPWMDisabled(std::move(pwmPortHandle), &status);
          return status;
        },
      py::arg("pwmPortHandle"), release_gil(), py::doc(
    "Sets a PWM channel to be disabled.\n"
"\n"
"The channel is disabled until the next time it is set. Note this is different\n"
"from just setting a 0 speed, as this will actively stop all signaling on the\n"
"channel.\n"
"\n"
":param in:  pwmPortHandle the PWM handle.\n"
":param out: status       Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("getPWMPulseTimeMicroseconds", [](HAL_DigitalHandle pwmPortHandle) {
                    int32_t status;
          auto __ret =::HAL_GetPWMPulseTimeMicroseconds(std::move(pwmPortHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("pwmPortHandle"), release_gil(), py::doc(
    "Gets the current microsecond pulse time from a PWM channel.\n"
"\n"
":param in:  pwmPortHandle the PWM handle\n"
":param out: status       Error status variable. 0 on success.\n"
"\n"
":returns: the current PWM microsecond pulse time")
  )
  
  ;
m
  .
def
("getPWMSpeed", [](HAL_DigitalHandle pwmPortHandle) {
                    int32_t status;
          auto __ret =::HAL_GetPWMSpeed(std::move(pwmPortHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("pwmPortHandle"), release_gil(), py::doc(
    "Gets a scaled value from a PWM channel.\n"
"\n"
"The values range from -1 to 1.\n"
"\n"
":param in:  pwmPortHandle the PWM handle\n"
":param out: status       Error status variable. 0 on success.\n"
"\n"
":returns: the current speed PWM value")
  )
  
  ;
m
  .
def
("getPWMPosition", [](HAL_DigitalHandle pwmPortHandle) {
                    int32_t status;
          auto __ret =::HAL_GetPWMPosition(std::move(pwmPortHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("pwmPortHandle"), release_gil(), py::doc(
    "Gets a position value from a PWM channel.\n"
"\n"
"The values range from 0 to 1.\n"
"\n"
":param in:  pwmPortHandle the PWM handle\n"
":param out: status       Error status variable. 0 on success.\n"
"\n"
":returns: the current positional PWM value")
  )
  
  ;
m
  .
def
("latchPWMZero", [](HAL_DigitalHandle pwmPortHandle) {
                    int32_t status;
          ::HAL_LatchPWMZero(std::move(pwmPortHandle), &status);
          return status;
        },
      py::arg("pwmPortHandle"), release_gil(), py::doc(
    "Forces a PWM signal to go to 0 temporarily.\n"
"\n"
":param in:  pwmPortHandle the PWM handle.\n"
":param out: status       Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setPWMPeriodScale", [](HAL_DigitalHandle pwmPortHandle, int32_t squelchMask) {
                    int32_t status;
          ::HAL_SetPWMPeriodScale(std::move(pwmPortHandle), std::move(squelchMask), &status);
          return status;
        },
      py::arg("pwmPortHandle"), py::arg("squelchMask"), release_gil(), py::doc(
    "Sets how how often the PWM signal is squelched, thus scaling the period.\n"
"\n"
":param in:  pwmPortHandle the PWM handle.\n"
":param in:  squelchMask   the 2-bit mask of outputs to squelch\n"
":param out: status       Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setPWMAlwaysHighMode", [](HAL_DigitalHandle pwmPortHandle) {
                    int32_t status;
          ::HAL_SetPWMAlwaysHighMode(std::move(pwmPortHandle), &status);
          return status;
        },
      py::arg("pwmPortHandle"), release_gil(), py::doc(
    "Sets the PWM output to be a continuous high signal while enabled.\n"
"\n"
":param in:  pwmPortHandle the PWM handle.\n"
":param out: status       Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("getPWMLoopTiming", []() {
                    int32_t status;
          auto __ret =::HAL_GetPWMLoopTiming(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Gets the loop timing of the PWM system.\n"
"\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: the loop time in clock ticks")
  )
  
  ;
m
  .
def
("getPWMCycleStartTime", []() {
                    int32_t status;
          auto __ret =::HAL_GetPWMCycleStartTime(&status);
          return std::make_tuple(__ret,status);
        }, release_gil(), py::doc(
    "Gets the pwm starting cycle time.\n"
"\n"
"This time is relative to the FPGA time.\n"
"\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: the pwm cycle start time")
  )
  
  ;



}

}; // struct rpybuild_PWM_initializer

static std::unique_ptr<rpybuild_PWM_initializer> cls;

void begin_init_PWM(py::module &m) {
  cls = std::make_unique<rpybuild_PWM_initializer>(m);
}

void finish_init_PWM() {
  cls->finish();
  cls.reset();
}