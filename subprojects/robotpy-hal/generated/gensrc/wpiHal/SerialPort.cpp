
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <hal/SerialPort.h>
















#include <type_traits>




struct rpybuild_SerialPort_initializer {







  
  py::enum_<::HAL_SerialPort> enum1;







  py::module &m;

  
  rpybuild_SerialPort_initializer(py::module &m) :

  

  
    enum1
  (m, "SerialPort"
  ),
  

  

  

    m(m)
  {
    
    
      enum1
  
    .value("Onboard", ::HAL_SerialPort::HAL_SerialPort_Onboard)
  
    .value("MXP", ::HAL_SerialPort::HAL_SerialPort_MXP)
  
    .value("USB1", ::HAL_SerialPort::HAL_SerialPort_USB1)
  
    .value("USB2", ::HAL_SerialPort::HAL_SerialPort_USB2)
  ;

    

    
  }

void finish() {







m
  .
def
("initializeSerialPort", [](HAL_SerialPort port) {
                    int32_t status;
          auto __ret =::HAL_InitializeSerialPort(std::move(port), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("port"), release_gil(), py::doc(
    "Initializes a serial port.\n"
"\n"
"The channels are either the onboard RS232, the MXP UART, or 2 USB ports. The\n"
"top port is USB1, the bottom port is USB2.\n"
"\n"
":param in:  port the serial port to initialize\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: Serial Port Handle")
  )
  
  ;
m
  .
def
("initializeSerialPortDirect", [](HAL_SerialPort port, const char* portName) {
                    int32_t status;
          auto __ret =::HAL_InitializeSerialPortDirect(std::move(port), portName, &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("port"), py::arg("portName"), release_gil(), py::doc(
    "Initializes a serial port with a direct name.\n"
"\n"
"This name is the /dev name for a specific port.\n"
"Note these are not always consistent between roboRIO reboots.\n"
"\n"
":param in:  port     the serial port to initialize\n"
":param in:  portName the dev port name\n"
":param out: status  the error code, or 0 for success\n"
"\n"
":returns: Serial Port Handle")
  )
  
  ;
m
  .
def
("getSerialFD", [](HAL_SerialPortHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetSerialFD(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Gets the raw serial port file descriptor from a handle.\n"
"\n"
":param in:  handle the serial port handle\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: the raw port descriptor")
  )
  
  ;
m
  .
def
("setSerialBaudRate", [](HAL_SerialPortHandle handle, int32_t baud) {
                    int32_t status;
          ::HAL_SetSerialBaudRate(std::move(handle), std::move(baud), &status);
          return status;
        },
      py::arg("handle"), py::arg("baud"), release_gil(), py::doc(
    "Sets the baud rate of a serial port.\n"
"\n"
"Any value between 0 and 0xFFFFFFFF may be used. Default is 9600.\n"
"\n"
":param in:  handle  the serial port handle\n"
":param in:  baud    the baud rate to set\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("setSerialDataBits", [](HAL_SerialPortHandle handle, int32_t bits) {
                    int32_t status;
          ::HAL_SetSerialDataBits(std::move(handle), std::move(bits), &status);
          return status;
        },
      py::arg("handle"), py::arg("bits"), release_gil(), py::doc(
    "Sets the number of data bits on a serial port.\n"
"\n"
"Defaults to 8.\n"
"\n"
":param in:  handle  the serial port handle\n"
":param in:  bits    the number of data bits (5-8)\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("setSerialParity", [](HAL_SerialPortHandle handle, int32_t parity) {
                    int32_t status;
          ::HAL_SetSerialParity(std::move(handle), std::move(parity), &status);
          return status;
        },
      py::arg("handle"), py::arg("parity"), release_gil(), py::doc(
    "Sets the number of parity bits on a serial port.\n"
"\n"
"Valid values are:\n"
"0: None (default)\n"
"1: Odd\n"
"2: Even\n"
"3: Mark - Means exists and always 1\n"
"4: Space - Means exists and always 0\n"
"\n"
":param in:  handle  the serial port handle\n"
":param in:  parity  the parity bit mode (see remarks for valid values)\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("setSerialStopBits", [](HAL_SerialPortHandle handle, int32_t stopBits) {
                    int32_t status;
          ::HAL_SetSerialStopBits(std::move(handle), std::move(stopBits), &status);
          return status;
        },
      py::arg("handle"), py::arg("stopBits"), release_gil(), py::doc(
    "Sets the number of stop bits on a serial port.\n"
"\n"
"Valid values are:\n"
"10: One stop bit (default)\n"
"15: One and a half stop bits\n"
"20: Two stop bits\n"
"\n"
":param in:  handle    the serial port handle\n"
":param in:  stopBits  the stop bit value (see remarks for valid values)\n"
":param out: status   the error code, or 0 for success")
  )
  
  ;
m
  .
def
("setSerialWriteMode", [](HAL_SerialPortHandle handle, int32_t mode) {
                    int32_t status;
          ::HAL_SetSerialWriteMode(std::move(handle), std::move(mode), &status);
          return status;
        },
      py::arg("handle"), py::arg("mode"), release_gil(), py::doc(
    "Sets the write mode on a serial port.\n"
"\n"
"Valid values are:\n"
"1: Flush on access\n"
"2: Flush when full (default)\n"
"\n"
":param in:  handle  the serial port handle\n"
":param in:  mode    the mode to set (see remarks for valid values)\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("setSerialFlowControl", [](HAL_SerialPortHandle handle, int32_t flow) {
                    int32_t status;
          ::HAL_SetSerialFlowControl(std::move(handle), std::move(flow), &status);
          return status;
        },
      py::arg("handle"), py::arg("flow"), release_gil(), py::doc(
    "Sets the flow control mode of a serial port.\n"
"\n"
"Valid values are:\n"
"0: None (default)\n"
"1: XON-XOFF\n"
"2: RTS-CTS\n"
"3: DTR-DSR\n"
"\n"
":param in:  handle  the serial port handle\n"
":param in:  flow    the mode to set (see remarks for valid values)\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("setSerialTimeout", [](HAL_SerialPortHandle handle, double timeout) {
                    int32_t status;
          ::HAL_SetSerialTimeout(std::move(handle), std::move(timeout), &status);
          return status;
        },
      py::arg("handle"), py::arg("timeout"), release_gil(), py::doc(
    "Sets the minimum serial read timeout of a port.\n"
"\n"
":param in:  handle   the serial port handle\n"
":param in:  timeout  the timeout in milliseconds\n"
":param out: status  the error code, or 0 for success")
  )
  
  ;
m
  .
def
("enableSerialTermination", [](HAL_SerialPortHandle handle, char terminator) {
                    int32_t status;
          ::HAL_EnableSerialTermination(std::move(handle), std::move(terminator), &status);
          return status;
        },
      py::arg("handle"), py::arg("terminator"), release_gil(), py::doc(
    "Sets the termination character that terminates a read.\n"
"\n"
"By default this is disabled.\n"
"\n"
":param in:  handle      the serial port handle\n"
":param in:  terminator  the termination character to set\n"
":param out: status     the error code, or 0 for success")
  )
  
  ;
m
  .
def
("disableSerialTermination", [](HAL_SerialPortHandle handle) {
                    int32_t status;
          ::HAL_DisableSerialTermination(std::move(handle), &status);
          return status;
        },
      py::arg("handle"), release_gil(), py::doc(
    "Disables a termination character for reads.\n"
"\n"
":param in:  handle  the serial port handle\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("setSerialReadBufferSize", [](HAL_SerialPortHandle handle, int32_t size) {
                    int32_t status;
          ::HAL_SetSerialReadBufferSize(std::move(handle), std::move(size), &status);
          return status;
        },
      py::arg("handle"), py::arg("size"), release_gil(), py::doc(
    "Sets the size of the read buffer.\n"
"\n"
":param in:  handle  the serial port handle\n"
":param in:  size    the read buffer size\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("setSerialWriteBufferSize", [](HAL_SerialPortHandle handle, int32_t size) {
                    int32_t status;
          ::HAL_SetSerialWriteBufferSize(std::move(handle), std::move(size), &status);
          return status;
        },
      py::arg("handle"), py::arg("size"), release_gil(), py::doc(
    "Sets the size of the write buffer.\n"
"\n"
":param in:  handle  the serial port handle\n"
":param in:  size    the write buffer size\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("getSerialBytesReceived", [](HAL_SerialPortHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetSerialBytesReceived(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Gets the number of bytes currently in the read buffer.\n"
"\n"
":param in:  handle  the serial port handle\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: the number of bytes in the read buffer")
  )
  
  ;
m
  .
def
("readSerial", [](HAL_SerialPortHandle handle, const py::buffer& buffer) {
                    int32_t count;
          int32_t status;
          auto __buffer = buffer.request(true);
          count = __buffer.size * __buffer.itemsize;
          auto __ret =::HAL_ReadSerial(std::move(handle), (char*)__buffer.ptr, count, &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), py::arg("buffer"), release_gil(), py::doc(
    "Reads data from the serial port.\n"
"\n"
"Will wait for either timeout (if set), the termination char (if set), or the\n"
"count to be full. Whichever one comes first.\n"
"\n"
":param in:  handle  the serial port handle\n"
":param out: buffer the buffer in which to store bytes read\n"
":param in:  count   the number of bytes maximum to read\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: the number of bytes actually read")
  )
  
  ;
m
  .
def
("writeSerial", [](HAL_SerialPortHandle handle, const py::buffer& buffer) {
                    int32_t count;
          int32_t status;
          auto __buffer = buffer.request(false);
          count = __buffer.size * __buffer.itemsize;
          auto __ret =::HAL_WriteSerial(std::move(handle), (const char*)__buffer.ptr, count, &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), py::arg("buffer"), release_gil(), py::doc(
    "Writes data to the serial port.\n"
"\n"
":param in:  handle  the serial port handle\n"
":param in:  buffer  the buffer to write\n"
":param in:  count   the number of bytes to write from the buffer\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: the number of bytes actually written")
  )
  
  ;
m
  .
def
("flushSerial", [](HAL_SerialPortHandle handle) {
                    int32_t status;
          ::HAL_FlushSerial(std::move(handle), &status);
          return status;
        },
      py::arg("handle"), release_gil(), py::doc(
    "Flushes the serial write buffer out to the port.\n"
"\n"
":param in:  handle  the serial port handle\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("clearSerial", [](HAL_SerialPortHandle handle) {
                    int32_t status;
          ::HAL_ClearSerial(std::move(handle), &status);
          return status;
        },
      py::arg("handle"), release_gil(), py::doc(
    "Clears the receive buffer of the serial port.\n"
"\n"
":param in:  handle  the serial port handle\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("closeSerial", &::HAL_CloseSerial,
      py::arg("handle"), release_gil(), py::doc(
    "Closes a serial port.\n"
"\n"
":param in: handle  the serial port handle to close")
  )
  
  ;



}

}; // struct rpybuild_SerialPort_initializer

static std::unique_ptr<rpybuild_SerialPort_initializer> cls;

void begin_init_SerialPort(py::module &m) {
  cls = std::make_unique<rpybuild_SerialPort_initializer>(m);
}

void finish_init_SerialPort() {
  cls->finish();
  cls.reset();
}