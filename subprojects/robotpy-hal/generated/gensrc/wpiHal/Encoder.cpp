
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <hal/Encoder.h>
















#include <type_traits>






struct rpybuild_Encoder_initializer {







  
  py::enum_<::HAL_EncoderIndexingType> enum1;

  
  py::enum_<::HAL_EncoderEncodingType> enum2;







  py::module &m;

  
  rpybuild_Encoder_initializer(py::module &m) :

  

  
    enum1
  (m, "EncoderIndexingType"
  ,
    "The type of index pulse for the encoder."),
  
    enum2
  (m, "EncoderEncodingType"
  ,
    "The encoding scaling of the encoder."),
  

  

  

    m(m)
  {
    
    
      enum1
  
    .value("kResetWhileHigh", ::HAL_EncoderIndexingType::HAL_kResetWhileHigh)
  
    .value("kResetWhileLow", ::HAL_EncoderIndexingType::HAL_kResetWhileLow)
  
    .value("kResetOnFallingEdge", ::HAL_EncoderIndexingType::HAL_kResetOnFallingEdge)
  
    .value("kResetOnRisingEdge", ::HAL_EncoderIndexingType::HAL_kResetOnRisingEdge)
  ;

    
      enum2
  
    .value("Encoder_k1X", ::HAL_EncoderEncodingType::HAL_Encoder_k1X)
  
    .value("Encoder_k2X", ::HAL_EncoderEncodingType::HAL_Encoder_k2X)
  
    .value("Encoder_k4X", ::HAL_EncoderEncodingType::HAL_Encoder_k4X)
  ;

    

    
  }

void finish() {







m
  .
def
("initializeEncoder", [](HAL_Handle digitalSourceHandleA, HAL_AnalogTriggerType analogTriggerTypeA, HAL_Handle digitalSourceHandleB, HAL_AnalogTriggerType analogTriggerTypeB, HAL_Bool reverseDirection, HAL_EncoderEncodingType encodingType) {
                    int32_t status;
          auto __ret =::HAL_InitializeEncoder(std::move(digitalSourceHandleA), std::move(analogTriggerTypeA), std::move(digitalSourceHandleB), std::move(analogTriggerTypeB), std::move(reverseDirection), std::move(encodingType), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("digitalSourceHandleA"), py::arg("analogTriggerTypeA"), py::arg("digitalSourceHandleB"), py::arg("analogTriggerTypeB"), py::arg("reverseDirection"), py::arg("encodingType"), release_gil(), py::doc(
    "Initializes an encoder.\n"
"\n"
":param in:  digitalSourceHandleA the A source (either a HAL_DigitalHandle or a\n"
"            HAL_AnalogTriggerHandle)\n"
":param in:  analogTriggerTypeA   the analog trigger type of the A source if it\n"
"            is an analog trigger\n"
":param in:  digitalSourceHandleB the B source (either a HAL_DigitalHandle or a\n"
"            HAL_AnalogTriggerHandle)\n"
":param in:  analogTriggerTypeB   the analog trigger type of the B source if it\n"
"            is an analog trigger\n"
":param in:  reverseDirection     true to reverse the counting direction from\n"
"            standard, otherwise false\n"
":param in:  encodingType         the encoding type\n"
":param out: status              Error status variable. 0 on success.\n"
"\n"
":returns: the created encoder handle")
  )
  
  ;
m
  .
def
("freeEncoder", [](HAL_EncoderHandle encoderHandle) {
                    int32_t status;
          ::HAL_FreeEncoder(std::move(encoderHandle), &status);
          return status;
        },
      py::arg("encoderHandle"), release_gil(), py::doc(
    "Frees an encoder.\n"
"\n"
":param in:  encoderHandle the encoder handle\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setEncoderSimDevice", &::HAL_SetEncoderSimDevice,
      py::arg("handle"), py::arg("device"), release_gil(), py::doc(
    "Indicates the encoder is used by a simulated device.\n"
"\n"
":param handle: the encoder handle\n"
":param device: simulated device handle")
  )
  
  ;
m
  .
def
("getEncoder", [](HAL_EncoderHandle encoderHandle) {
                    int32_t status;
          auto __ret =::HAL_GetEncoder(std::move(encoderHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("encoderHandle"), release_gil(), py::doc(
    "Gets the current counts of the encoder after encoding type scaling.\n"
"\n"
"This is scaled by the value passed during initialization to encodingType.\n"
"\n"
":param in:  encoderHandle the encoder handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: the current scaled count")
  )
  
  ;
m
  .
def
("getEncoderRaw", [](HAL_EncoderHandle encoderHandle) {
                    int32_t status;
          auto __ret =::HAL_GetEncoderRaw(std::move(encoderHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("encoderHandle"), release_gil(), py::doc(
    "Gets the raw counts of the encoder.\n"
"\n"
"This is not scaled by any values.\n"
"\n"
":param in:  encoderHandle the encoder handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: the raw encoder count")
  )
  
  ;
m
  .
def
("getEncoderEncodingScale", [](HAL_EncoderHandle encoderHandle) {
                    int32_t status;
          auto __ret =::HAL_GetEncoderEncodingScale(std::move(encoderHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("encoderHandle"), release_gil(), py::doc(
    "Gets the encoder scale value.\n"
"\n"
"This is set by the value passed during initialization to encodingType.\n"
"\n"
":param in:  encoderHandle the encoder handle\n"
":param out: status       Error status variable. 0 on success.\n"
"\n"
":returns: the encoder scale value")
  )
  
  ;
m
  .
def
("resetEncoder", [](HAL_EncoderHandle encoderHandle) {
                    int32_t status;
          ::HAL_ResetEncoder(std::move(encoderHandle), &status);
          return status;
        },
      py::arg("encoderHandle"), release_gil(), py::doc(
    "Reads the current encoder value.\n"
"\n"
"Read the value at this instant. It may still be running, so it reflects the\n"
"current value. Next time it is read, it might have a different value.\n"
"\n"
":param in:  encoderHandle the encoder handle\n"
":param out: status       Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("getEncoderPeriod", [](HAL_EncoderHandle encoderHandle) {
                    int32_t status;
          auto __ret =::HAL_GetEncoderPeriod(std::move(encoderHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("encoderHandle"), release_gil(), py::doc(
    "Gets the Period of the most recent count.\n"
"\n"
"Returns the time interval of the most recent count. This can be used for\n"
"velocity calculations to determine shaft speed.\n"
"\n"
":param in:  encoderHandle the encoder handle\n"
":param out: status       Error status variable. 0 on success.\n"
"\n"
":returns: the period of the last two pulses in units of seconds")
  )
  
  ;
m
  .
def
("setEncoderMaxPeriod", [](HAL_EncoderHandle encoderHandle, double maxPeriod) {
                    int32_t status;
          ::HAL_SetEncoderMaxPeriod(std::move(encoderHandle), std::move(maxPeriod), &status);
          return status;
        },
      py::arg("encoderHandle"), py::arg("maxPeriod"), release_gil(), py::doc(
    "Sets the maximum period where the device is still considered \"moving\".\n"
"\n"
"Sets the maximum period where the device is considered moving. This value is\n"
"used to determine the \"stopped\" state of the encoder using the\n"
"HAL_GetEncoderStopped method.\n"
"\n"
":param in:  encoderHandle the encoder handle\n"
":param in:  maxPeriod     the maximum period where the counted device is\n"
"            considered moving in seconds\n"
":param out: status       Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("getEncoderStopped", [](HAL_EncoderHandle encoderHandle) {
                    int32_t status;
          auto __ret =::HAL_GetEncoderStopped(std::move(encoderHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("encoderHandle"), release_gil(), py::doc(
    "Determines if the clock is stopped.\n"
"\n"
"Determines if the clocked input is stopped based on the MaxPeriod value set\n"
"using the SetMaxPeriod method. If the clock exceeds the MaxPeriod, then the\n"
"device (and encoder) are assumed to be stopped and it returns true.\n"
"\n"
":param in:  encoderHandle the encoder handle\n"
":param out: status       Error status variable. 0 on success.\n"
"\n"
":returns: true if the most recent encoder period exceeds the MaxPeriod value\n"
"          set by SetMaxPeriod")
  )
  
  ;
m
  .
def
("getEncoderDirection", [](HAL_EncoderHandle encoderHandle) {
                    int32_t status;
          auto __ret =::HAL_GetEncoderDirection(std::move(encoderHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("encoderHandle"), release_gil(), py::doc(
    "Gets the last direction the encoder value changed.\n"
"\n"
":param in:  encoderHandle the encoder handle\n"
":param out: status       Error status variable. 0 on success.\n"
"\n"
":returns: the last direction the encoder value changed")
  )
  
  ;
m
  .
def
("getEncoderDistance", [](HAL_EncoderHandle encoderHandle) {
                    int32_t status;
          auto __ret =::HAL_GetEncoderDistance(std::move(encoderHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("encoderHandle"), release_gil(), py::doc(
    "Gets the current distance traveled by the encoder.\n"
"\n"
"This is the encoder count scaled by the distance per pulse set for the\n"
"encoder.\n"
"\n"
":param in:  encoderHandle the encoder handle\n"
":param out: status       Error status variable. 0 on success.\n"
"\n"
":returns: the encoder distance (units are determined by the units\n"
"          passed to HAL_SetEncoderDistancePerPulse)")
  )
  
  ;
m
  .
def
("getEncoderRate", [](HAL_EncoderHandle encoderHandle) {
                    int32_t status;
          auto __ret =::HAL_GetEncoderRate(std::move(encoderHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("encoderHandle"), release_gil(), py::doc(
    "Gets the current rate of the encoder.\n"
"\n"
"This is the encoder period scaled by the distance per pulse set for the\n"
"encoder.\n"
"\n"
":param in:  encoderHandle the encoder handle\n"
":param out: status       Error status variable. 0 on success.\n"
"\n"
":returns: the encoder rate (units are determined by the units passed to\n"
"          HAL_SetEncoderDistancePerPulse, time value is seconds)")
  )
  
  ;
m
  .
def
("setEncoderMinRate", [](HAL_EncoderHandle encoderHandle, double minRate) {
                    int32_t status;
          ::HAL_SetEncoderMinRate(std::move(encoderHandle), std::move(minRate), &status);
          return status;
        },
      py::arg("encoderHandle"), py::arg("minRate"), release_gil(), py::doc(
    "Sets the minimum rate to be considered moving by the encoder.\n"
"\n"
"Units need to match what is set by HAL_SetEncoderDistancePerPulse, with time\n"
"as seconds.\n"
"\n"
":param in:  encoderHandle the encoder handle\n"
":param in:  minRate       the minimum rate to be considered moving (units are\n"
"            determined by the units passed to\n"
"            HAL_SetEncoderDistancePerPulse, time value is\n"
"            seconds)\n"
":param out: status       Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setEncoderDistancePerPulse", [](HAL_EncoderHandle encoderHandle, double distancePerPulse) {
                    int32_t status;
          ::HAL_SetEncoderDistancePerPulse(std::move(encoderHandle), std::move(distancePerPulse), &status);
          return status;
        },
      py::arg("encoderHandle"), py::arg("distancePerPulse"), release_gil(), py::doc(
    "Sets the distance traveled per encoder pulse. This is used as a scaling\n"
"factor for the rate and distance calls.\n"
"\n"
":param in:  encoderHandle    the encoder handle\n"
":param in:  distancePerPulse the distance traveled per encoder pulse (units\n"
"            user defined)\n"
":param out: status          Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setEncoderReverseDirection", [](HAL_EncoderHandle encoderHandle, HAL_Bool reverseDirection) {
                    int32_t status;
          ::HAL_SetEncoderReverseDirection(std::move(encoderHandle), std::move(reverseDirection), &status);
          return status;
        },
      py::arg("encoderHandle"), py::arg("reverseDirection"), release_gil(), py::doc(
    "Sets if to reverse the direction of the encoder.\n"
"\n"
"Note that this is not a toggle. It is an absolute set.\n"
"\n"
":param in:  encoderHandle    the encoder handle\n"
":param in:  reverseDirection true to reverse the direction, false to not.\n"
":param out: status          Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setEncoderSamplesToAverage", [](HAL_EncoderHandle encoderHandle, int32_t samplesToAverage) {
                    int32_t status;
          ::HAL_SetEncoderSamplesToAverage(std::move(encoderHandle), std::move(samplesToAverage), &status);
          return status;
        },
      py::arg("encoderHandle"), py::arg("samplesToAverage"), release_gil(), py::doc(
    "Sets the number of encoder samples to average when calculating encoder rate.\n"
"\n"
":param in:  encoderHandle    the encoder handle\n"
":param in:  samplesToAverage the number of samples to average\n"
":param out: status          Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("getEncoderSamplesToAverage", [](HAL_EncoderHandle encoderHandle) {
                    int32_t status;
          auto __ret =::HAL_GetEncoderSamplesToAverage(std::move(encoderHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("encoderHandle"), release_gil(), py::doc(
    "Gets the current samples to average value.\n"
"\n"
":param in:  encoderHandle the encoder handle\n"
":param out: status       Error status variable. 0 on success.\n"
"\n"
":returns: the current samples to average value")
  )
  
  ;
m
  .
def
("setEncoderIndexSource", [](HAL_EncoderHandle encoderHandle, HAL_Handle digitalSourceHandle, HAL_AnalogTriggerType analogTriggerType, HAL_EncoderIndexingType type) {
                    int32_t status;
          ::HAL_SetEncoderIndexSource(std::move(encoderHandle), std::move(digitalSourceHandle), std::move(analogTriggerType), std::move(type), &status);
          return status;
        },
      py::arg("encoderHandle"), py::arg("digitalSourceHandle"), py::arg("analogTriggerType"), py::arg("type"), release_gil(), py::doc(
    "Sets the source for an index pulse on the encoder.\n"
"\n"
"The index pulse can be used to cause an encoder to reset based on an external\n"
"input.\n"
"\n"
":param in:  encoderHandle       the encoder handle\n"
":param in:  digitalSourceHandle the index source handle (either a\n"
"            HAL_AnalogTriggerHandle or a\n"
"            HAL_DigitalHandle)\n"
":param in:  analogTriggerType   the analog trigger type if the source is an\n"
"            analog trigger\n"
":param in:  type                the index triggering type\n"
":param out: status             Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("getEncoderFPGAIndex", [](HAL_EncoderHandle encoderHandle) {
                    int32_t status;
          auto __ret =::HAL_GetEncoderFPGAIndex(std::move(encoderHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("encoderHandle"), release_gil(), py::doc(
    "Gets the FPGA index of the encoder.\n"
"\n"
":param in:  encoderHandle the encoder handle\n"
":param out: status       Error status variable. 0 on success.\n"
"\n"
":returns: the FPGA index of the encoder")
  )
  
  ;
m
  .
def
("getEncoderDecodingScaleFactor", [](HAL_EncoderHandle encoderHandle) {
                    int32_t status;
          auto __ret =::HAL_GetEncoderDecodingScaleFactor(std::move(encoderHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("encoderHandle"), release_gil(), py::doc(
    "Gets the decoding scale factor of the encoder.\n"
"\n"
"This is used to perform the scaling from raw to type scaled values.\n"
"\n"
":param in:  encoderHandle the encoder handle\n"
":param out: status       Error status variable. 0 on success.\n"
"\n"
":returns: the scale value for the encoder")
  )
  
  ;
m
  .
def
("getEncoderDistancePerPulse", [](HAL_EncoderHandle encoderHandle) {
                    int32_t status;
          auto __ret =::HAL_GetEncoderDistancePerPulse(std::move(encoderHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("encoderHandle"), release_gil(), py::doc(
    "Gets the user set distance per pulse of the encoder.\n"
"\n"
":param in:  encoderHandle the encoder handle\n"
":param out: status       Error status variable. 0 on success.\n"
"\n"
":returns: the set distance per pulse")
  )
  
  ;
m
  .
def
("getEncoderEncodingType", [](HAL_EncoderHandle encoderHandle) {
                    int32_t status;
          auto __ret =::HAL_GetEncoderEncodingType(std::move(encoderHandle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("encoderHandle"), release_gil(), py::doc(
    "Gets the encoding type of the encoder.\n"
"\n"
":param in:  encoderHandle the encoder handle\n"
":param out: status       Error status variable. 0 on success.\n"
"\n"
":returns: the encoding type")
  )
  
  ;



}

}; // struct rpybuild_Encoder_initializer

static std::unique_ptr<rpybuild_Encoder_initializer> cls;

void begin_init_Encoder(py::module &m) {
  cls = std::make_unique<rpybuild_Encoder_initializer>(m);
}

void finish_init_Encoder() {
  cls->finish();
  cls.reset();
}