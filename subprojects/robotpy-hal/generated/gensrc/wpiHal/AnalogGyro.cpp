
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <hal/AnalogGyro.h>
















#include <type_traits>






struct rpybuild_AnalogGyro_initializer {













  py::module &m;

  
  rpybuild_AnalogGyro_initializer(py::module &m) :

  

  

  

  

    m(m)
  {
    
    

    
  }

void finish() {







m
  .
def
("initializeAnalogGyro", [](HAL_AnalogInputHandle handle, const char* allocationLocation) {
                    int32_t status;
          auto __ret =::HAL_InitializeAnalogGyro(std::move(handle), allocationLocation, &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), py::arg("allocationLocation"), release_gil(), py::doc(
    "Initializes an analog gyro.\n"
"\n"
":param in:  handle handle to the analog input port\n"
":param in:  allocationLocation the location where the allocation is occurring\n"
"            (can be null)\n"
":param out: status the error code, or 0 for success\n"
"\n"
":returns: the initialized gyro handle")
  )
  
  ;
m
  .
def
("setupAnalogGyro", [](HAL_GyroHandle handle) {
                    int32_t status;
          ::HAL_SetupAnalogGyro(std::move(handle), &status);
          return status;
        },
      py::arg("handle"), release_gil(), py::doc(
    "Sets up an analog gyro with the proper offsets and settings for the KOP\n"
"analog gyro.\n"
"\n"
":param in:  handle the gyro handle\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("freeAnalogGyro", &::HAL_FreeAnalogGyro,
      py::arg("handle"), release_gil(), py::doc(
    "Frees an analog gyro.\n"
"\n"
":param in: out] handle the gyro handle")
  )
  
  ;
m
  .
def
("setAnalogGyroParameters", [](HAL_GyroHandle handle, double voltsPerDegreePerSecond, double offset, int32_t center) {
                    int32_t status;
          ::HAL_SetAnalogGyroParameters(std::move(handle), std::move(voltsPerDegreePerSecond), std::move(offset), std::move(center), &status);
          return status;
        },
      py::arg("handle"), py::arg("voltsPerDegreePerSecond"), py::arg("offset"), py::arg("center"), release_gil(), py::doc(
    "Sets the analog gyro parameters to the specified values.\n"
"\n"
"This is meant to be used if you want to reuse the values from a previous\n"
"calibration.\n"
"\n"
":param in:  handle                  the gyro handle\n"
":param in:  voltsPerDegreePerSecond the gyro volts scaling\n"
":param in:  offset                  the gyro offset\n"
":param in:  center                  the gyro center\n"
":param out: status                  the error code, or 0 for success")
  )
  
  ;
m
  .
def
("setAnalogGyroVoltsPerDegreePerSecond", [](HAL_GyroHandle handle, double voltsPerDegreePerSecond) {
                    int32_t status;
          ::HAL_SetAnalogGyroVoltsPerDegreePerSecond(std::move(handle), std::move(voltsPerDegreePerSecond), &status);
          return status;
        },
      py::arg("handle"), py::arg("voltsPerDegreePerSecond"), release_gil(), py::doc(
    "Sets the analog gyro volts per degrees per second scaling.\n"
"\n"
":param in:  handle                  the gyro handle\n"
":param in:  voltsPerDegreePerSecond the gyro volts scaling\n"
":param out: status                  the error code, or 0 for success")
  )
  
  ;
m
  .
def
("resetAnalogGyro", [](HAL_GyroHandle handle) {
                    int32_t status;
          ::HAL_ResetAnalogGyro(std::move(handle), &status);
          return status;
        },
      py::arg("handle"), release_gil(), py::doc(
    "Resets the analog gyro value to 0.\n"
"\n"
":param in:  handle the gyro handle\n"
":param out: status the error code, or 0 for success")
  )
  
  ;
m
  .
def
("calibrateAnalogGyro", [](HAL_GyroHandle handle) {
                    int32_t status;
          ::HAL_CalibrateAnalogGyro(std::move(handle), &status);
          return status;
        },
      py::arg("handle"), release_gil(), py::doc(
    "Calibrates the analog gyro.\n"
"\n"
"This happens by calculating the average value of the gyro over 5 seconds, and\n"
"setting that as the center. Note that this call blocks for 5 seconds to\n"
"perform this.\n"
"\n"
":param in:  handle the gyro handle\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("setAnalogGyroDeadband", [](HAL_GyroHandle handle, double volts) {
                    int32_t status;
          ::HAL_SetAnalogGyroDeadband(std::move(handle), std::move(volts), &status);
          return status;
        },
      py::arg("handle"), py::arg("volts"), release_gil(), py::doc(
    "Sets the deadband of the analog gyro.\n"
"\n"
":param in:  handle the gyro handle\n"
":param in:  volts  the voltage deadband\n"
":param out: status Error status variable. 0 on success.")
  )
  
  ;
m
  .
def
("getAnalogGyroAngle", [](HAL_GyroHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetAnalogGyroAngle(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Gets the gyro angle in degrees.\n"
"\n"
":param in:  handle the gyro handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: the gyro angle in degrees")
  )
  
  ;
m
  .
def
("getAnalogGyroRate", [](HAL_GyroHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetAnalogGyroRate(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Gets the gyro rate in degrees/second.\n"
"\n"
":param in:  handle the gyro handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: the gyro rate in degrees/second")
  )
  
  ;
m
  .
def
("getAnalogGyroOffset", [](HAL_GyroHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetAnalogGyroOffset(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Gets the calibrated gyro offset.\n"
"\n"
"Can be used to not repeat a calibration but reconstruct the gyro object.\n"
"\n"
":param in:  handle the gyro handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: the gryo offset")
  )
  
  ;
m
  .
def
("getAnalogGyroCenter", [](HAL_GyroHandle handle) {
                    int32_t status;
          auto __ret =::HAL_GetAnalogGyroCenter(std::move(handle), &status);
          return std::make_tuple(__ret,status);
        },
      py::arg("handle"), release_gil(), py::doc(
    "Gets the calibrated gyro center.\n"
"\n"
"Can be used to not repeat a calibration but reconstruct the gyro object.\n"
"\n"
":param in:  handle the gyro handle\n"
":param out: status Error status variable. 0 on success.\n"
"\n"
":returns: the gyro center")
  )
  
  ;



}

}; // struct rpybuild_AnalogGyro_initializer

static std::unique_ptr<rpybuild_AnalogGyro_initializer> cls;

void begin_init_AnalogGyro(py::module &m) {
  cls = std::make_unique<rpybuild_AnalogGyro_initializer>(m);
}

void finish_init_AnalogGyro() {
  cls->finish();
  cls.reset();
}