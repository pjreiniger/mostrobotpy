
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <cscore_cv.h>


#include <cvnp/cvnp.h>

#include <pybind11/functional.h>













#include <opencv2/core/core.hpp>

#include <cvnp/cvnp.h>



#include <type_traits>


  using namespace cv;

  using namespace cs;





struct rpybuild_cscore_cv_initializer {


  

  


  

  












  py::class_<typename cs::CvSource, cs::ImageSource> cls_CvSource;

    

    
    
  py::class_<typename cs::CvSink, cs::ImageSink> cls_CvSink;

    

    
    

  py::module &m;

  
  rpybuild_cscore_cv_initializer(py::module &m) :

  

  

  

  
    cls_CvSource(m, "CvSource"),

  

  
  
  
    cls_CvSink(m, "CvSink"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_CvSource.doc() =
    "A source for user code to provide OpenCV images as video frames.";

  cls_CvSource
  
    
  .def(py::init<std::string_view, const VideoMode&>(),
      py::arg("name"), py::arg("mode"), release_gil()
    , py::keep_alive<1, 3>(), py::doc(
    "Create an OpenCV source.\n"
"\n"
":param name: Source name (arbitrary unique identifier)\n"
":param mode: Video mode being generated")
  )
  
  
  
    
  .def(py::init<std::string_view, VideoMode::PixelFormat, int, int, int>(),
      py::arg("name"), py::arg("pixelFormat"), py::arg("width"), py::arg("height"), py::arg("fps"), release_gil(), py::doc(
    "Create an OpenCV source.\n"
"\n"
":param name:        Source name (arbitrary unique identifier)\n"
":param pixelFormat: Pixel format\n"
":param width:       width\n"
":param height:      height\n"
":param fps:         fps")
  )
  
  
  
    
  .
def
("putFrame", &cs::CvSource::PutFrame,
      py::arg("image"), release_gil(), py::doc(
    "Put an OpenCV image and notify sinks.\n"
"\n"
"Only 8-bit single-channel or 3-channel (with BGR channel order) images\n"
"are supported. If the format, depth or channel order is different, use\n"
"cv::Mat::convertTo() and/or cv::cvtColor() to convert it first.\n"
"\n"
":param image: OpenCV image")
  )
  
  
  ;

  


  }

  {
  
  
  


  

  cls_CvSink.doc() =
    "A sink for user code to accept video frames as OpenCV images.";

  cls_CvSink
  
    
  .def(py::init<std::string_view, VideoMode::PixelFormat>(),
      py::arg("name"), py::arg("pixelFormat") = VideoMode::PixelFormat::kBGR, release_gil(), py::doc(
    "Create a sink for accepting OpenCV images.\n"
"\n"
"WaitForFrame() must be called on the created sink to get each new\n"
"image.\n"
"\n"
":param name:        Source name (arbitrary unique identifier)\n"
":param pixelFormat: Source pixel format")
  )
  
  
  
    
  .def(py::init<std::string_view, std::function<void (uint64_t time)>, VideoMode::PixelFormat>(),
      py::arg("name"), py::arg("processFrame").none(false), py::arg("pixelFormat") = VideoMode::PixelFormat::kBGR, release_gil(), py::doc(
    "Create a sink for accepting OpenCV images in a separate thread.\n"
"\n"
"A thread will be created that calls WaitForFrame() and calls the\n"
"processFrame() callback each time a new frame arrives.\n"
"\n"
":param name:         Source name (arbitrary unique identifier)\n"
":param processFrame: Frame processing function; will be called with a\n"
"                     time=0 if an error occurred.  processFrame should call GetImage()\n"
"                     or GetError() as needed, but should not call (except in very\n"
"                     unusual circumstances) WaitForImage().\n"
":param pixelFormat:  Source pixel format")
  )
  
  
  
    
  .
def
("grabFrame", [](cs::CvSink &self, cv::Mat& image, double timeout) -> std::tuple<uint64_t, cv::Mat> {
  py::gil_scoped_release unlock;
  auto result = self.GrabFrame(image, timeout);
  return std::make_tuple(result, image);
}
,
      py::arg("image"), py::arg("timeout") = 0.225, py::doc(
    "Wait for the next frame and get the image.\n"
"Times out (returning 0) after timeout seconds.\n"
"The provided image will have three 8-bit channels stored in BGR order.\n"
"\n"
":returns: Frame time, or 0 on error (call GetError() to obtain the error\n"
"          message); the frame time is in the same time base as wpi::Now(),\n"
"          and is in 1 us increments.")
  )
  
  
  
    
  .
def
("grabFrameNoTimeout", [](cs::CvSink &self, cv::Mat& image) -> std::tuple<uint64_t, cv::Mat> {
  py::gil_scoped_release unlock;
  auto result = self.GrabFrameNoTimeout(image);
  return std::make_tuple(result, image);
}
,
      py::arg("image"), py::doc(
    "Wait for the next frame and get the image.  May block forever.\n"
"The provided image will have three 8-bit channels stored in BGR order.\n"
"\n"
":returns: Frame time, or 0 on error (call GetError() to obtain the error\n"
"          message); the frame time is in the same time base as wpi::Now(),\n"
"          and is in 1 us increments.")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_cscore_cv_initializer

static std::unique_ptr<rpybuild_cscore_cv_initializer> cls;

void begin_init_cscore_cv(py::module &m) {
  cls = std::make_unique<rpybuild_cscore_cv_initializer>(m);
}

void finish_init_cscore_cv() {
  cls->finish();
  cls.reset();
}