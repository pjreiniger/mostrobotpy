
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <cscore_cv.h>


#include <cvnp/cvnp.h>













#include <opencv2/core/core.hpp>

#include <cvnp/cvnp.h>



#include <type_traits>


  using namespace cs;



struct rpybuild_cscore_cv_initializer {


  

  


  

  












  py::class_<typename cs::CvSource, cs::ImageSource> cls_CvSource;

    

    
    
  py::class_<typename cs::CvSink, cs::ImageSink> cls_CvSink;

    

    
    

  py::module &m;

  
  rpybuild_cscore_cv_initializer(py::module &m) :

  

  

  

  
    cls_CvSource(m, "CvSource"),

  

  
  
  
    cls_CvSink(m, "CvSink"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_CvSource.doc() =
    "A source for user code to provide OpenCV images as video frames.";

  cls_CvSource
  
    
  .def(py::init<std::string_view, const VideoMode&>(),
      py::arg("name"), py::arg("mode"), release_gil()
    , py::keep_alive<1, 3>(), py::doc(
    "Create an OpenCV source.\n"
"\n"
":param name: Source name (arbitrary unique identifier)\n"
":param mode: Video mode being generated")
  )
  
  
  
    
  .def(py::init<std::string_view, VideoMode::PixelFormat, int, int, int>(),
      py::arg("name"), py::arg("pixelFormat"), py::arg("width"), py::arg("height"), py::arg("fps"), release_gil(), py::doc(
    "Create an  OpenCV source.\n"
"\n"
":param name:        Source name (arbitrary unique identifier)\n"
":param pixelFormat: Pixel format\n"
":param width:       width\n"
":param height:      height\n"
":param fps:         fps")
  )
  
  
  
    
  .
def
("putFrame", static_cast<void(cs::CvSource::*)(cv::Mat&)>(
        &cs::CvSource::PutFrame),
      py::arg("image"), release_gil(), py::doc(
    "Put an OpenCV image and notify sinks\n"
"\n"
"The image format is guessed from the number of channels. The channel\n"
"mapping is as follows. 1: kGray 2: kYUYV 3: BGR 4: BGRA Any other channel\n"
"numbers will throw an error. If your image is an in alternate format, use\n"
"the overload that takes a PixelFormat.\n"
"\n"
":param image: OpenCV Image")
  )
  
  
  
    
  .
def
("putFrame", static_cast<void(cs::CvSource::*)(cv::Mat&, VideoMode::PixelFormat, bool)>(
        &cs::CvSource::PutFrame),
      py::arg("image"), py::arg("pixelFormat"), py::arg("skipVerification"), release_gil(), py::doc(
    "Put an OpenCV image and notify sinks.\n"
"\n"
"The format of the Mat must match the PixelFormat. You will corrupt memory\n"
"if they dont. With skipVerification false, we will verify the number of\n"
"channels matches the pixel format. If skipVerification is true, this step\n"
"is skipped and is passed straight through.\n"
"\n"
":param image:            OpenCV image\n"
":param pixelFormat:      The pixel format of the image\n"
":param skipVerification: skip verifying pixel format")
  )
  
  
  ;

  


  }

  {
  
  
  


  

  cls_CvSink.doc() =
    "A sink for user code to accept video frames as OpenCV images.";

  cls_CvSink
  
    
  .def(py::init<std::string_view, VideoMode::PixelFormat>(),
      py::arg("name"), py::arg("pixelFormat") = VideoMode::PixelFormat::kBGR, release_gil(), py::doc(
    "Create a sink for accepting OpenCV images.\n"
"\n"
"WaitForFrame() must be called on the created sink to get each new\n"
"image.\n"
"\n"
":param name:        Source name (arbitrary unique identifier)\n"
":param pixelFormat: The pixel format to read")
  )
  
  
  
    
  .
def
("grabFrame", [](cs::CvSink &self, cv::Mat& image, double timeout) -> std::tuple<uint64_t, cv::Mat> {
  py::gil_scoped_release unlock;
  auto result = self.GrabFrame(image, timeout);
  return std::make_tuple(result, image);
}
,
      py::arg("image"), py::arg("timeout") = 0.225, py::doc(
    "Wait for the next frame and get the image.\n"
"Times out (returning 0) after timeout seconds.\n"
"The provided image will have the pixelFormat this class was constructed\n"
"with.\n"
"\n"
":returns: Frame time, or 0 on error (call GetError() to obtain the error\n"
"          message); the frame time is in the same time base as wpi::Now(),\n"
"          and is in 1 us increments.")
  )
  
  
  
    
  .
def
("grabFrameNoTimeout", [](cs::CvSink &self, cv::Mat& image) -> std::tuple<uint64_t, cv::Mat> {
  py::gil_scoped_release unlock;
  auto result = self.GrabFrameNoTimeout(image);
  return std::make_tuple(result, image);
}
,
      py::arg("image"), py::doc(
    "Wait for the next frame and get the image.  May block forever.\n"
"The provided image will have the pixelFormat this class was constructed\n"
"with.\n"
"\n"
":returns: Frame time, or 0 on error (call GetError() to obtain the error\n"
"          message); the frame time is in the same time base as wpi::Now(),\n"
"          and is in 1 us increments.")
  )
  
  
  
    
  .
def
("grabFrameDirect", &cs::CvSink::GrabFrameDirect,
      py::arg("image"), py::arg("timeout") = 0.225, release_gil(), py::doc(
    "Wait for the next frame and get the image.\n"
"Times out (returning 0) after timeout seconds.\n"
"The provided image will have the pixelFormat this class was constructed\n"
"with. The data is backed by data in the CvSink. It will be invalidated by\n"
"any grabFrame*() call on the sink.\n"
"\n"
":returns: Frame time, or 0 on error (call GetError() to obtain the error\n"
"          message); the frame time is in the same time base as wpi::Now(),\n"
"          and is in 1 us increments.")
  )
  
  
  
    
  .
def
("grabFrameNoTimeoutDirect", &cs::CvSink::GrabFrameNoTimeoutDirect,
      py::arg("image"), release_gil(), py::doc(
    "Wait for the next frame and get the image.  May block forever.\n"
"The provided image will have the pixelFormat this class was constructed\n"
"with. The data is backed by data in the CvSink. It will be invalidated by\n"
"any grabFrame*() call on the sink.\n"
"\n"
":returns: Frame time, or 0 on error (call GetError() to obtain the error\n"
"          message); the frame time is in the same time base as wpi::Now(),\n"
"          and is in 1 us increments.")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_cscore_cv_initializer

static std::unique_ptr<rpybuild_cscore_cv_initializer> cls;

void begin_init_cscore_cv(py::module &m) {
  cls = std::make_unique<rpybuild_cscore_cv_initializer>(m);
}

void finish_init_cscore_cv() {
  cls->finish();
  cls.reset();
}