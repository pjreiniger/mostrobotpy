
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <cscore_oo.h>


#include <pybind11/functional.h>

#include <pybind11/stl.h>

#include <wpi_json_type_caster.h>

#include <wpi_smallvectorimpl_type_caster.h>

#include <wpi_span_type_caster.h>



#include <pybind11/operators.h>













#include <type_traits>


  using namespace cs;





struct rpybuild_cscore_oo_initializer {


  

  


  

  


  

  


  

  


  

  static constexpr auto kUnknown = cs::HttpCamera::HttpCameraKind::kUnknown;
  


  

  


  

  


  

  


  

  


  

  


  

  


  

  












  py::class_<typename cs::VideoProperty> cls_VideoProperty;

    
    
  py::enum_<cs::VideoProperty::Kind> cls_VideoProperty_enum1;
    

    
    
  py::class_<typename cs::VideoSource> cls_VideoSource;

    
    
  py::enum_<cs::VideoSource::Kind> cls_VideoSource_enum1;
    
    
  py::enum_<cs::VideoSource::ConnectionStrategy> cls_VideoSource_enum2;
    

    
    
  py::class_<typename cs::VideoCamera, cs::VideoSource> cls_VideoCamera;

    
    
  py::enum_<cs::VideoCamera::WhiteBalance> cls_VideoCamera_enum1;
    

    
    
  py::class_<typename cs::UsbCamera, cs::VideoCamera> cls_UsbCamera;

    

    
    
  py::class_<typename cs::HttpCamera, cs::VideoCamera> cls_HttpCamera;

    
    
  py::enum_<cs::HttpCamera::HttpCameraKind> cls_HttpCamera_enum1;
    

    
    
  py::class_<typename cs::AxisCamera, cs::HttpCamera> cls_AxisCamera;

    

    
    
  py::class_<typename cs::ImageSource, cs::VideoSource> cls_ImageSource;

    

    
    
  py::class_<typename cs::VideoSink> cls_VideoSink;

    
    
  py::enum_<cs::VideoSink::Kind> cls_VideoSink_enum1;
    

    
    
  py::class_<typename cs::MjpegServer, cs::VideoSink> cls_MjpegServer;

    

    
    
  py::class_<typename cs::ImageSink, cs::VideoSink> cls_ImageSink;

    

    
    
  py::class_<typename cs::VideoEvent, cs::RawEvent> cls_VideoEvent;

    

    
    
  py::class_<typename cs::VideoListener> cls_VideoListener;

    

    
    

  py::module &m;

  
  rpybuild_cscore_oo_initializer(py::module &m) :

  

  

  

  
    cls_VideoProperty(m, "VideoProperty"),

  
    cls_VideoProperty_enum1
  (cls_VideoProperty, "Kind"
  ),
  

  
  
  
    cls_VideoSource(m, "VideoSource"),

  
    cls_VideoSource_enum1
  (cls_VideoSource, "Kind"
  ,
    "Video source kind."),
  
    cls_VideoSource_enum2
  (cls_VideoSource, "ConnectionStrategy"
  ,
    "Connection strategy.  Used for SetConnectionStrategy()."),
  

  
  
  
    cls_VideoCamera(m, "VideoCamera"),

  
    cls_VideoCamera_enum1
  (cls_VideoCamera, "WhiteBalance"
  ,
    "White balance."),
  

  
  
  
    cls_UsbCamera(m, "UsbCamera"),

  

  
  
  
    cls_HttpCamera(m, "HttpCamera"),

  
    cls_HttpCamera_enum1
  (cls_HttpCamera, "HttpCameraKind"
  ,
    "HTTP camera kind."),
  

  
  
  
    cls_AxisCamera(m, "AxisCamera"),

  

  
  
  
    cls_ImageSource(m, "ImageSource"),

  

  
  
  
    cls_VideoSink(m, "VideoSink"),

  
    cls_VideoSink_enum1
  (cls_VideoSink, "Kind"
  ),
  

  
  
  
    cls_MjpegServer(m, "MjpegServer"),

  

  
  
  
    cls_ImageSink(m, "ImageSink"),

  

  
  
  
    cls_VideoEvent(m, "VideoEvent"),

  

  
  
  
    cls_VideoListener(m, "VideoListener"),

  

  
  
  

    m(m)
  {
    
    

    
    
  
    cls_VideoProperty_enum1
  
    .value("kNone", cs::VideoProperty::Kind::kNone,
      "No specific property.")
  
    .value("kBoolean", cs::VideoProperty::Kind::kBoolean,
      "Boolean property.")
  
    .value("kInteger", cs::VideoProperty::Kind::kInteger,
      "Integer property.")
  
    .value("kString", cs::VideoProperty::Kind::kString,
      "String property.")
  
    .value("kEnum", cs::VideoProperty::Kind::kEnum,
      "Enum property.")
  ;

  

    
    
    
  
    cls_VideoSource_enum1
  
    .value("kUnknown", cs::VideoSource::Kind::kUnknown,
      "Unknown video source.")
  
    .value("kUsb", cs::VideoSource::Kind::kUsb,
      "USB video source.")
  
    .value("kHttp", cs::VideoSource::Kind::kHttp,
      "HTTP video source.")
  
    .value("kCv", cs::VideoSource::Kind::kCv,
      "CV video source.")
  ;

  
    cls_VideoSource_enum2
  
    .value("kConnectionAutoManage", cs::VideoSource::ConnectionStrategy::kConnectionAutoManage,
      "Automatically connect or disconnect based on whether any sinks are\n"
"connected to this source.  This is the default behavior.")
  
    .value("kConnectionKeepOpen", cs::VideoSource::ConnectionStrategy::kConnectionKeepOpen,
      "Try to keep the connection open regardless of whether any sinks are\n"
"connected.")
  
    .value("kConnectionForceClose", cs::VideoSource::ConnectionStrategy::kConnectionForceClose,
      "Never open the connection.  If this is set when the connection is open,\n"
"close the connection.")
  ;

  

    
    
    
  
    cls_VideoCamera_enum1
  
    .value("kFixedIndoor", cs::VideoCamera::WhiteBalance::kFixedIndoor,
      "Fixed indoor white balance.")
  
    .value("kFixedOutdoor1", cs::VideoCamera::WhiteBalance::kFixedOutdoor1,
      "Fixed outdoor white balance 1.")
  
    .value("kFixedOutdoor2", cs::VideoCamera::WhiteBalance::kFixedOutdoor2,
      "Fixed outdoor white balance 2.")
  
    .value("kFixedFluorescent1", cs::VideoCamera::WhiteBalance::kFixedFluorescent1,
      "Fixed fluorescent white balance 1.")
  
    .value("kFixedFlourescent2", cs::VideoCamera::WhiteBalance::kFixedFlourescent2,
      "Fixed fluorescent white balance 2.")
  ;

  

    
    
    
  

    
    
    
  
    cls_HttpCamera_enum1
  
    .value("kUnknown", cs::HttpCamera::HttpCameraKind::kUnknown,
      "Unknown camera kind.")
  
    .value("kMJPGStreamer", cs::HttpCamera::HttpCameraKind::kMJPGStreamer,
      "MJPG Streamer camera.")
  
    .value("kCSCore", cs::HttpCamera::HttpCameraKind::kCSCore,
      "CS Core camera.")
  
    .value("kAxis", cs::HttpCamera::HttpCameraKind::kAxis,
      "Axis camera.")
  ;

  

    
    
    
  

    
    
    
  

    
    
    
  
    cls_VideoSink_enum1
  
    .value("kUnknown", cs::VideoSink::Kind::kUnknown,
      "Unknown sink type.")
  
    .value("kMjpeg", cs::VideoSink::Kind::kMjpeg,
      "MJPEG video sink.")
  
    .value("kCv", cs::VideoSink::Kind::kCv,
      "CV video sink.")
  ;

  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
  }

void finish() {





  {
  
  
  using Kind [[maybe_unused]] = typename cs::VideoProperty::Kind;
  
  


  

  cls_VideoProperty.doc() =
    "A source or sink property.";

  cls_VideoProperty
  
    
  .def(py::init<>(), release_gil()
  )
  
  
  
    
  .
def
("getName", &cs::VideoProperty::GetName, release_gil(), py::doc(
    "Returns property name.\n"
"\n"
":returns: Property name.")
  )
  
  
  
    
  .
def
("getKind", &cs::VideoProperty::GetKind, release_gil(), py::doc(
    "Returns property kind.\n"
"\n"
":returns: Property kind.")
  )
  
  
  
    
  .
def
("isBoolean", &cs::VideoProperty::IsBoolean, release_gil(), py::doc(
    "Returns true if property is a boolean.\n"
"\n"
":returns: True if property is a boolean.")
  )
  
  
  
    
  .
def
("isInteger", &cs::VideoProperty::IsInteger, release_gil(), py::doc(
    "Returns true if property is an integer.\n"
"\n"
":returns: True if property is an integer.")
  )
  
  
  
    
  .
def
("isString", &cs::VideoProperty::IsString, release_gil(), py::doc(
    "Returns true if property is a string.\n"
"\n"
":returns: True if property is a string.")
  )
  
  
  
    
  .
def
("isEnum", &cs::VideoProperty::IsEnum, release_gil(), py::doc(
    "Returns true if property is an enum.\n"
"\n"
":returns: True if property is an enum.")
  )
  
  
  
    
  .
def
("get", &cs::VideoProperty::Get, release_gil(), py::doc(
    "Returns property value.\n"
"\n"
":returns: Property value.")
  )
  
  
  
    
  .
def
("set", &cs::VideoProperty::Set,
      py::arg("value"), release_gil(), py::doc(
    "Sets property value.\n"
"\n"
":param value: Property value.")
  )
  
  
  
    
  .
def
("getMin", &cs::VideoProperty::GetMin, release_gil(), py::doc(
    "Returns property minimum value.\n"
"\n"
":returns: Property minimum value.")
  )
  
  
  
    
  .
def
("getMax", &cs::VideoProperty::GetMax, release_gil(), py::doc(
    "Returns property maximum value.\n"
"\n"
":returns: Property maximum value.")
  )
  
  
  
    
  .
def
("getStep", &cs::VideoProperty::GetStep, release_gil(), py::doc(
    "Returns property step size.\n"
"\n"
":returns: Property step size.")
  )
  
  
  
    
  .
def
("getDefault", &cs::VideoProperty::GetDefault, release_gil(), py::doc(
    "Returns property default value.\n"
"\n"
":returns: Property default value.")
  )
  
  
  
    
  .
def
("getString", static_cast<std::string(cs::VideoProperty::*)() const>(
        &cs::VideoProperty::GetString), release_gil(), py::doc(
    "Returns the string property value.\n"
"\n"
"This function is string-specific.\n"
"\n"
":returns: The string property value.")
  )
  
  
  
    
  .
def
("getString", static_cast<std::string_view(cs::VideoProperty::*)(wpi::SmallVectorImpl<char>&) const>(
        &cs::VideoProperty::GetString),
      py::arg("buf"), release_gil(), py::doc(
    "Returns the string property value as a reference to the given buffer.\n"
"\n"
"This function is string-specific.\n"
"\n"
":param buf: The backing storage to which to write the property value.\n"
"\n"
":returns: The string property value as a reference to the given buffer.")
  )
  
  
  
    
  .
def
("setString", &cs::VideoProperty::SetString,
      py::arg("value"), release_gil(), py::doc(
    "Sets the string property value.\n"
"\n"
"This function is string-specific.\n"
"\n"
":param value: String property value.")
  )
  
  
  
    
  .
def
("getChoices", &cs::VideoProperty::GetChoices, release_gil(), py::doc(
    "Returns the possible values for the enum property value.\n"
"\n"
"This function is enum-specific.\n"
"\n"
":returns: The possible values for the enum property value.")
  )
  
  
  
    
  .
def
("getLastStatus", &cs::VideoProperty::GetLastStatus, release_gil(), py::doc(
    "Returns the last status.\n"
"\n"
":returns: The last status.")
  )
  
  
  ;

  


  }

  {
  
  
  using Kind [[maybe_unused]] = typename cs::VideoSource::Kind;
  
  using ConnectionStrategy [[maybe_unused]] = typename cs::VideoSource::ConnectionStrategy;
  
  


  

  cls_VideoSource.doc() =
    "A source for video that provides a sequence of frames.";

  cls_VideoSource
  
    
  .def(py::init<>(), release_gil()
  )
  
  
  
    
  .
def
("getHandle", &cs::VideoSource::GetHandle, release_gil()
  )
  
  
  
    
  .def(py::self == py::self
  )
  
  
  
    
  .
def
("getKind", &cs::VideoSource::GetKind, release_gil(), py::doc(
    "Get the kind of the source.")
  )
  
  
  
    
  .
def
("getName", &cs::VideoSource::GetName, release_gil(), py::doc(
    "Get the name of the source.  The name is an arbitrary identifier\n"
"provided when the source is created, and should be unique.")
  )
  
  
  
    
  .
def
("getDescription", &cs::VideoSource::GetDescription, release_gil(), py::doc(
    "Get the source description.  This is source-kind specific.")
  )
  
  
  
    
  .
def
("getLastFrameTime", &cs::VideoSource::GetLastFrameTime, release_gil(), py::doc(
    "Get the last time a frame was captured.\n"
"This uses the same time base as wpi::Now().\n"
"\n"
":returns: Time in 1 us increments.")
  )
  
  
  
    
  .
def
("setConnectionStrategy", &cs::VideoSource::SetConnectionStrategy,
      py::arg("strategy"), release_gil(), py::doc(
    "Sets the connection strategy.  By default, the source will automatically\n"
"connect or disconnect based on whether any sinks are connected.\n"
"\n"
"This function is non-blocking; look for either a connection open or\n"
"close event or call IsConnected() to determine the connection state.\n"
"\n"
":param strategy: connection strategy (auto, keep open, or force close)")
  )
  
  
  
    
  .
def
("isConnected", &cs::VideoSource::IsConnected, release_gil(), py::doc(
    "Is the source currently connected to whatever is providing the images?")
  )
  
  
  
    
  .
def
("isEnabled", &cs::VideoSource::IsEnabled, release_gil(), py::doc(
    "Gets source enable status.  This is determined with a combination of\n"
"connection strategy and the number of sinks connected.\n"
"\n"
":returns: True if enabled, false otherwise.")
  )
  
  
  
    
  .
def
("getProperty", &cs::VideoSource::GetProperty,
      py::arg("name"), release_gil(), py::doc(
    "Get a property.\n"
"\n"
":param name: Property name\n"
"\n"
":returns: Property contents (of kind Property::kNone if no property with\n"
"          the given name exists)")
  )
  
  
  
    
  .
def
("enumerateProperties", &cs::VideoSource::EnumerateProperties, release_gil(), py::doc(
    "Enumerate all properties of this source.")
  )
  
  
  
    
  .
def
("getVideoMode", &cs::VideoSource::GetVideoMode, release_gil(), py::doc(
    "Get the current video mode.")
  )
  
  
  
    
  .
def
("setVideoMode", static_cast<bool(cs::VideoSource::*)(const VideoMode&)>(
        &cs::VideoSource::SetVideoMode),
      py::arg("mode"), release_gil(), py::doc(
    "Set the video mode.\n"
"\n"
":param mode: Video mode")
  )
  
  
  
    
  .
def
("setVideoMode", static_cast<bool(cs::VideoSource::*)(VideoMode::PixelFormat, int, int, int)>(
        &cs::VideoSource::SetVideoMode),
      py::arg("pixelFormat"), py::arg("width"), py::arg("height"), py::arg("fps"), release_gil(), py::doc(
    "Set the video mode.\n"
"\n"
":param pixelFormat: desired pixel format\n"
":param width:       desired width\n"
":param height:      desired height\n"
":param fps:         desired FPS\n"
"\n"
":returns: True if set successfully")
  )
  
  
  
    
  .
def
("setPixelFormat", &cs::VideoSource::SetPixelFormat,
      py::arg("pixelFormat"), release_gil(), py::doc(
    "Set the pixel format.\n"
"\n"
":param pixelFormat: desired pixel format\n"
"\n"
":returns: True if set successfully")
  )
  
  
  
    
  .
def
("setResolution", &cs::VideoSource::SetResolution,
      py::arg("width"), py::arg("height"), release_gil(), py::doc(
    "Set the resolution.\n"
"\n"
":param width:  desired width\n"
":param height: desired height\n"
"\n"
":returns: True if set successfully")
  )
  
  
  
    
  .
def
("setFPS", &cs::VideoSource::SetFPS,
      py::arg("fps"), release_gil(), py::doc(
    "Set the frames per second (FPS).\n"
"\n"
":param fps: desired FPS\n"
"\n"
":returns: True if set successfully")
  )
  
  
  
    
  .
def
("setConfigJson", static_cast<bool(cs::VideoSource::*)(std::string_view)>(
        &cs::VideoSource::SetConfigJson),
      py::arg("config"), release_gil(), py::doc(
    "Set video mode and properties from a JSON configuration string.\n"
"\n"
"The format of the JSON input is:\n"
"\n"
"::\n"
"\n"
"  {\n"
"      \"pixel format\": \"MJPEG\", \"YUYV\", etc\n"
"      \"width\": video mode width\n"
"      \"height\": video mode height\n"
"      \"fps\": video mode fps\n"
"      \"brightness\": percentage brightness\n"
"      \"white balance\": \"auto\", \"hold\", or value\n"
"      \"exposure\": \"auto\", \"hold\", or value\n"
"      \"properties\": [\n"
"          {\n"
"              \"name\": property name\n"
"              \"value\": property value\n"
"          }\n"
"      ]\n"
"  }\n"
"\n"
":param config: configuration\n"
"\n"
":returns: True if set successfully")
  )
  
  
  
    
  .
def
("setConfigJson", static_cast<bool(cs::VideoSource::*)(const wpi::json&)>(
        &cs::VideoSource::SetConfigJson),
      py::arg("config"), release_gil(), py::doc(
    "Set video mode and properties from a JSON configuration object.\n"
"\n"
":param config: configuration\n"
"\n"
":returns: True if set successfully")
  )
  
  
  
    
  .
def
("getConfigJson", &cs::VideoSource::GetConfigJson, release_gil(), py::doc(
    "Get a JSON configuration string.\n"
"\n"
":returns: JSON configuration string")
  )
  
  
  
    
  .
def
("getConfigJsonObject", &cs::VideoSource::GetConfigJsonObject, release_gil(), py::doc(
    "Get a JSON configuration object.\n"
"\n"
":returns: JSON configuration object")
  )
  
  
  
    
  .
def
("getActualFPS", &cs::VideoSource::GetActualFPS, release_gil(), py::doc(
    "Get the actual FPS.\n"
"\n"
"SetTelemetryPeriod() must be called for this to be valid.\n"
"\n"
":returns: Actual FPS averaged over the telemetry period.")
  )
  
  
  
    
  .
def
("getActualDataRate", &cs::VideoSource::GetActualDataRate, release_gil(), py::doc(
    "Get the data rate (in bytes per second).\n"
"\n"
"SetTelemetryPeriod() must be called for this to be valid.\n"
"\n"
":returns: Data rate averaged over the telemetry period.")
  )
  
  
  
    
  .
def
("enumerateVideoModes", &cs::VideoSource::EnumerateVideoModes, release_gil(), py::doc(
    "Enumerate all known video modes for this source.")
  )
  
  
  
    
  .
def
("getLastStatus", &cs::VideoSource::GetLastStatus, release_gil()
  )
  
  
  
    
  .
def
("enumerateSinks", &cs::VideoSource::EnumerateSinks, release_gil(), py::doc(
    "Enumerate all sinks connected to this source.\n"
"\n"
":returns: Vector of sinks.")
  )
  
  
  
    
  .
def_static
("enumerateSources", &cs::VideoSource::EnumerateSources, release_gil(), py::doc(
    "Enumerate all existing sources.\n"
"\n"
":returns: Vector of sources.")
  )
  
  
  ;

  


  }

  {
  
  
  using WhiteBalance [[maybe_unused]] = typename cs::VideoCamera::WhiteBalance;
  
  


  

  cls_VideoCamera.doc() =
    "A source that represents a video camera.";

  cls_VideoCamera
  
    
  .def(py::init<>(), release_gil()
  )
  
  
  
    
  .
def
("setBrightness", &cs::VideoCamera::SetBrightness,
      py::arg("brightness"), release_gil(), py::doc(
    "Set the brightness, as a percentage (0-100).")
  )
  
  
  
    
  .
def
("getBrightness", &cs::VideoCamera::GetBrightness, release_gil(), py::doc(
    "Get the brightness, as a percentage (0-100).")
  )
  
  
  
    
  .
def
("setWhiteBalanceAuto", &cs::VideoCamera::SetWhiteBalanceAuto, release_gil(), py::doc(
    "Set the white balance to auto.")
  )
  
  
  
    
  .
def
("setWhiteBalanceHoldCurrent", &cs::VideoCamera::SetWhiteBalanceHoldCurrent, release_gil(), py::doc(
    "Set the white balance to hold current.")
  )
  
  
  
    
  .
def
("setWhiteBalanceManual", &cs::VideoCamera::SetWhiteBalanceManual,
      py::arg("value"), release_gil(), py::doc(
    "Set the white balance to manual, with specified color temperature.")
  )
  
  
  
    
  .
def
("setExposureAuto", &cs::VideoCamera::SetExposureAuto, release_gil(), py::doc(
    "Set the exposure to auto aperature.")
  )
  
  
  
    
  .
def
("setExposureHoldCurrent", &cs::VideoCamera::SetExposureHoldCurrent, release_gil(), py::doc(
    "Set the exposure to hold current.")
  )
  
  
  
    
  .
def
("setExposureManual", &cs::VideoCamera::SetExposureManual,
      py::arg("value"), release_gil(), py::doc(
    "Set the exposure to manual, as a percentage (0-100).")
  )
  
  
  ;

  


  }

  {
  
  
  


  

  cls_UsbCamera.doc() =
    "A source that represents a USB camera.";

  cls_UsbCamera
  
    
  .def(py::init<>(), release_gil()
  )
  
  
  
    
  .def(py::init<std::string_view, int>(),
      py::arg("name"), py::arg("dev"), release_gil(), py::doc(
    "Create a source for a USB camera based on device number.\n"
"\n"
":param name: Source name (arbitrary unique identifier)\n"
":param dev:  Device number (e.g. 0 for /dev/video0)")
  )
  
  
  
    
  .def(py::init<std::string_view, std::string_view>(),
      py::arg("name"), py::arg("path"), release_gil(), py::doc(
    "Create a source for a USB camera based on device path.\n"
"\n"
":param name: Source name (arbitrary unique identifier)\n"
":param path: Path to device (e.g. \"/dev/video0\" on Linux)")
  )
  
  
  
    
  .
def_static
("enumerateUsbCameras", &cs::UsbCamera::EnumerateUsbCameras, release_gil(), py::doc(
    "Enumerate USB cameras on the local system.\n"
"\n"
":returns: Vector of USB camera information (one for each camera)")
  )
  
  
  
    
  .
def
("setPath", &cs::UsbCamera::SetPath,
      py::arg("path"), release_gil(), py::doc(
    "Change the path to the device.")
  )
  
  
  
    
  .
def
("getPath", &cs::UsbCamera::GetPath, release_gil(), py::doc(
    "Get the path to the device.")
  )
  
  
  
    
  .
def
("getInfo", &cs::UsbCamera::GetInfo, release_gil(), py::doc(
    "Get the full camera information for the device.")
  )
  
  
  
    
  .
def
("setConnectVerbose", &cs::UsbCamera::SetConnectVerbose,
      py::arg("level"), release_gil(), py::doc(
    "Set how verbose the camera connection messages are.\n"
"\n"
":param level: 0=don't display Connecting message, 1=do display message")
  )
  
  
  ;

  


  }

  {
  
  
  using HttpCameraKind [[maybe_unused]] = typename cs::HttpCamera::HttpCameraKind;
  
  


  

  cls_HttpCamera.doc() =
    "A source that represents a MJPEG-over-HTTP (IP) camera.";

  cls_HttpCamera
  
    
  .def(py::init<std::string_view, std::string_view, HttpCameraKind>(),
      py::arg("name"), py::arg("url"), py::arg("kind") = kUnknown, release_gil(), py::doc(
    "Create a source for a MJPEG-over-HTTP (IP) camera.\n"
"\n"
":param name: Source name (arbitrary unique identifier)\n"
":param url:  Camera URL (e.g. \"http://10.x.y.11/video/stream.mjpg\")\n"
":param kind: Camera kind (e.g. kAxis)")
  )
  
  
  
    
  .def(py::init<std::string_view, const char*, HttpCameraKind>(),
      py::arg("name"), py::arg("url"), py::arg("kind") = kUnknown, release_gil(), py::doc(
    "Create a source for a MJPEG-over-HTTP (IP) camera.\n"
"\n"
":param name: Source name (arbitrary unique identifier)\n"
":param url:  Camera URL (e.g. \"http://10.x.y.11/video/stream.mjpg\")\n"
":param kind: Camera kind (e.g. kAxis)")
  )
  
  
  
    
  .def(py::init<std::string_view, const std::string&, HttpCameraKind>(),
      py::arg("name"), py::arg("url"), py::arg("kind") = kUnknown, release_gil()
    , py::keep_alive<1, 3>(), py::doc(
    "Create a source for a MJPEG-over-HTTP (IP) camera.\n"
"\n"
":param name: Source name (arbitrary unique identifier)\n"
":param url:  Camera URL (e.g. \"http://10.x.y.11/video/stream.mjpg\")\n"
":param kind: Camera kind (e.g. kAxis)")
  )
  
  
  
    
  .def(py::init<std::string_view, std::span<const std::string>, HttpCameraKind>(),
      py::arg("name"), py::arg("urls"), py::arg("kind") = kUnknown, release_gil(), py::doc(
    "Create a source for a MJPEG-over-HTTP (IP) camera.\n"
"\n"
":param name: Source name (arbitrary unique identifier)\n"
":param urls: Array of Camera URLs\n"
":param kind: Camera kind (e.g. kAxis)")
  )
  
  
  
    
  .
def
("getHttpCameraKind", &cs::HttpCamera::GetHttpCameraKind, release_gil(), py::doc(
    "Get the kind of HTTP camera.\n"
"\n"
"Autodetection can result in returning a different value than the camera\n"
"was created with.")
  )
  
  
  
    
  .
def
("setUrls", static_cast<void(cs::HttpCamera::*)(std::span<const std::string>)>(
        &cs::HttpCamera::SetUrls),
      py::arg("urls"), release_gil(), py::doc(
    "Change the URLs used to connect to the camera.")
  )
  
  
  
    
  .
def
("getUrls", &cs::HttpCamera::GetUrls, release_gil(), py::doc(
    "Get the URLs used to connect to the camera.")
  )
  
  
  ;

  


  }

  {
  
  
  


  

  cls_AxisCamera.doc() =
    "A source that represents an Axis IP camera.";

  cls_AxisCamera
  
    
  .def(py::init<std::string_view, std::string_view>(),
      py::arg("name"), py::arg("host"), release_gil(), py::doc(
    "Create a source for an Axis IP camera.\n"
"\n"
":param name: Source name (arbitrary unique identifier)\n"
":param host: Camera host IP or DNS name (e.g. \"10.x.y.11\")")
  )
  
  
  
    
  .def(py::init<std::string_view, const char*>(),
      py::arg("name"), py::arg("host"), release_gil(), py::doc(
    "Create a source for an Axis IP camera.\n"
"\n"
":param name: Source name (arbitrary unique identifier)\n"
":param host: Camera host IP or DNS name (e.g. \"10.x.y.11\")")
  )
  
  
  
    
  .def(py::init<std::string_view, const std::string&>(),
      py::arg("name"), py::arg("host"), release_gil()
    , py::keep_alive<1, 3>(), py::doc(
    "Create a source for an Axis IP camera.\n"
"\n"
":param name: Source name (arbitrary unique identifier)\n"
":param host: Camera host IP or DNS name (e.g. \"10.x.y.11\")")
  )
  
  
  
    
  .def(py::init<std::string_view, std::span<const std::string>>(),
      py::arg("name"), py::arg("hosts"), release_gil(), py::doc(
    "Create a source for an Axis IP camera.\n"
"\n"
":param name:  Source name (arbitrary unique identifier)\n"
":param hosts: Array of Camera host IPs/DNS names")
  )
  
  
  ;

  


  }

  {
  
  
  


  

  cls_ImageSource.doc() =
    "A base class for single image providing sources.";

  cls_ImageSource
  
    
  .
def
("notifyError", &cs::ImageSource::NotifyError,
      py::arg("msg"), release_gil(), py::doc(
    "Signal sinks that an error has occurred.  This should be called instead\n"
"of NotifyFrame when an error occurs.\n"
"\n"
":param msg: Notification message.")
  )
  
  
  
    
  .
def
("setConnected", &cs::ImageSource::SetConnected,
      py::arg("connected"), release_gil(), py::doc(
    "Set source connection status.  Defaults to true.\n"
"\n"
":param connected: True for connected, false for disconnected")
  )
  
  
  
    
  .
def
("setDescription", &cs::ImageSource::SetDescription,
      py::arg("description"), release_gil(), py::doc(
    "Set source description.\n"
"\n"
":param description: Description")
  )
  
  
  
    
  .
def
("createProperty", &cs::ImageSource::CreateProperty,
      py::arg("name"), py::arg("kind"), py::arg("minimum"), py::arg("maximum"), py::arg("step"), py::arg("defaultValue"), py::arg("value"), release_gil(), py::doc(
    "Create a property.\n"
"\n"
":param name:         Property name\n"
":param kind:         Property kind\n"
":param minimum:      Minimum value\n"
":param maximum:      Maximum value\n"
":param step:         Step value\n"
":param defaultValue: Default value\n"
":param value:        Current value\n"
"\n"
":returns: Property")
  )
  
  
  
    
  .
def
("createIntegerProperty", &cs::ImageSource::CreateIntegerProperty,
      py::arg("name"), py::arg("minimum"), py::arg("maximum"), py::arg("step"), py::arg("defaultValue"), py::arg("value"), release_gil(), py::doc(
    "Create an integer property.\n"
"\n"
":param name:         Property name\n"
":param minimum:      Minimum value\n"
":param maximum:      Maximum value\n"
":param step:         Step value\n"
":param defaultValue: Default value\n"
":param value:        Current value\n"
"\n"
":returns: Property")
  )
  
  
  
    
  .
def
("createBooleanProperty", &cs::ImageSource::CreateBooleanProperty,
      py::arg("name"), py::arg("defaultValue"), py::arg("value"), release_gil(), py::doc(
    "Create a boolean property.\n"
"\n"
":param name:         Property name\n"
":param defaultValue: Default value\n"
":param value:        Current value\n"
"\n"
":returns: Property")
  )
  
  
  
    
  .
def
("createStringProperty", &cs::ImageSource::CreateStringProperty,
      py::arg("name"), py::arg("value"), release_gil(), py::doc(
    "Create a string property.\n"
"\n"
":param name:  Property name\n"
":param value: Current value\n"
"\n"
":returns: Property")
  )
  
  
  
    
  .
def
("setEnumPropertyChoices", static_cast<void(cs::ImageSource::*)(const VideoProperty&, std::span<const std::string>)>(
        &cs::ImageSource::SetEnumPropertyChoices),
      py::arg("property"), py::arg("choices"), release_gil(), py::doc(
    "Configure enum property choices.\n"
"\n"
":param property: Property\n"
":param choices:  Choices")
  )
  
  
  ;

  


  }

  {
  
  
  using Kind [[maybe_unused]] = typename cs::VideoSink::Kind;
  
  


  

  cls_VideoSink.doc() =
    "A sink for video that accepts a sequence of frames.";

  cls_VideoSink
  
    
  .def(py::init<>(), release_gil()
  )
  
  
  
    
  .
def
("getHandle", &cs::VideoSink::GetHandle, release_gil(), py::doc(
    "Returns the VideoSink handle.\n"
"\n"
":returns: The VideoSink handle.")
  )
  
  
  
    
  .def(py::self == py::self
  )
  
  
  
    
  .
def
("getKind", &cs::VideoSink::GetKind, release_gil(), py::doc(
    "Get the kind of the sink.")
  )
  
  
  
    
  .
def
("getName", &cs::VideoSink::GetName, release_gil(), py::doc(
    "Get the name of the sink.  The name is an arbitrary identifier\n"
"provided when the sink is created, and should be unique.")
  )
  
  
  
    
  .
def
("getDescription", &cs::VideoSink::GetDescription, release_gil(), py::doc(
    "Get the sink description.  This is sink-kind specific.")
  )
  
  
  
    
  .
def
("getProperty", &cs::VideoSink::GetProperty,
      py::arg("name"), release_gil(), py::doc(
    "Get a property of the sink.\n"
"\n"
":param name: Property name\n"
"\n"
":returns: Property (kind Property::kNone if no property with\n"
"          the given name exists)")
  )
  
  
  
    
  .
def
("enumerateProperties", &cs::VideoSink::EnumerateProperties, release_gil(), py::doc(
    "Enumerate all properties of this sink.")
  )
  
  
  
    
  .
def
("setConfigJson", static_cast<bool(cs::VideoSink::*)(std::string_view)>(
        &cs::VideoSink::SetConfigJson),
      py::arg("config"), release_gil(), py::doc(
    "Set properties from a JSON configuration string.\n"
"\n"
"The format of the JSON input is:\n"
"\n"
"::\n"
"\n"
"  {\n"
"      \"properties\": [\n"
"          {\n"
"              \"name\": property name\n"
"              \"value\": property value\n"
"          }\n"
"      ]\n"
"  }\n"
"\n"
":param config: configuration\n"
"\n"
":returns: True if set successfully")
  )
  
  
  
    
  .
def
("setConfigJson", static_cast<bool(cs::VideoSink::*)(const wpi::json&)>(
        &cs::VideoSink::SetConfigJson),
      py::arg("config"), release_gil(), py::doc(
    "Set properties from a JSON configuration object.\n"
"\n"
":param config: configuration\n"
"\n"
":returns: True if set successfully")
  )
  
  
  
    
  .
def
("getConfigJson", &cs::VideoSink::GetConfigJson, release_gil(), py::doc(
    "Get a JSON configuration string.\n"
"\n"
":returns: JSON configuration string")
  )
  
  
  
    
  .
def
("getConfigJsonObject", &cs::VideoSink::GetConfigJsonObject, release_gil(), py::doc(
    "Get a JSON configuration object.\n"
"\n"
":returns: JSON configuration object")
  )
  
  
  
    
  .
def
("setSource", &cs::VideoSink::SetSource,
      py::arg("source"), release_gil(), py::doc(
    "Configure which source should provide frames to this sink.  Each sink\n"
"can accept frames from only a single source, but a single source can\n"
"provide frames to multiple clients.\n"
"\n"
":param source: Source")
  )
  
  
  
    
  .
def
("getSource", &cs::VideoSink::GetSource, release_gil(), py::doc(
    "Get the connected source.\n"
"\n"
":returns: Connected source (empty if none connected).")
  )
  
  
  
    
  .
def
("getSourceProperty", &cs::VideoSink::GetSourceProperty,
      py::arg("name"), release_gil(), py::doc(
    "Get a property of the associated source.\n"
"\n"
":param name: Property name\n"
"\n"
":returns: Property (kind Property::kNone if no property with\n"
"          the given name exists or no source connected)")
  )
  
  
  
    
  .
def
("getLastStatus", &cs::VideoSink::GetLastStatus, release_gil()
  )
  
  
  
    
  .
def_static
("enumerateSinks", &cs::VideoSink::EnumerateSinks, release_gil(), py::doc(
    "Enumerate all existing sinks.\n"
"\n"
":returns: Vector of sinks.")
  )
  
  
  ;

  


  }

  {
  
  
  


  

  cls_MjpegServer.doc() =
    "A sink that acts as a MJPEG-over-HTTP network server.";

  cls_MjpegServer
  
    
  .def(py::init<>(), release_gil()
  )
  
  
  
    
  .def(py::init<std::string_view, std::string_view, int>(),
      py::arg("name"), py::arg("listenAddress"), py::arg("port"), release_gil(), py::doc(
    "Create a MJPEG-over-HTTP server sink.\n"
"\n"
":param name:          Sink name (arbitrary unique identifier)\n"
":param listenAddress: TCP listen address (empty string for all addresses)\n"
":param port:          TCP port number")
  )
  
  
  
    
  .def(py::init<std::string_view, int>(),
      py::arg("name"), py::arg("port"), release_gil(), py::doc(
    "Create a MJPEG-over-HTTP server sink.\n"
"\n"
":param name: Sink name (arbitrary unique identifier)\n"
":param port: TCP port number")
  )
  
  
  
    
  .
def
("getListenAddress", &cs::MjpegServer::GetListenAddress, release_gil(), py::doc(
    "Get the listen address of the server.")
  )
  
  
  
    
  .
def
("getPort", &cs::MjpegServer::GetPort, release_gil(), py::doc(
    "Get the port number of the server.")
  )
  
  
  
    
  .
def
("setResolution", &cs::MjpegServer::SetResolution,
      py::arg("width"), py::arg("height"), release_gil(), py::doc(
    "Set the stream resolution for clients that don't specify it.\n"
"\n"
"It is not necessary to set this if it is the same as the source\n"
"resolution.\n"
"\n"
"Setting this different than the source resolution will result in\n"
"increased CPU usage, particularly for MJPEG source cameras, as it will\n"
"decompress, resize, and recompress the image, instead of using the\n"
"camera's MJPEG image directly.\n"
"\n"
":param width:  width, 0 for unspecified\n"
":param height: height, 0 for unspecified")
  )
  
  
  
    
  .
def
("setFPS", &cs::MjpegServer::SetFPS,
      py::arg("fps"), release_gil(), py::doc(
    "Set the stream frames per second (FPS) for clients that don't specify it.\n"
"\n"
"It is not necessary to set this if it is the same as the source FPS.\n"
"\n"
":param fps: FPS, 0 for unspecified")
  )
  
  
  
    
  .
def
("setCompression", &cs::MjpegServer::SetCompression,
      py::arg("quality"), release_gil(), py::doc(
    "Set the compression for clients that don't specify it.\n"
"\n"
"Setting this will result in increased CPU usage for MJPEG source cameras\n"
"as it will decompress and recompress the image instead of using the\n"
"camera's MJPEG image directly.\n"
"\n"
":param quality: JPEG compression quality (0-100), -1 for unspecified")
  )
  
  
  
    
  .
def
("setDefaultCompression", &cs::MjpegServer::SetDefaultCompression,
      py::arg("quality"), release_gil(), py::doc(
    "Set the default compression used for non-MJPEG sources.  If not set,\n"
"80 is used.  This function has no effect on MJPEG source cameras; use\n"
"SetCompression() instead to force recompression of MJPEG source images.\n"
"\n"
":param quality: JPEG compression quality (0-100)")
  )
  
  
  ;

  


  }

  {
  
  
  


  

  cls_ImageSink.doc() =
    "A base class for single image reading sinks.";

  cls_ImageSink
  
    
  .
def
("setDescription", &cs::ImageSink::SetDescription,
      py::arg("description"), release_gil(), py::doc(
    "Set sink description.\n"
"\n"
":param description: Description")
  )
  
  
  
    
  .
def
("getError", &cs::ImageSink::GetError, release_gil(), py::doc(
    "Get error string.  Call this if WaitForFrame() returns 0 to determine\n"
"what the error is.")
  )
  
  
  
    
  .
def
("setEnabled", &cs::ImageSink::SetEnabled,
      py::arg("enabled"), release_gil(), py::doc(
    "Enable or disable getting new frames.\n"
"\n"
"Disabling will cause processFrame (for callback-based CvSinks) to not\n"
"be called and WaitForFrame() to not return.  This can be used to save\n"
"processor resources when frames are not needed.")
  )
  
  
  ;

  


  }

  {
  
  
  


  

  cls_VideoEvent.doc() =
    "An event generated by the library and provided to event listeners.";

  cls_VideoEvent
  
    .def(py::init<>(), release_gil())
  
    
  .
def
("getSource", &cs::VideoEvent::GetSource, release_gil(), py::doc(
    "Returns the source associated with the event (if any).\n"
"\n"
":returns: The source associated with the event (if any).")
  )
  
  
  
    
  .
def
("getSink", &cs::VideoEvent::GetSink, release_gil(), py::doc(
    "Returns the sink associated with the event (if any).\n"
"\n"
":returns: The sink associated with the event (if any).")
  )
  
  
  
    
  .
def
("getProperty", &cs::VideoEvent::GetProperty, release_gil(), py::doc(
    "Returns the property associated with the event (if any).\n"
"\n"
":returns: The property associated with the event (if any).")
  )
  
  
  ;

  


  }

  {
  
  
  


  

  cls_VideoListener.doc() =
    "An event listener.  This calls back to a desigated callback function when\n"
"an event matching the specified mask is generated by the library.";

  cls_VideoListener
  
    
  .def(py::init<>(), release_gil()
  )
  
  
  
    
  .def(py::init<std::function<void (const VideoEvent& event)>, int, bool>(),
      py::arg("callback").none(false), py::arg("eventMask"), py::arg("immediateNotify"), release_gil(), py::doc(
    "Create an event listener.\n"
"\n"
":param callback:        Callback function\n"
":param eventMask:       Bitmask of VideoEvent::Kind values\n"
":param immediateNotify: Whether callback should be immediately called with\n"
"                        a representative set of events for the current library state.")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_cscore_oo_initializer

static std::unique_ptr<rpybuild_cscore_oo_initializer> cls;

void begin_init_cscore_oo(py::module &m) {
  cls = std::make_unique<rpybuild_cscore_oo_initializer>(m);
}

void finish_init_cscore_oo() {
  cls->finish();
  cls.reset();
}