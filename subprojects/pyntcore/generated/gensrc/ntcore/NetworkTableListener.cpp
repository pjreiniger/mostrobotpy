
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <networktables/NetworkTableListener.h>


#include <pybind11/functional.h>

#include <pybind11/stl.h>

#include <wpi_span_type_caster.h>















#include <type_traits>


  using namespace nt;



struct rpybuild_NetworkTableListener_initializer {


  

  


  

  












  py::class_<typename nt::NetworkTableListener> cls_NetworkTableListener;

    

    
    
  py::class_<typename nt::NetworkTableListenerPoller> cls_NetworkTableListenerPoller;

    

    
    

  py::module &m;

  
  rpybuild_NetworkTableListener_initializer(py::module &m) :

  

  

  

  
    cls_NetworkTableListener(m, "NetworkTableListener", py::is_final()),

  

  
  
  
    cls_NetworkTableListenerPoller(m, "NetworkTableListenerPoller", py::is_final()),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_NetworkTableListener.doc() =
    "Event listener. This calls back to a callback function when an event\n"
"matching the specified mask occurs. The callback function is called\n"
"asynchronously on a separate thread, so it's important to use synchronization\n"
"or atomics when accessing any shared state from the callback function.";

  cls_NetworkTableListener
  
    
  .def(py::init<>(), release_gil()
  )
  
  
  
    
  .
def_static
("createListener", static_cast<NetworkTableListener(*)(NetworkTableInstance, std::span<const std::string_view>, unsigned int, ListenerCallback)>(
        &nt::NetworkTableListener::CreateListener),
      py::arg("inst"), py::arg("prefixes"), py::arg("mask"), py::arg("listener"), release_gil(), py::doc(
    "Create a listener for changes to topics with names that start with any of\n"
"the given prefixes. This creates a corresponding internal subscriber with\n"
"the lifetime of the listener.\n"
"\n"
":param inst:     Instance\n"
":param prefixes: Topic name string prefixes\n"
":param mask:     Bitmask of EventFlags values\n"
":param listener: Listener function\n"
"\n"
":returns: Listener")
  )
  
  
  
    
  .
def_static
("createListener", static_cast<NetworkTableListener(*)(Topic, unsigned int, ListenerCallback)>(
        &nt::NetworkTableListener::CreateListener),
      py::arg("topic"), py::arg("mask"), py::arg("listener"), release_gil(), py::doc(
    "Create a listener for changes on a particular topic. This creates a\n"
"corresponding internal subscriber with the lifetime of the listener.\n"
"\n"
":param topic:    Topic\n"
":param mask:     Bitmask of EventFlags values\n"
":param listener: Listener function\n"
"\n"
":returns: Listener")
  )
  
  
  
    
  .
def_static
("createListener", static_cast<NetworkTableListener(*)(Subscriber&, unsigned int, ListenerCallback)>(
        &nt::NetworkTableListener::CreateListener),
      py::arg("subscriber"), py::arg("mask"), py::arg("listener"), release_gil(), py::doc(
    "Create a listener for topic changes on a subscriber. This does NOT keep the\n"
"subscriber active.\n"
"\n"
":param subscriber: Subscriber\n"
":param mask:       Bitmask of EventFlags values\n"
":param listener:   Listener function\n"
"\n"
":returns: Listener")
  )
  
  
  
    
  .
def_static
("createListener", static_cast<NetworkTableListener(*)(MultiSubscriber&, unsigned int, ListenerCallback)>(
        &nt::NetworkTableListener::CreateListener),
      py::arg("subscriber"), py::arg("mask"), py::arg("listener"), release_gil(), py::doc(
    "Create a listener for topic changes on a subscriber. This does NOT keep the\n"
"subscriber active.\n"
"\n"
":param subscriber: Subscriber\n"
":param mask:       Bitmask of EventFlags values\n"
":param listener:   Listener function\n"
"\n"
":returns: Listener")
  )
  
  
  
    
  .
def_static
("createListener", static_cast<NetworkTableListener(*)(NetworkTableEntry&, unsigned int, ListenerCallback)>(
        &nt::NetworkTableListener::CreateListener),
      py::arg("entry"), py::arg("mask"), py::arg("listener"), release_gil(), py::doc(
    "Create a listener for topic changes on an entry.\n"
"\n"
":param entry:    Entry\n"
":param mask:     Bitmask of EventFlags values\n"
":param listener: Listener function\n"
"\n"
":returns: Listener")
  )
  
  
  
    
  .
def_static
("createConnectionListener", &nt::NetworkTableListener::CreateConnectionListener,
      py::arg("inst"), py::arg("immediate_notify"), py::arg("listener"), release_gil(), py::doc(
    "Create a connection listener.\n"
"\n"
":param inst:             instance\n"
":param immediate_notify: notify listener of all existing connections\n"
":param listener:         listener function\n"
"\n"
":returns: Listener")
  )
  
  
  
    
  .
def_static
("createTimeSyncListener", &nt::NetworkTableListener::CreateTimeSyncListener,
      py::arg("inst"), py::arg("immediate_notify"), py::arg("listener"), release_gil(), py::doc(
    "Create a time synchronization listener.\n"
"\n"
":param inst:             instance\n"
":param immediate_notify: notify listener of current time synchronization\n"
"                         value\n"
":param listener:         listener function\n"
"\n"
":returns: Listener")
  )
  
  
  
    
  .
def_static
("createLogger", &nt::NetworkTableListener::CreateLogger,
      py::arg("inst"), py::arg("minLevel"), py::arg("maxLevel"), py::arg("listener"), release_gil(), py::doc(
    "Create a listener for log messages.  By default, log messages are sent to\n"
"stderr; this function sends log messages with the specified levels to the\n"
"provided callback function instead.  The callback function will only be\n"
"called for log messages with level greater than or equal to minLevel and\n"
"less than or equal to maxLevel; messages outside this range will be\n"
"silently ignored.\n"
"\n"
":param inst:     instance\n"
":param minLevel: minimum log level\n"
":param maxLevel: maximum log level\n"
":param listener: listener function\n"
"\n"
":returns: Listener")
  )
  
  
  
    
  .
def
("getHandle", &nt::NetworkTableListener::GetHandle, release_gil(), py::doc(
    "Gets the native handle.\n"
"\n"
":returns: Handle")
  )
  
  
  
    
  .
def
("waitForQueue", &nt::NetworkTableListener::WaitForQueue,
      py::arg("timeout"), release_gil(), py::doc(
    "Wait for the listener queue to be empty. This is primarily useful for\n"
"deterministic testing. This blocks until either the listener queue is\n"
"empty (e.g. there are no more events that need to be passed along to\n"
"callbacks or poll queues) or the timeout expires.\n"
"\n"
":param timeout: timeout, in seconds. Set to 0 for non-blocking behavior, or\n"
"                a negative value to block indefinitely\n"
"\n"
":returns: False if timed out, otherwise true.")
  )
  
  
  .def("close", [](NetworkTableListener *self) {
  py::gil_scoped_release release;
  *self = NetworkTableListener();
}, py::doc("Destroys the listener"))
.def("__enter__", [](NetworkTableListener *self) {
  return self;
})
.def("__exit__", [](NetworkTableListener *self, py::args args) {
  py::gil_scoped_release release;
  *self = NetworkTableListener();
})
;

  


  }

  {
  
  
  


  

  cls_NetworkTableListenerPoller.doc() =
    "Event polled listener. This queues events matching the specified mask. Code\n"
"using the listener must periodically call ReadQueue() to read the\n"
"events.";

  cls_NetworkTableListenerPoller
  
    
  .def(py::init<>(), release_gil()
  )
  
  
  
    
  .def(py::init<NetworkTableInstance>(),
      py::arg("inst"), release_gil(), py::doc(
    "Construct a listener poller.\n"
"\n"
":param inst: Instance")
  )
  
  
  
    
  .
def
("getHandle", &nt::NetworkTableListenerPoller::GetHandle, release_gil(), py::doc(
    "Gets the native handle.\n"
"\n"
":returns: Handle")
  )
  
  
  
    
  .
def
("addListener", static_cast<NT_Listener(nt::NetworkTableListenerPoller::*)(std::span<const std::string_view>, unsigned int)>(
        &nt::NetworkTableListenerPoller::AddListener),
      py::arg("prefixes"), py::arg("mask"), release_gil(), py::doc(
    "Start listening to topic changes for topics with names that start with any\n"
"of the given prefixes. This creates a corresponding internal subscriber\n"
"with the lifetime of the listener.\n"
"\n"
":param prefixes: Topic name string prefixes\n"
":param mask:     Bitmask of EventFlags values\n"
"\n"
":returns: Listener handle")
  )
  
  
  
    
  .
def
("addListener", static_cast<NT_Listener(nt::NetworkTableListenerPoller::*)(Topic, unsigned int)>(
        &nt::NetworkTableListenerPoller::AddListener),
      py::arg("topic"), py::arg("mask"), release_gil(), py::doc(
    "Start listening to changes to a particular topic. This creates a\n"
"corresponding internal subscriber with the lifetime of the listener.\n"
"\n"
":param topic: Topic\n"
":param mask:  Bitmask of EventFlags values\n"
"\n"
":returns: Listener handle")
  )
  
  
  
    
  .
def
("addListener", static_cast<NT_Listener(nt::NetworkTableListenerPoller::*)(Subscriber&, unsigned int)>(
        &nt::NetworkTableListenerPoller::AddListener),
      py::arg("subscriber"), py::arg("mask"), release_gil(), py::doc(
    "Start listening to topic changes on a subscriber. This does NOT keep the\n"
"subscriber active.\n"
"\n"
":param subscriber: Subscriber\n"
":param mask:       Bitmask of EventFlags values\n"
"\n"
":returns: Listener handle")
  )
  
  
  
    
  .
def
("addListener", static_cast<NT_Listener(nt::NetworkTableListenerPoller::*)(MultiSubscriber&, unsigned int)>(
        &nt::NetworkTableListenerPoller::AddListener),
      py::arg("subscriber"), py::arg("mask"), release_gil(), py::doc(
    "Start listening to topic changes on a subscriber. This does NOT keep the\n"
"subscriber active.\n"
"\n"
":param subscriber: Subscriber\n"
":param mask:       Bitmask of EventFlags values\n"
"\n"
":returns: Listener handle")
  )
  
  
  
    
  .
def
("addListener", static_cast<NT_Listener(nt::NetworkTableListenerPoller::*)(NetworkTableEntry&, unsigned int)>(
        &nt::NetworkTableListenerPoller::AddListener),
      py::arg("entry"), py::arg("mask"), release_gil(), py::doc(
    "Start listening to topic changes on an entry.\n"
"\n"
":param entry: Entry\n"
":param mask:  Bitmask of EventFlags values\n"
"\n"
":returns: Listener handle")
  )
  
  
  
    
  .
def
("addConnectionListener", &nt::NetworkTableListenerPoller::AddConnectionListener,
      py::arg("immediate_notify"), release_gil(), py::doc(
    "Add a connection listener. The callback function is called asynchronously\n"
"on a separate thread, so it's important to use synchronization or atomics\n"
"when accessing any shared state from the callback function.\n"
"\n"
":param immediate_notify: notify listener of all existing connections\n"
"\n"
":returns: Listener handle")
  )
  
  
  
    
  .
def
("addTimeSyncListener", &nt::NetworkTableListenerPoller::AddTimeSyncListener,
      py::arg("immediate_notify"), release_gil(), py::doc(
    "Add a time synchronization listener. The callback function is called\n"
"asynchronously on a separate thread, so it's important to use\n"
"synchronization or atomics when accessing any shared state from the\n"
"callback function.\n"
"\n"
":param immediate_notify: notify listener of current time synchronization\n"
"                         value\n"
"\n"
":returns: Listener handle")
  )
  
  
  
    
  .
def
("addLogger", &nt::NetworkTableListenerPoller::AddLogger,
      py::arg("minLevel"), py::arg("maxLevel"), release_gil(), py::doc(
    "Add logger callback function.  By default, log messages are sent to stderr;\n"
"this function sends log messages with the specified levels to the provided\n"
"callback function instead.  The callback function will only be called for\n"
"log messages with level greater than or equal to minLevel and less than or\n"
"equal to maxLevel; messages outside this range will be silently ignored.\n"
"\n"
":param minLevel: minimum log level\n"
":param maxLevel: maximum log level\n"
"\n"
":returns: Listener handle")
  )
  
  
  
    
  .
def
("removeListener", &nt::NetworkTableListenerPoller::RemoveListener,
      py::arg("listener"), release_gil(), py::doc(
    "Remove a listener.\n"
"\n"
":param listener: Listener handle")
  )
  
  
  
    
  .
def
("readQueue", &nt::NetworkTableListenerPoller::ReadQueue, release_gil(), py::doc(
    "Read events.\n"
"\n"
":returns: Events since the previous call to ReadQueue()")
  )
  
  
  .def("close", [](NetworkTableListenerPoller *self) {
  py::gil_scoped_release release;
  *self = NetworkTableListenerPoller();
}, py::doc("Destroys the poller"))
.def("__enter__", [](NetworkTableListenerPoller *self) {
  return self;
})
.def("__exit__", [](NetworkTableListenerPoller *self, py::args args) {
  py::gil_scoped_release release;
  *self = NetworkTableListenerPoller();
})
;

  


  }






}

}; // struct rpybuild_NetworkTableListener_initializer

static std::unique_ptr<rpybuild_NetworkTableListener_initializer> cls;

void begin_init_NetworkTableListener(py::module &m) {
  cls = std::make_unique<rpybuild_NetworkTableListener_initializer>(m);
}

void finish_init_NetworkTableListener() {
  cls->finish();
  cls.reset();
}