
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <networktables/DoubleTopic.h>


#include <pybind11/stl.h>

#include <wpi_json_type_caster.h>







#define RPYGEN_ENABLE_nt__DoubleSubscriber_PROTECTED_CONSTRUCTORS
#include <rpygen/nt__DoubleSubscriber.hpp>

#define RPYGEN_ENABLE_nt__DoublePublisher_PROTECTED_CONSTRUCTORS
#include <rpygen/nt__DoublePublisher.hpp>









#include <type_traits>


  using namespace wpi;

  using namespace nt;





struct rpybuild_DoubleTopic_initializer {


  

  


  

  


  

  


  

  












  
  using DoubleSubscriber_Trampoline = rpygen::PyTrampoline_nt__DoubleSubscriber<typename nt::DoubleSubscriber, typename rpygen::PyTrampolineCfg_nt__DoubleSubscriber<>>;
    static_assert(std::is_abstract<DoubleSubscriber_Trampoline>::value == false, "nt::DoubleSubscriber " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename nt::DoubleSubscriber, DoubleSubscriber_Trampoline, nt::Subscriber> cls_DoubleSubscriber;

    

    
    
  
  using DoublePublisher_Trampoline = rpygen::PyTrampoline_nt__DoublePublisher<typename nt::DoublePublisher, typename rpygen::PyTrampolineCfg_nt__DoublePublisher<>>;
    static_assert(std::is_abstract<DoublePublisher_Trampoline>::value == false, "nt::DoublePublisher " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename nt::DoublePublisher, DoublePublisher_Trampoline, nt::Publisher> cls_DoublePublisher;

    

    
    
  py::class_<typename nt::DoubleEntry, nt::DoubleSubscriber, nt::DoublePublisher> cls_DoubleEntry;

    

    
    
  py::class_<typename nt::DoubleTopic, nt::Topic> cls_DoubleTopic;

    

    
    

  py::module &m;

  
  rpybuild_DoubleTopic_initializer(py::module &m) :

  

  

  

  
    cls_DoubleSubscriber(m, "DoubleSubscriber"),

  

  
  
  
    cls_DoublePublisher(m, "DoublePublisher"),

  

  
  
  
    cls_DoubleEntry(m, "DoubleEntry", py::is_final()),

  

  
  
  
    cls_DoubleTopic(m, "DoubleTopic", py::is_final()),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
  }

void finish() {





  {
  
  
  
    using TopicType [[maybe_unused]] = typename nt::DoubleSubscriber::TopicType;
  
    using ValueType [[maybe_unused]] = typename nt::DoubleSubscriber::ValueType;
  
    using ParamType [[maybe_unused]] = typename nt::DoubleSubscriber::ParamType;
  
    using TimestampedValueType [[maybe_unused]] = typename nt::DoubleSubscriber::TimestampedValueType;
  


  

  cls_DoubleSubscriber.doc() =
    "NetworkTables Double subscriber.";

  cls_DoubleSubscriber
  
    
  .
def
("get", static_cast<ValueType(nt::DoubleSubscriber::*)() const>(
        &nt::DoubleSubscriber::Get), release_gil(), py::doc(
    "Get the last published value.\n"
"If no value has been published, returns the stored default value.\n"
"\n"
":returns: value")
  )
  
  
  
    
  .
def
("get", static_cast<ValueType(nt::DoubleSubscriber::*)(ParamType) const>(
        &nt::DoubleSubscriber::Get),
      py::arg("defaultValue"), release_gil(), py::doc(
    "Get the last published value.\n"
"If no value has been published, returns the passed defaultValue.\n"
"\n"
":param defaultValue: default value to return if no value has been published\n"
"\n"
":returns: value")
  )
  
  
  
    
  .
def
("getAtomic", static_cast<TimestampedValueType(nt::DoubleSubscriber::*)() const>(
        &nt::DoubleSubscriber::GetAtomic), release_gil(), py::doc(
    "Get the last published value along with its timestamp\n"
"If no value has been published, returns the stored default value and a\n"
"timestamp of 0.\n"
"\n"
":returns: timestamped value")
  )
  
  
  
    
  .
def
("getAtomic", static_cast<TimestampedValueType(nt::DoubleSubscriber::*)(ParamType) const>(
        &nt::DoubleSubscriber::GetAtomic),
      py::arg("defaultValue"), release_gil(), py::doc(
    "Get the last published value along with its timestamp.\n"
"If no value has been published, returns the passed defaultValue and a\n"
"timestamp of 0.\n"
"\n"
":param defaultValue: default value to return if no value has been published\n"
"\n"
":returns: timestamped value")
  )
  
  
  
    
  .
def
("readQueue", &nt::DoubleSubscriber::ReadQueue, release_gil(), py::doc(
    "Get an array of all value changes since the last call to ReadQueue.\n"
"Also provides a timestamp for each value.\n"
"\n"
".. note:: The \"poll storage\" subscribe option can be used to set the queue\n"
"   depth.\n"
"\n"
":returns: Array of timestamped values; empty array if no new changes have\n"
"          been published since the previous call.")
  )
  
  
  
    
  .
def
("getTopic", &nt::DoubleSubscriber::GetTopic, release_gil(), py::doc(
    "Get the corresponding topic.\n"
"\n"
":returns: Topic")
  )
  
  
  .def("close", [](DoubleSubscriber *self) {
  py::gil_scoped_release release;
  *self = DoubleSubscriber();
}, py::doc("Destroys the subscriber"))
.def("__enter__", [](DoubleSubscriber *self) {
  return self;
})
.def("__exit__", [](DoubleSubscriber *self, py::args args) {
  py::gil_scoped_release release;
  *self = DoubleSubscriber();
})
;

  


  }

  {
  
  
  
    using TopicType [[maybe_unused]] = typename nt::DoublePublisher::TopicType;
  
    using ValueType [[maybe_unused]] = typename nt::DoublePublisher::ValueType;
  
    using ParamType [[maybe_unused]] = typename nt::DoublePublisher::ParamType;
  
    using TimestampedValueType [[maybe_unused]] = typename nt::DoublePublisher::TimestampedValueType;
  


  

  cls_DoublePublisher.doc() =
    "NetworkTables Double publisher.";

  cls_DoublePublisher
  
    
  .
def
("set", &nt::DoublePublisher::Set,
      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
    "Publish a new value.\n"
"\n"
":param value: value to publish\n"
":param time:  timestamp; 0 indicates current NT time should be used")
  )
  
  
  
    
  .
def
("setDefault", &nt::DoublePublisher::SetDefault,
      py::arg("value"), release_gil(), py::doc(
    "Publish a default value.\n"
"On reconnect, a default value will never be used in preference to a\n"
"published value.\n"
"\n"
":param value: value")
  )
  
  
  
    
  .
def
("getTopic", &nt::DoublePublisher::GetTopic, release_gil(), py::doc(
    "Get the corresponding topic.\n"
"\n"
":returns: Topic")
  )
  
  
  .def("close", [](DoublePublisher *self) {
  py::gil_scoped_release release;
  *self = DoublePublisher();
}, py::doc("Destroys the publisher"))
.def("__enter__", [](DoublePublisher *self) {
  return self;
})
.def("__exit__", [](DoublePublisher *self, py::args args) {
  py::gil_scoped_release release;
  *self = DoublePublisher();
})
;

  


  }

  {
  
  
  
    using SubscriberType [[maybe_unused]] = typename nt::DoubleEntry::SubscriberType;
  
    using PublisherType [[maybe_unused]] = typename nt::DoubleEntry::PublisherType;
  
    using TopicType [[maybe_unused]] = typename nt::DoubleEntry::TopicType;
  
    using ValueType [[maybe_unused]] = typename nt::DoubleEntry::ValueType;
  
    using ParamType [[maybe_unused]] = typename nt::DoubleEntry::ParamType;
  
    using TimestampedValueType [[maybe_unused]] = typename nt::DoubleEntry::TimestampedValueType;
  


  

  cls_DoubleEntry.doc() =
    "NetworkTables Double entry.\n"
"\n"
".. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.";

  cls_DoubleEntry
  
    
  .
def
("getTopic", &nt::DoubleEntry::GetTopic, release_gil(), py::doc(
    "Get the corresponding topic.\n"
"\n"
":returns: Topic")
  )
  
  
  
    
  .
def
("unpublish", &nt::DoubleEntry::Unpublish, release_gil(), py::doc(
    "Stops publishing the entry if it's published.")
  )
  
  
  .def("close", [](DoubleEntry *self) {
  py::gil_scoped_release release;
  *self = DoubleEntry();
}, py::doc("Destroys the entry"))
.def("__enter__", [](DoubleEntry *self) {
  return self;
})
.def("__exit__", [](DoubleEntry *self, py::args args) {
  py::gil_scoped_release release;
  *self = DoubleEntry();
})
;

  


  }

  {
  
  
  
    using SubscriberType [[maybe_unused]] = typename nt::DoubleTopic::SubscriberType;
  
    using PublisherType [[maybe_unused]] = typename nt::DoubleTopic::PublisherType;
  
    using EntryType [[maybe_unused]] = typename nt::DoubleTopic::EntryType;
  
    using ValueType [[maybe_unused]] = typename nt::DoubleTopic::ValueType;
  
    using ParamType [[maybe_unused]] = typename nt::DoubleTopic::ParamType;
  
    using TimestampedValueType [[maybe_unused]] = typename nt::DoubleTopic::TimestampedValueType;
  
    static constexpr auto kTypeString [[maybe_unused]] = nt::DoubleTopic::kTypeString;
  


  

  cls_DoubleTopic.doc() =
    "NetworkTables Double topic.";

  cls_DoubleTopic
  
    
  .def(py::init<Topic>(),
      py::arg("topic"), release_gil(), py::doc(
    "Construct from a generic topic.\n"
"\n"
":param topic: Topic")
  )
  
  
  
    
  .
def
("subscribe", &nt::DoubleTopic::Subscribe,
      py::arg("defaultValue"), py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
    "Create a new subscriber to the topic.\n"
"\n"
"The subscriber is only active as long as the returned object\n"
"is not destroyed.\n"
"\n"
".. note:: Subscribers that do not match the published data type do not return\n"
"   any values. To determine if the data type matches, use the appropriate\n"
"   Topic functions.\n"
"\n"
":param defaultValue: default value used when a default is not provided to a\n"
"                     getter function\n"
":param options:      subscribe options\n"
"\n"
":returns: subscriber")
  )
  
  
  
    
  .
def
("subscribeEx", &nt::DoubleTopic::SubscribeEx,
      py::arg("typeString"), py::arg("defaultValue"), py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
    "Create a new subscriber to the topic, with specific type string.\n"
"\n"
"The subscriber is only active as long as the returned object\n"
"is not destroyed.\n"
"\n"
".. note:: Subscribers that do not match the published data type do not return\n"
"   any values. To determine if the data type matches, use the appropriate\n"
"   Topic functions.\n"
"\n"
":param typeString:   type string\n"
":param defaultValue: default value used when a default is not provided to a\n"
"                     getter function\n"
":param options:      subscribe options\n"
"\n"
":returns: subscriber")
  )
  
  
  
    
  .
def
("publish", &nt::DoubleTopic::Publish,
      py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
    "Create a new publisher to the topic.\n"
"\n"
"The publisher is only active as long as the returned object\n"
"is not destroyed.\n"
"\n"
".. note:: It is not possible to publish two different data types to the same\n"
"   topic. Conflicts between publishers are typically resolved by the\n"
"   server on a first-come, first-served basis. Any published values that\n"
"   do not match the topic's data type are dropped (ignored). To determine\n"
"   if the data type matches, use the appropriate Topic functions.\n"
"\n"
":param options: publish options\n"
"\n"
":returns: publisher")
  )
  
  
  
    
  .
def
("publishEx", &nt::DoubleTopic::PublishEx,
      py::arg("typeString"), py::arg("properties"), py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
    "Create a new publisher to the topic, with type string and initial\n"
"properties.\n"
"\n"
"The publisher is only active as long as the returned object\n"
"is not destroyed.\n"
"\n"
".. note:: It is not possible to publish two different data types to the same\n"
"   topic. Conflicts between publishers are typically resolved by the\n"
"   server on a first-come, first-served basis. Any published values that\n"
"   do not match the topic's data type are dropped (ignored). To determine\n"
"   if the data type matches, use the appropriate Topic functions.\n"
"\n"
":param typeString: type string\n"
":param properties: JSON properties\n"
":param options:    publish options\n"
"\n"
":returns: publisher")
  )
  
  
  
    
  .
def
("getEntry", &nt::DoubleTopic::GetEntry,
      py::arg("defaultValue"), py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
    "Create a new entry for the topic.\n"
"\n"
"Entries act as a combination of a subscriber and a weak publisher. The\n"
"subscriber is active as long as the entry is not destroyed. The publisher\n"
"is created when the entry is first written to, and remains active until\n"
"either Unpublish() is called or the entry is destroyed.\n"
"\n"
".. note:: It is not possible to use two different data types with the same\n"
"   topic. Conflicts between publishers are typically resolved by the\n"
"   server on a first-come, first-served basis. Any published values that\n"
"   do not match the topic's data type are dropped (ignored), and the entry\n"
"   will show no new values if the data type does not match. To determine\n"
"   if the data type matches, use the appropriate Topic functions.\n"
"\n"
":param defaultValue: default value used when a default is not provided to a\n"
"                     getter function\n"
":param options:      publish and/or subscribe options\n"
"\n"
":returns: entry")
  )
  
  
  
    
  .
def
("getEntryEx", &nt::DoubleTopic::GetEntryEx,
      py::arg("typeString"), py::arg("defaultValue"), py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
    "Create a new entry for the topic, with specific type string.\n"
"\n"
"Entries act as a combination of a subscriber and a weak publisher. The\n"
"subscriber is active as long as the entry is not destroyed. The publisher\n"
"is created when the entry is first written to, and remains active until\n"
"either Unpublish() is called or the entry is destroyed.\n"
"\n"
".. note:: It is not possible to use two different data types with the same\n"
"   topic. Conflicts between publishers are typically resolved by the\n"
"   server on a first-come, first-served basis. Any published values that\n"
"   do not match the topic's data type are dropped (ignored), and the entry\n"
"   will show no new values if the data type does not match. To determine\n"
"   if the data type matches, use the appropriate Topic functions.\n"
"\n"
":param typeString:   type string\n"
":param defaultValue: default value used when a default is not provided to a\n"
"                     getter function\n"
":param options:      publish and/or subscribe options\n"
"\n"
":returns: entry")
  )
  
  
  
    .def_readonly_static("kTypeString", &nt::DoubleTopic::kTypeString, py::doc(
    "The default type string for this topic type."))
  .def("close", [](DoubleTopic *self) {
  py::gil_scoped_release release;
  *self = DoubleTopic();
}, py::doc("Destroys the topic"))
.def("__enter__", [](DoubleTopic *self) {
  return self;
})
.def("__exit__", [](DoubleTopic *self, py::args args) {
  py::gil_scoped_release release;
  *self = DoubleTopic();
})
;

  


  }






}

}; // struct rpybuild_DoubleTopic_initializer

static std::unique_ptr<rpybuild_DoubleTopic_initializer> cls;

void begin_init_DoubleTopic(py::module &m) {
  cls = std::make_unique<rpybuild_DoubleTopic_initializer>(m);
}

void finish_init_DoubleTopic() {
  cls->finish();
  cls.reset();
}