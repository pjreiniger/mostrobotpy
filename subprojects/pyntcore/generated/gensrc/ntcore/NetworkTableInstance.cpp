
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <networktables/NetworkTableInstance.h>


#include <pybind11/functional.h>

#include <pybind11/stl.h>

#include <wpi_span_type_caster.h>



#include <pybind11/operators.h>











#include <networktables/BooleanArrayTopic.h>

#include <networktables/BooleanTopic.h>

#include <networktables/DoubleArrayTopic.h>

#include <networktables/DoubleTopic.h>

#include <networktables/FloatArrayTopic.h>

#include <networktables/FloatTopic.h>

#include <networktables/IntegerArrayTopic.h>

#include <networktables/IntegerTopic.h>

#include <networktables/MultiSubscriber.h>

#include <networktables/RawTopic.h>

#include <networktables/StringArrayTopic.h>

#include <networktables/StringTopic.h>

#include <networktables/StructArrayTopic.h>

#include <networktables/StructTopic.h>

#include <networktables/Topic.h>

#include <src/py2value.h>

#include <src/nt_instance.h>

#include <wpi/DataLog.h>

#include <wpystruct.h>



#include <type_traits>


  using namespace nt;



struct rpybuild_NetworkTableInstance_initializer {


  

  












  py::class_<typename nt::NetworkTableInstance> cls_NetworkTableInstance;

    
    
  py::enum_<nt::NetworkTableInstance::NetworkMode> cls_NetworkTableInstance_enum1;
    
    
  py::enum_<nt::NetworkTableInstance::LogLevel> cls_NetworkTableInstance_enum2;
    

    
    

  py::module &m;

  
  rpybuild_NetworkTableInstance_initializer(py::module &m) :

  

  

  

  
    cls_NetworkTableInstance(m, "NetworkTableInstance", py::is_final()),

  
    cls_NetworkTableInstance_enum1
  (cls_NetworkTableInstance, "NetworkMode"
  ,
    "Client/server mode flag values (as returned by GetNetworkMode()).\n"
"This is a bitmask.", py::arithmetic()),
  
    cls_NetworkTableInstance_enum2
  (cls_NetworkTableInstance, "LogLevel"
  ,
    "Logging levels (as used by SetLogger())."),
  

  
  
  

    m(m)
  {
    
    

    
    
  
    cls_NetworkTableInstance_enum1
  
    .value("kNetModeNone", nt::NetworkTableInstance::NetworkMode::kNetModeNone)
  
    .value("kNetModeServer", nt::NetworkTableInstance::NetworkMode::kNetModeServer)
  
    .value("kNetModeClient3", nt::NetworkTableInstance::NetworkMode::kNetModeClient3)
  
    .value("kNetModeClient4", nt::NetworkTableInstance::NetworkMode::kNetModeClient4)
  
    .value("kNetModeLocal", nt::NetworkTableInstance::NetworkMode::kNetModeLocal)
  .value("kNetModeStarting", (nt::NetworkTableInstance::NetworkMode)NT_NET_MODE_STARTING)
;

  
    cls_NetworkTableInstance_enum2
  
    .value("kLogCritical", nt::NetworkTableInstance::LogLevel::kLogCritical)
  
    .value("kLogError", nt::NetworkTableInstance::LogLevel::kLogError)
  
    .value("kLogWarning", nt::NetworkTableInstance::LogLevel::kLogWarning)
  
    .value("kLogInfo", nt::NetworkTableInstance::LogLevel::kLogInfo)
  
    .value("kLogDebug", nt::NetworkTableInstance::LogLevel::kLogDebug)
  
    .value("kLogDebug1", nt::NetworkTableInstance::LogLevel::kLogDebug1)
  
    .value("kLogDebug2", nt::NetworkTableInstance::LogLevel::kLogDebug2)
  
    .value("kLogDebug3", nt::NetworkTableInstance::LogLevel::kLogDebug3)
  
    .value("kLogDebug4", nt::NetworkTableInstance::LogLevel::kLogDebug4)
  ;

  

    
    
  }

void finish() {





  {
  
  
  using NetworkMode [[maybe_unused]] = typename nt::NetworkTableInstance::NetworkMode;
  
  using LogLevel [[maybe_unused]] = typename nt::NetworkTableInstance::LogLevel;
  
  
    static constexpr auto kDefaultPort3 [[maybe_unused]] = nt::NetworkTableInstance::kDefaultPort3;
  
    static constexpr auto kDefaultPort4 [[maybe_unused]] = nt::NetworkTableInstance::kDefaultPort4;
  


  

  cls_NetworkTableInstance.doc() =
    "NetworkTables Instance.\n"
"\n"
"Instances are completely independent from each other.  Table operations on\n"
"one instance will not be visible to other instances unless the instances are\n"
"connected via the network.  The main limitation on instances is that you\n"
"cannot have two servers on the same network port.  The main utility of\n"
"instances is for unit testing, but they can also enable one program to\n"
"connect to two different NetworkTables networks.\n"
"\n"
"The global \"default\" instance (as returned by GetDefault()) is\n"
"always available, and is intended for the common case when there is only\n"
"a single NetworkTables instance being used in the program.  The\n"
"default instance cannot be destroyed.\n"
"\n"
"Additional instances can be created with the Create() function.\n"
"Instances are not reference counted or RAII.  Instead, they must be\n"
"explicitly destroyed (with Destroy()).\n"
"\n"
"@ingroup ntcore_cpp_api";

  cls_NetworkTableInstance
  
    
  .
def_static
("getDefault", &nt::NetworkTableInstance::GetDefault, release_gil(), py::doc(
    "Get global default instance.\n"
"\n"
":returns: Global default instance")
  )
  
  
  
    
  .
def_static
("create", &nt::NetworkTableInstance::Create, release_gil(), py::doc(
    "Create an instance.\n"
"\n"
":returns: Newly created instance")
  )
  
  
  
    
  .
def_static
("destroy", [](NetworkTableInstance * self) {
  pyntcore::onInstanceDestroy(self);
  py::gil_scoped_release release;
  NetworkTableInstance::Destroy(*self);
}
,
      py::arg("inst"), py::doc(
    "Destroys an instance (note: this has global effect).\n"
"\n"
":param inst: Instance")
  )
  
  
  
    
  .
def
("_getHandle", &nt::NetworkTableInstance::GetHandle, release_gil(), py::doc(
    "Gets the native handle for the entry.\n"
"\n"
":returns: Native handle")
  )
  
  
  
    
  .
def
("getTopic", &nt::NetworkTableInstance::GetTopic,
      py::arg("name"), release_gil(), py::doc(
    "Gets a \"generic\" (untyped) topic.\n"
"\n"
":param name: topic name\n"
"\n"
":returns: Topic")
  )
  
  
  
    
  .
def
("getBooleanTopic", &nt::NetworkTableInstance::GetBooleanTopic,
      py::arg("name"), release_gil(), py::doc(
    "Gets a boolean topic.\n"
"\n"
":param name: topic name\n"
"\n"
":returns: Topic")
  )
  
  
  
    
  .
def
("getIntegerTopic", &nt::NetworkTableInstance::GetIntegerTopic,
      py::arg("name"), release_gil(), py::doc(
    "Gets an integer topic.\n"
"\n"
":param name: topic name\n"
"\n"
":returns: Topic")
  )
  
  
  
    
  .
def
("getFloatTopic", &nt::NetworkTableInstance::GetFloatTopic,
      py::arg("name"), release_gil(), py::doc(
    "Gets a float topic.\n"
"\n"
":param name: topic name\n"
"\n"
":returns: Topic")
  )
  
  
  
    
  .
def
("getDoubleTopic", &nt::NetworkTableInstance::GetDoubleTopic,
      py::arg("name"), release_gil(), py::doc(
    "Gets a double topic.\n"
"\n"
":param name: topic name\n"
"\n"
":returns: Topic")
  )
  
  
  
    
  .
def
("getStringTopic", &nt::NetworkTableInstance::GetStringTopic,
      py::arg("name"), release_gil(), py::doc(
    "Gets a string topic.\n"
"\n"
":param name: topic name\n"
"\n"
":returns: Topic")
  )
  
  
  
    
  .
def
("getRawTopic", &nt::NetworkTableInstance::GetRawTopic,
      py::arg("name"), release_gil(), py::doc(
    "Gets a raw topic.\n"
"\n"
":param name: topic name\n"
"\n"
":returns: Topic")
  )
  
  
  
    
  .
def
("getBooleanArrayTopic", &nt::NetworkTableInstance::GetBooleanArrayTopic,
      py::arg("name"), release_gil(), py::doc(
    "Gets a boolean array topic.\n"
"\n"
":param name: topic name\n"
"\n"
":returns: Topic")
  )
  
  
  
    
  .
def
("getIntegerArrayTopic", &nt::NetworkTableInstance::GetIntegerArrayTopic,
      py::arg("name"), release_gil(), py::doc(
    "Gets an integer array topic.\n"
"\n"
":param name: topic name\n"
"\n"
":returns: Topic")
  )
  
  
  
    
  .
def
("getFloatArrayTopic", &nt::NetworkTableInstance::GetFloatArrayTopic,
      py::arg("name"), release_gil(), py::doc(
    "Gets a float array topic.\n"
"\n"
":param name: topic name\n"
"\n"
":returns: Topic")
  )
  
  
  
    
  .
def
("getDoubleArrayTopic", &nt::NetworkTableInstance::GetDoubleArrayTopic,
      py::arg("name"), release_gil(), py::doc(
    "Gets a double array topic.\n"
"\n"
":param name: topic name\n"
"\n"
":returns: Topic")
  )
  
  
  
    
  .
def
("getStringArrayTopic", &nt::NetworkTableInstance::GetStringArrayTopic,
      py::arg("name"), release_gil(), py::doc(
    "Gets a string array topic.\n"
"\n"
":param name: topic name\n"
"\n"
":returns: Topic")
  )
  
  
  
    
  .
def
("getStructTopic", [](const NetworkTableInstance &self, std::string_view name, const py::type &t) {
  WPyStructInfo info(t);
  return self.GetStructTopic<WPyStruct, WPyStructInfo>(name, info);
}
,
      py::arg("name"), py::arg("type"), py::doc(
    "Gets a raw struct serialized value topic.\n"
"\n"
":param name: topic name\n"
":param type: optional struct type info\n"
"\n"
":returns: Topic")
  )
  
  
  
    
  .
def
("getStructArrayTopic", [](const NetworkTableInstance &self, std::string_view name, const py::type &t) {
  WPyStructInfo info(t);
  return self.GetStructArrayTopic<WPyStruct, WPyStructInfo>(name, info);
}
,
      py::arg("name"), py::arg("type"), py::doc(
    "Gets a raw struct serialized array topic.\n"
"\n"
":param name: topic name\n"
":param type: optional struct type info\n"
"\n"
":returns: Topic")
  )
  
  
  
    
  .
def
("getTopics", static_cast<std::vector<Topic>(nt::NetworkTableInstance::*)()>(
        &nt::NetworkTableInstance::GetTopics), release_gil(), py::doc(
    "Get Published Topics.\n"
"\n"
"Returns an array of topics.\n"
"\n"
":returns: Array of topics.")
  )
  
  
  
    
  .
def
("getTopics", static_cast<std::vector<Topic>(nt::NetworkTableInstance::*)(std::string_view)>(
        &nt::NetworkTableInstance::GetTopics),
      py::arg("prefix"), release_gil(), py::doc(
    "Get Published Topics.\n"
"\n"
"Returns an array of topics.  The results are filtered by\n"
"string prefix to only return a subset of all topics.\n"
"\n"
":param prefix: name required prefix; only topics whose name\n"
"               starts with this string are returned\n"
"\n"
":returns: Array of topics.")
  )
  
  
  
    
  .
def
("getTopics", static_cast<std::vector<Topic>(nt::NetworkTableInstance::*)(std::string_view, unsigned int)>(
        &nt::NetworkTableInstance::GetTopics),
      py::arg("prefix"), py::arg("types"), release_gil(), py::doc(
    "Get Published Topics.\n"
"\n"
"Returns an array of topics.  The results are filtered by\n"
"string prefix and type to only return a subset of all topics.\n"
"\n"
":param prefix: name required prefix; only topics whose name\n"
"               starts with this string are returned\n"
":param types:  bitmask of NT_Type values; 0 is treated specially\n"
"               as a \"don't care\"\n"
"\n"
":returns: Array of topics.")
  )
  
  
  
    
  .
def
("getTopics", static_cast<std::vector<Topic>(nt::NetworkTableInstance::*)(std::string_view, std::span<std::string_view>)>(
        &nt::NetworkTableInstance::GetTopics),
      py::arg("prefix"), py::arg("types"), release_gil(), py::doc(
    "Get Published Topics.\n"
"\n"
"Returns an array of topics.  The results are filtered by\n"
"string prefix and type to only return a subset of all topics.\n"
"\n"
":param prefix: name required prefix; only topics whose name\n"
"               starts with this string are returned\n"
":param types:  array of type strings\n"
"\n"
":returns: Array of topic handles.")
  )
  
  
  
    
  .
def
("getTopicInfo", static_cast<std::vector<TopicInfo>(nt::NetworkTableInstance::*)()>(
        &nt::NetworkTableInstance::GetTopicInfo), release_gil(), py::doc(
    "Get Topic Information about multiple topics.\n"
"\n"
"Returns an array of topic information (handle, name, type, and properties).\n"
"\n"
":returns: Array of topic information.")
  )
  
  
  
    
  .
def
("getTopicInfo", static_cast<std::vector<TopicInfo>(nt::NetworkTableInstance::*)(std::string_view)>(
        &nt::NetworkTableInstance::GetTopicInfo),
      py::arg("prefix"), release_gil(), py::doc(
    "Get Topic Information about multiple topics.\n"
"\n"
"Returns an array of topic information (handle, name, type, and properties).\n"
"The results are filtered by string prefix to only\n"
"return a subset of all topics.\n"
"\n"
":param prefix: name required prefix; only topics whose name\n"
"               starts with this string are returned\n"
"\n"
":returns: Array of topic information.")
  )
  
  
  
    
  .
def
("getTopicInfo", static_cast<std::vector<TopicInfo>(nt::NetworkTableInstance::*)(std::string_view, unsigned int)>(
        &nt::NetworkTableInstance::GetTopicInfo),
      py::arg("prefix"), py::arg("types"), release_gil(), py::doc(
    "Get Topic Information about multiple topics.\n"
"\n"
"Returns an array of topic information (handle, name, type, and properties).\n"
"The results are filtered by string prefix and type to only\n"
"return a subset of all topics.\n"
"\n"
":param prefix: name required prefix; only topics whose name\n"
"               starts with this string are returned\n"
":param types:  bitmask of NT_Type values; 0 is treated specially\n"
"               as a \"don't care\"\n"
"\n"
":returns: Array of topic information.")
  )
  
  
  
    
  .
def
("getTopicInfo", static_cast<std::vector<TopicInfo>(nt::NetworkTableInstance::*)(std::string_view, std::span<std::string_view>)>(
        &nt::NetworkTableInstance::GetTopicInfo),
      py::arg("prefix"), py::arg("types"), release_gil(), py::doc(
    "Get Topic Information about multiple topics.\n"
"\n"
"Returns an array of topic information (handle, name, type, and properties).\n"
"The results are filtered by string prefix and type to only\n"
"return a subset of all topics.\n"
"\n"
":param prefix: name required prefix; only topics whose name\n"
"               starts with this string are returned\n"
":param types:  array of type strings\n"
"\n"
":returns: Array of topic information.")
  )
  
  
  
    
  .
def
("getEntry", &nt::NetworkTableInstance::GetEntry,
      py::arg("name"), release_gil(), py::doc(
    "Gets the entry for a key.\n"
"\n"
":param name: Key\n"
"\n"
":returns: Network table entry.")
  )
  
  
  
    
  .
def
("getTable", &nt::NetworkTableInstance::GetTable,
      py::arg("key"), release_gil(), py::doc(
    "Gets the table with the specified key.\n"
"\n"
":param key: the key name\n"
"\n"
":returns: The network table")
  )
  
  
  
    
  .
def_static
("removeListener", &nt::NetworkTableInstance::RemoveListener,
      py::arg("listener"), release_gil(), py::doc(
    "Remove a listener.\n"
"\n"
":param listener: Listener handle to remove")
  )
  
  
  
    
  .
def
("waitForListenerQueue", &nt::NetworkTableInstance::WaitForListenerQueue,
      py::arg("timeout"), release_gil(), py::doc(
    "Wait for the listener queue to be empty. This is primarily\n"
"useful for deterministic testing. This blocks until either the\n"
"listener queue is empty (e.g. there are no more events that need to be\n"
"passed along to callbacks or poll queues) or the timeout expires.\n"
"\n"
":param timeout: timeout, in seconds. Set to 0 for non-blocking behavior, or\n"
"                a negative value to block indefinitely\n"
"\n"
":returns: False if timed out, otherwise true.")
  )
  
  
  
    
  .
def
("addConnectionListener", &nt::NetworkTableInstance::AddConnectionListener,
      py::arg("immediate_notify"), py::arg("callback"), release_gil(), py::doc(
    "Add a connection listener. The callback function is called asynchronously\n"
"on a separate thread, so it's important to use synchronization or atomics\n"
"when accessing any shared state from the callback function.\n"
"\n"
":param immediate_notify: notify listener of all existing connections\n"
":param callback:         listener to add\n"
"\n"
":returns: Listener handle")
  )
  
  
  
    
  .
def
("addTimeSyncListener", &nt::NetworkTableInstance::AddTimeSyncListener,
      py::arg("immediate_notify"), py::arg("callback"), release_gil(), py::doc(
    "Add a time synchronization listener. The callback function is called\n"
"asynchronously on a separate thread, so it's important to use\n"
"synchronization or atomics when accessing any shared state from the\n"
"callback function.\n"
"\n"
":param immediate_notify: notify listener of current time synchronization\n"
"                         value\n"
":param callback:         listener to add\n"
"\n"
":returns: Listener handle")
  )
  
  
  
    
  .
def
("addListener", static_cast<NT_Listener(nt::NetworkTableInstance::*)(Topic, unsigned int, ListenerCallback)>(
        &nt::NetworkTableInstance::AddListener),
      py::arg("topic"), py::arg("eventMask"), py::arg("listener"), release_gil(), py::doc(
    "Add a listener for changes on a particular topic. The callback\n"
"function is called asynchronously on a separate thread, so it's important\n"
"to use synchronization or atomics when accessing any shared state from the\n"
"callback function.\n"
"\n"
"This creates a corresponding internal subscriber with the lifetime of the\n"
"listener.\n"
"\n"
":param topic:     Topic\n"
":param eventMask: Bitmask of EventFlags values\n"
":param listener:  Listener function\n"
"\n"
":returns: Listener handle")
  )
  
  
  
    
  .
def
("addListener", static_cast<NT_Listener(nt::NetworkTableInstance::*)(Subscriber&, unsigned int, ListenerCallback)>(
        &nt::NetworkTableInstance::AddListener),
      py::arg("subscriber"), py::arg("eventMask"), py::arg("listener"), release_gil(), py::doc(
    "Add a listener for changes on a subscriber. The callback\n"
"function is called asynchronously on a separate thread, so it's important\n"
"to use synchronization or atomics when accessing any shared state from the\n"
"callback function. This does NOT keep the subscriber active.\n"
"\n"
":param subscriber: Subscriber\n"
":param eventMask:  Bitmask of EventFlags values\n"
":param listener:   Listener function\n"
"\n"
":returns: Listener handle")
  )
  
  
  
    
  .
def
("addListener", static_cast<NT_Listener(nt::NetworkTableInstance::*)(MultiSubscriber&, int, ListenerCallback)>(
        &nt::NetworkTableInstance::AddListener),
      py::arg("subscriber"), py::arg("eventMask"), py::arg("listener"), release_gil(), py::doc(
    "Add a listener for changes on a subscriber. The callback\n"
"function is called asynchronously on a separate thread, so it's important\n"
"to use synchronization or atomics when accessing any shared state from the\n"
"callback function. This does NOT keep the subscriber active.\n"
"\n"
":param subscriber: Subscriber\n"
":param eventMask:  Bitmask of EventFlags values\n"
":param listener:   Listener function\n"
"\n"
":returns: Listener handle")
  )
  
  
  
    
  .
def
("addListener", static_cast<NT_Listener(nt::NetworkTableInstance::*)(const NetworkTableEntry&, int, ListenerCallback)>(
        &nt::NetworkTableInstance::AddListener),
      py::arg("entry"), py::arg("eventMask"), py::arg("listener"), release_gil(), py::doc(
    "Add a listener for changes on an entry. The callback function\n"
"is called asynchronously on a separate thread, so it's important to use\n"
"synchronization or atomics when accessing any shared state from the\n"
"callback function.\n"
"\n"
":param entry:     Entry\n"
":param eventMask: Bitmask of EventFlags values\n"
":param listener:  Listener function\n"
"\n"
":returns: Listener handle")
  )
  
  
  
    
  .
def
("addListener", static_cast<NT_Listener(nt::NetworkTableInstance::*)(std::span<const std::string_view>, int, ListenerCallback)>(
        &nt::NetworkTableInstance::AddListener),
      py::arg("prefixes"), py::arg("eventMask"), py::arg("listener"), release_gil(), py::doc(
    "Add a listener for changes to topics with names that start with any\n"
"of the given prefixes. The callback function is called asynchronously on a\n"
"separate thread, so it's important to use synchronization or atomics when\n"
"accessing any shared state from the callback function.\n"
"\n"
"This creates a corresponding internal subscriber with the lifetime of the\n"
"listener.\n"
"\n"
":param prefixes:  Topic name string prefixes\n"
":param eventMask: Bitmask of EventFlags values\n"
":param listener:  Listener function\n"
"\n"
":returns: Listener handle")
  )
  
  
  
    
  .
def
("getNetworkMode", &nt::NetworkTableInstance::GetNetworkMode, release_gil(), py::doc(
    "Get the current network mode.\n"
"\n"
":returns: Bitmask of NetworkMode.")
  )
  
  
  
    
  .
def
("startLocal", [](NetworkTableInstance * self) {
  pyntcore::onInstanceStart(self);
  py::gil_scoped_release release;
  self->StartLocal();
}
, py::doc(
    "Starts local-only operation.  Prevents calls to StartServer or StartClient\n"
"from taking effect.  Has no effect if StartServer or StartClient\n"
"has already been called.")
  )
  
  
  
    
  .
def
("stopLocal", &nt::NetworkTableInstance::StopLocal, release_gil(), py::doc(
    "Stops local-only operation.  StartServer or StartClient can be called after\n"
"this call to start a server or client.")
  )
  
  
  
    
  .
def
("startServer", [](NetworkTableInstance * self, std::string_view persist_filename,  const char* listen_address,
   unsigned int port3, unsigned int port4) {
  pyntcore::onInstanceStart(self);
  py::gil_scoped_release release;
  self->StartServer(persist_filename, listen_address, port3, port4);
}
,
      py::arg("persist_filename") = "networktables.json", py::arg("listen_address") = "", py::arg("port3") = kDefaultPort3, py::arg("port4") = kDefaultPort4, py::doc(
    "Starts a server using the specified filename, listening address, and port.\n"
"\n"
":param persist_filename: the name of the persist file to use (UTF-8 string,\n"
"                         null terminated)\n"
":param listen_address:   the address to listen on, or null to listen on any\n"
"                         address (UTF-8 string, null terminated)\n"
":param port3:            port to communicate over (NT3)\n"
":param port4:            port to communicate over (NT4)")
  )
  
  
  
    
  .
def
("stopServer", &nt::NetworkTableInstance::StopServer, release_gil(), py::doc(
    "Stops the server if it is running.")
  )
  
  
  
    
  .
def
("startClient3", [](NetworkTableInstance * self, std::string_view identity) {
  pyntcore::onInstanceStart(self);
  py::gil_scoped_release release;
  self->StartClient3(identity);
}
,
      py::arg("identity"), py::doc(
    "Starts a NT3 client.  Use SetServer or SetServerTeam to set the server name\n"
"and port.\n"
"\n"
":param identity: network identity to advertise (cannot be empty string)")
  )
  
  
  
    
  .
def
("startClient4", [](NetworkTableInstance * self, std::string_view identity) {
  pyntcore::onInstanceStart(self);
  py::gil_scoped_release release;
  self->StartClient4(identity);
}
,
      py::arg("identity"), py::doc(
    "Starts a NT4 client.  Use SetServer or SetServerTeam to set the server name\n"
"and port.\n"
"\n"
":param identity: network identity to advertise (cannot be empty string)")
  )
  
  
  
    
  .
def
("stopClient", &nt::NetworkTableInstance::StopClient, release_gil(), py::doc(
    "Stops the client if it is running.")
  )
  
  
  
    
  .
def
("setServer", static_cast<void(nt::NetworkTableInstance::*)(std::string_view, unsigned int)>(
        &nt::NetworkTableInstance::SetServer),
      py::arg("server_name"), py::arg("port") = 0, release_gil(), py::doc(
    "Sets server address and port for client (without restarting client).\n"
"\n"
":param server_name: server name (UTF-8 string)\n"
":param port:        port to communicate over (0 = default)")
  )
  
  
  
    
  .
def
("setServer", static_cast<void(nt::NetworkTableInstance::*)(std::span<const std::pair<std::string_view, unsigned int>>)>(
        &nt::NetworkTableInstance::SetServer),
      py::arg("servers"), release_gil(), py::doc(
    "Sets server addresses and ports for client (without restarting client).\n"
"The client will attempt to connect to each server in round robin fashion.\n"
"\n"
":param servers: array of server address and port pairs")
  )
  
  
  
    
  .
def
("setServer", static_cast<void(nt::NetworkTableInstance::*)(std::span<const std::string_view>, unsigned int)>(
        &nt::NetworkTableInstance::SetServer),
      py::arg("servers"), py::arg("port") = 0, release_gil(), py::doc(
    "Sets server addresses and port for client (without restarting client).\n"
"The client will attempt to connect to each server in round robin fashion.\n"
"\n"
":param servers: array of server names\n"
":param port:    port to communicate over (0 = default)")
  )
  
  
  
    
  .
def
("setServerTeam", &nt::NetworkTableInstance::SetServerTeam,
      py::arg("team"), py::arg("port") = 0, release_gil(), py::doc(
    "Sets server addresses and port for client (without restarting client).\n"
"Connects using commonly known robot addresses for the specified team.\n"
"\n"
":param team: team number\n"
":param port: port to communicate over (0 = default)")
  )
  
  
  
    
  .
def
("disconnect", &nt::NetworkTableInstance::Disconnect, release_gil(), py::doc(
    "Disconnects the client if it's running and connected. This will\n"
"automatically start reconnection attempts to the current server list.")
  )
  
  
  
    
  .
def
("startDSClient", &nt::NetworkTableInstance::StartDSClient,
      py::arg("port") = 0, release_gil(), py::doc(
    "Starts requesting server address from Driver Station.\n"
"This connects to the Driver Station running on localhost to obtain the\n"
"server IP address.\n"
"\n"
":param port: server port to use in combination with IP from DS (0 = default)")
  )
  
  
  
    
  .
def
("stopDSClient", &nt::NetworkTableInstance::StopDSClient, release_gil(), py::doc(
    "Stops requesting server address from Driver Station.")
  )
  
  
  
    
  .
def
("flushLocal", &nt::NetworkTableInstance::FlushLocal, release_gil(), py::doc(
    "Flushes all updated values immediately to the local client/server. This\n"
"does not flush to the network.")
  )
  
  
  
    
  .
def
("flush", &nt::NetworkTableInstance::Flush, release_gil(), py::doc(
    "Flushes all updated values immediately to the network.\n"
".. note:: This is rate-limited to protect the network from flooding.\n"
"   This is primarily useful for synchronizing network updates with\n"
"   user code.")
  )
  
  
  
    
  .
def
("getConnections", &nt::NetworkTableInstance::GetConnections, release_gil(), py::doc(
    "Get information on the currently established network connections.\n"
"If operating as a client, this will return either zero or one values.\n"
"\n"
":returns: array of connection information")
  )
  
  
  
    
  .
def
("isConnected", &nt::NetworkTableInstance::IsConnected, release_gil(), py::doc(
    "Return whether or not the instance is connected to another node.\n"
"\n"
":returns: True if connected.")
  )
  
  
  
    
  .
def
("getServerTimeOffset", &nt::NetworkTableInstance::GetServerTimeOffset, release_gil(), py::doc(
    "Get the time offset between server time and local time. Add this value to\n"
"local time to get the estimated equivalent server time. In server mode,\n"
"this always returns 0. In client mode, this returns the time offset only if\n"
"the client and server are connected and have exchanged synchronization\n"
"messages. Note the time offset may change over time as it is periodically\n"
"updated; to receive updates as events, add a listener to the \"time sync\"\n"
"event.\n"
"\n"
":returns: Time offset in microseconds (optional)")
  )
  
  
  
    
  .
def
("startEntryDataLog", &nt::NetworkTableInstance::StartEntryDataLog,
      py::arg("log"), py::arg("prefix"), py::arg("logPrefix"), release_gil(), py::doc(
    "Starts logging entry changes to a DataLog.\n"
"\n"
":param log:       data log object; lifetime must extend until StopEntryDataLog is\n"
"                  called or the instance is destroyed\n"
":param prefix:    only store entries with names that start with this prefix;\n"
"                  the prefix is not included in the data log entry name\n"
":param logPrefix: prefix to add to data log entry names\n"
"\n"
":returns: Data logger handle")
  )
  
  
  
    
  .
def_static
("stopEntryDataLog", &nt::NetworkTableInstance::StopEntryDataLog,
      py::arg("logger"), release_gil(), py::doc(
    "Stops logging entry changes to a DataLog.\n"
"\n"
":param logger: data logger handle")
  )
  
  
  
    
  .
def
("startConnectionDataLog", &nt::NetworkTableInstance::StartConnectionDataLog,
      py::arg("log"), py::arg("name"), release_gil(), py::doc(
    "Starts logging connection changes to a DataLog.\n"
"\n"
":param log:  data log object; lifetime must extend until\n"
"             StopConnectionDataLog is called or the instance is destroyed\n"
":param name: data log entry name\n"
"\n"
":returns: Data logger handle")
  )
  
  
  
    
  .
def_static
("stopConnectionDataLog", &nt::NetworkTableInstance::StopConnectionDataLog,
      py::arg("logger"), release_gil(), py::doc(
    "Stops logging connection changes to a DataLog.\n"
"\n"
":param logger: data logger handle")
  )
  
  
  
    
  .
def
("addLogger", &nt::NetworkTableInstance::AddLogger,
      py::arg("minLevel"), py::arg("maxLevel"), py::arg("func"), release_gil(), py::doc(
    "Add logger callback function.  By default, log messages are sent to stderr;\n"
"this function sends log messages with the specified levels to the provided\n"
"callback function instead.  The callback function will only be called for\n"
"log messages with level greater than or equal to minLevel and less than or\n"
"equal to maxLevel; messages outside this range will be silently ignored.\n"
"\n"
":param minLevel: minimum log level\n"
":param maxLevel: maximum log level\n"
":param func:     callback function\n"
"\n"
":returns: Listener handle")
  )
  
  
  
    
  .
def
("hasSchema", &nt::NetworkTableInstance::HasSchema,
      py::arg("name"), release_gil(), py::doc(
    "Returns whether there is a data schema already registered with the given\n"
"name. This does NOT perform a check as to whether the schema has already\n"
"been published by another node on the network.\n"
"\n"
":param name: Name (the string passed as the data type for topics using this\n"
"             schema)\n"
"\n"
":returns: True if schema already registered")
  )
  
  
  
    
  .
def
("addSchema", static_cast<void(nt::NetworkTableInstance::*)(std::string_view, std::string_view, std::span<const uint8_t>)>(
        &nt::NetworkTableInstance::AddSchema),
      py::arg("name"), py::arg("type"), py::arg("schema"), release_gil(), py::doc(
    "Registers a data schema.  Data schemas provide information for how a\n"
"certain data type string can be decoded.  The type string of a data schema\n"
"indicates the type of the schema itself (e.g. \"protobuf\" for protobuf\n"
"schemas, \"struct\" for struct schemas, etc). In NetworkTables, schemas are\n"
"published just like normal topics, with the name being generated from the\n"
"provided name: \"/.schema/<name>\".  Duplicate calls to this function with\n"
"the same name are silently ignored.\n"
"\n"
":param name:   Name (the string passed as the data type for topics using this\n"
"               schema)\n"
":param type:   Type of schema (e.g. \"protobuf\", \"struct\", etc)\n"
":param schema: Schema data")
  )
  
  
  
    
  .
def
("addSchema", static_cast<void(nt::NetworkTableInstance::*)(std::string_view, std::string_view, std::string_view)>(
        &nt::NetworkTableInstance::AddSchema),
      py::arg("name"), py::arg("type"), py::arg("schema"), release_gil(), py::doc(
    "Registers a data schema.  Data schemas provide information for how a\n"
"certain data type string can be decoded.  The type string of a data schema\n"
"indicates the type of the schema itself (e.g. \"protobuf\" for protobuf\n"
"schemas, \"struct\" for struct schemas, etc). In NetworkTables, schemas are\n"
"published just like normal topics, with the name being generated from the\n"
"provided name: \"/.schema/<name>\".  Duplicate calls to this function with\n"
"the same name are silently ignored.\n"
"\n"
":param name:   Name (the string passed as the data type for topics using this\n"
"               schema)\n"
":param type:   Type of schema (e.g. \"protobuf\", \"struct\", etc)\n"
":param schema: Schema data")
  )
  
  
  
    
  .def(py::self == py::self, py::doc(
    "Equality operator.  Returns true if both instances refer to the same\n"
"native handle.")
  )
  
  
  
    .def_readonly_static("kDefaultPort3", &nt::NetworkTableInstance::kDefaultPort3, py::doc(
    "The default port that network tables operates on for NT3."))
  
    .def_readonly_static("kDefaultPort4", &nt::NetworkTableInstance::kDefaultPort4, py::doc(
    "The default port that network tables operates on for NT4."))
  .def("configPythonLogging", [](NetworkTableInstance * self, 
  NetworkTableInstance::LogLevel minLevel, NetworkTableInstance::LogLevel maxLevel, py::str logName) {
    py::module::import("ntcore._logutil").attr("_config_logging")(self, minLevel, maxLevel, logName);
  }, py::kw_only(),
    py::arg("min") = NetworkTableInstance::LogLevel::kLogInfo,
    py::arg("max") = NetworkTableInstance::LogLevel::kLogCritical,
    py::arg("name") = "nt",
  py::doc("Configure python logging for this instance.\n"
          "\n"
          ":param min:  Minimum NT level to log\n"
          ":param max:  Maximum NT level to log\n"
          ":param name: Name of python logger\n"
          "\n"
          ".. note:: This must be called before the instance is started")
)
.def("_reset", [](NetworkTableInstance *self) {
  pyntcore::onInstancePreReset(self);
  {
    py::gil_scoped_release release;
    nt::ResetInstance(self->GetHandle());
  }
  pyntcore::onInstancePostReset(self);
})
;

  


  }






}

}; // struct rpybuild_NetworkTableInstance_initializer

static std::unique_ptr<rpybuild_NetworkTableInstance_initializer> cls;

void begin_init_NetworkTableInstance(py::module &m) {
  cls = std::make_unique<rpybuild_NetworkTableInstance_initializer>(m);
}

void finish_init_NetworkTableInstance() {
  cls->finish();
  cls.reset();
}