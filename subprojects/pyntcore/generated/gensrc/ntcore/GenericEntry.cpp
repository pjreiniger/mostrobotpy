
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <networktables/GenericEntry.h>


#include <pybind11/stl.h>

#include <wpi_span_type_caster.h>







#define RPYGEN_ENABLE_nt__GenericSubscriber_PROTECTED_CONSTRUCTORS
#include <rpygen/nt__GenericSubscriber.hpp>

#define RPYGEN_ENABLE_nt__GenericPublisher_PROTECTED_CONSTRUCTORS
#include <rpygen/nt__GenericPublisher.hpp>







#include <src/nt_type_caster.h>



#include <type_traits>


  using namespace nt;



struct rpybuild_GenericEntry_initializer {


  

  


  

  


  

  












  
  using GenericSubscriber_Trampoline = rpygen::PyTrampoline_nt__GenericSubscriber<typename nt::GenericSubscriber, typename rpygen::PyTrampolineCfg_nt__GenericSubscriber<>>;
    static_assert(std::is_abstract<GenericSubscriber_Trampoline>::value == false, "nt::GenericSubscriber " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename nt::GenericSubscriber, GenericSubscriber_Trampoline, nt::Subscriber> cls_GenericSubscriber;

    

    
    
  
  using GenericPublisher_Trampoline = rpygen::PyTrampoline_nt__GenericPublisher<typename nt::GenericPublisher, typename rpygen::PyTrampolineCfg_nt__GenericPublisher<>>;
    static_assert(std::is_abstract<GenericPublisher_Trampoline>::value == false, "nt::GenericPublisher " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename nt::GenericPublisher, GenericPublisher_Trampoline, nt::Publisher> cls_GenericPublisher;

    

    
    
  py::class_<typename nt::GenericEntry, nt::GenericSubscriber, nt::GenericPublisher> cls_GenericEntry;

    

    
    

  py::module &m;

  
  rpybuild_GenericEntry_initializer(py::module &m) :

  

  

  

  
    cls_GenericSubscriber(m, "GenericSubscriber"),

  

  
  
  
    cls_GenericPublisher(m, "GenericPublisher"),

  

  
  
  
    cls_GenericEntry(m, "GenericEntry", py::is_final()),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
    
  

    
    
    
  

    
    
  }

void finish() {





  {
  
  
  
    using TopicType [[maybe_unused]] = typename nt::GenericSubscriber::TopicType;
  
    using ValueType [[maybe_unused]] = typename nt::GenericSubscriber::ValueType;
  
    using ParamType [[maybe_unused]] = typename nt::GenericSubscriber::ParamType;
  
    using TimestampedValueType [[maybe_unused]] = typename nt::GenericSubscriber::TimestampedValueType;
  


  

  cls_GenericSubscriber.doc() =
    "NetworkTables generic subscriber.";

  cls_GenericSubscriber
  
    
  .
def
("get", &nt::GenericSubscriber::Get, release_gil(), py::doc(
    "Get the last published value.\n"
"If no value has been published, returns a value with unassigned type.\n"
"\n"
":returns: value")
  )
  
  
  
    
  .
def
("getBoolean", &nt::GenericSubscriber::GetBoolean,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Gets the entry's value as a boolean. If the entry does not exist or is of\n"
"different type, it will return the default value.\n"
"\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the entry's value or the given default value")
  )
  
  
  
    
  .
def
("getInteger", &nt::GenericSubscriber::GetInteger,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Gets the entry's value as a integer. If the entry does not exist or is of\n"
"different type, it will return the default value.\n"
"\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the entry's value or the given default value")
  )
  
  
  
    
  .
def
("getFloat", &nt::GenericSubscriber::GetFloat,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Gets the entry's value as a float. If the entry does not exist or is of\n"
"different type, it will return the default value.\n"
"\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the entry's value or the given default value")
  )
  
  
  
    
  .
def
("getDouble", &nt::GenericSubscriber::GetDouble,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Gets the entry's value as a double. If the entry does not exist or is of\n"
"different type, it will return the default value.\n"
"\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the entry's value or the given default value")
  )
  
  
  
    
  .
def
("getString", &nt::GenericSubscriber::GetString,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Gets the entry's value as a string. If the entry does not exist or is of\n"
"different type, it will return the default value.\n"
"\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the entry's value or the given default value")
  )
  
  
  
    
  .
def
("getRaw", &nt::GenericSubscriber::GetRaw,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Gets the entry's value as a raw. If the entry does not exist or is of\n"
"different type, it will return the default value.\n"
"\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the entry's value or the given default value")
  )
  
  
  
    
  .
def
("getBooleanArray", &nt::GenericSubscriber::GetBooleanArray,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Gets the entry's value as a boolean array. If the entry does not exist\n"
"or is of different type, it will return the default value.\n"
"\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the entry's value or the given default value\n"
"          \n"
"          .. note:: This makes a copy of the array.  If the overhead of this is a\n"
"             concern, use GetValue() instead.\n"
"          \n"
"          .. note:: The returned array is std::vector<int> instead of std::vector<bool>\n"
"             because std::vector<bool> is special-cased in C++.  0 is false, any\n"
"             non-zero value is true.")
  )
  
  
  
    
  .
def
("getIntegerArray", &nt::GenericSubscriber::GetIntegerArray,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Gets the entry's value as a integer array. If the entry does not exist\n"
"or is of different type, it will return the default value.\n"
"\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the entry's value or the given default value\n"
"          \n"
"          .. note:: This makes a copy of the array.  If the overhead of this is a\n"
"             concern, use GetValue() instead.")
  )
  
  
  
    
  .
def
("getFloatArray", &nt::GenericSubscriber::GetFloatArray,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Gets the entry's value as a float array. If the entry does not exist\n"
"or is of different type, it will return the default value.\n"
"\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the entry's value or the given default value\n"
"          \n"
"          .. note:: This makes a copy of the array.  If the overhead of this is a\n"
"             concern, use GetValue() instead.")
  )
  
  
  
    
  .
def
("getDoubleArray", &nt::GenericSubscriber::GetDoubleArray,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Gets the entry's value as a double array. If the entry does not exist\n"
"or is of different type, it will return the default value.\n"
"\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the entry's value or the given default value\n"
"          \n"
"          .. note:: This makes a copy of the array.  If the overhead of this is a\n"
"             concern, use GetValue() instead.")
  )
  
  
  
    
  .
def
("getStringArray", &nt::GenericSubscriber::GetStringArray,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Gets the entry's value as a string array. If the entry does not exist\n"
"or is of different type, it will return the default value.\n"
"\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the entry's value or the given default value\n"
"          \n"
"          .. note:: This makes a copy of the array.  If the overhead of this is a\n"
"             concern, use GetValue() instead.")
  )
  
  
  
    
  .
def
("readQueue", &nt::GenericSubscriber::ReadQueue, release_gil(), py::doc(
    "Get an array of all value changes since the last call to ReadQueue.\n"
"Also provides a timestamp for each value.\n"
"\n"
".. note:: The \"poll storage\" subscribe option can be used to set the queue\n"
"   depth.\n"
"\n"
":returns: Array of timestamped values; empty array if no new changes have\n"
"          been published since the previous call.")
  )
  
  
  
    
  .
def
("getTopic", &nt::GenericSubscriber::GetTopic, release_gil(), py::doc(
    "Get the corresponding topic.\n"
"\n"
":returns: Topic")
  )
  
  
  ;

  


  }

  {
  
  
  
    using TopicType [[maybe_unused]] = typename nt::GenericPublisher::TopicType;
  
    using ValueType [[maybe_unused]] = typename nt::GenericPublisher::ValueType;
  
    using ParamType [[maybe_unused]] = typename nt::GenericPublisher::ParamType;
  
    using TimestampedValueType [[maybe_unused]] = typename nt::GenericPublisher::TimestampedValueType;
  


  

  cls_GenericPublisher.doc() =
    "NetworkTables generic publisher.";

  cls_GenericPublisher
  
    
  .
def
("set", &nt::GenericPublisher::Set,
      py::arg("value"), release_gil(), py::doc(
    "Publish a new value.\n"
"\n"
":param value: value to publish")
  )
  
  
  
    
  .
def
("setBoolean", &nt::GenericPublisher::SetBoolean,
      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
    "Sets the entry's value.\n"
"\n"
":param value: the value to set\n"
":param time:  the timestamp to set (0 = nt::Now())\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setInteger", &nt::GenericPublisher::SetInteger,
      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
    "Sets the entry's value.\n"
"\n"
":param value: the value to set\n"
":param time:  the timestamp to set (0 = nt::Now())\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setFloat", &nt::GenericPublisher::SetFloat,
      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
    "Sets the entry's value.\n"
"\n"
":param value: the value to set\n"
":param time:  the timestamp to set (0 = nt::Now())\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setDouble", &nt::GenericPublisher::SetDouble,
      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
    "Sets the entry's value.\n"
"\n"
":param value: the value to set\n"
":param time:  the timestamp to set (0 = nt::Now())\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setString", &nt::GenericPublisher::SetString,
      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
    "Sets the entry's value.\n"
"\n"
":param value: the value to set\n"
":param time:  the timestamp to set (0 = nt::Now())\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setRaw", &nt::GenericPublisher::SetRaw,
      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
    "Sets the entry's value.\n"
"\n"
":param value: the value to set\n"
":param time:  the timestamp to set (0 = nt::Now())\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setBooleanArray", static_cast<bool(nt::GenericPublisher::*)(std::span<const bool>, int64_t)>(
        &nt::GenericPublisher::SetBooleanArray),
      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
    "Sets the entry's value.\n"
"\n"
":param value: the value to set\n"
":param time:  the timestamp to set (0 = nt::Now())\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setBooleanArray", static_cast<bool(nt::GenericPublisher::*)(std::span<const int>, int64_t)>(
        &nt::GenericPublisher::SetBooleanArray),
      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
    "Sets the entry's value.\n"
"\n"
":param value: the value to set\n"
":param time:  the timestamp to set (0 = nt::Now())\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setIntegerArray", &nt::GenericPublisher::SetIntegerArray,
      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
    "Sets the entry's value.\n"
"\n"
":param value: the value to set\n"
":param time:  the timestamp to set (0 = nt::Now())\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setFloatArray", &nt::GenericPublisher::SetFloatArray,
      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
    "Sets the entry's value.\n"
"\n"
":param value: the value to set\n"
":param time:  the timestamp to set (0 = nt::Now())\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setDoubleArray", &nt::GenericPublisher::SetDoubleArray,
      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
    "Sets the entry's value.\n"
"\n"
":param value: the value to set\n"
":param time:  the timestamp to set (0 = nt::Now())\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setStringArray", &nt::GenericPublisher::SetStringArray,
      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
    "Sets the entry's value.\n"
"\n"
":param value: the value to set\n"
":param time:  the timestamp to set (0 = nt::Now())\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setDefault", &nt::GenericPublisher::SetDefault,
      py::arg("value"), release_gil(), py::doc(
    "Publish a default value.\n"
"On reconnect, a default value will never be used in preference to a\n"
"published value.\n"
"\n"
":param value: value")
  )
  
  
  
    
  .
def
("setDefaultBoolean", &nt::GenericPublisher::SetDefaultBoolean,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Sets the entry's value if it does not exist.\n"
"\n"
":param defaultValue: the default value to set\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setDefaultInteger", &nt::GenericPublisher::SetDefaultInteger,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Sets the entry's value if it does not exist.\n"
"\n"
":param defaultValue: the default value to set\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setDefaultFloat", &nt::GenericPublisher::SetDefaultFloat,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Sets the entry's value if it does not exist.\n"
"\n"
":param defaultValue: the default value to set\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setDefaultDouble", &nt::GenericPublisher::SetDefaultDouble,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Sets the entry's value if it does not exist.\n"
"\n"
":param defaultValue: the default value to set\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setDefaultString", &nt::GenericPublisher::SetDefaultString,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Sets the entry's value if it does not exist.\n"
"\n"
":param defaultValue: the default value to set\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setDefaultRaw", &nt::GenericPublisher::SetDefaultRaw,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Sets the entry's value if it does not exist.\n"
"\n"
":param defaultValue: the default value to set\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setDefaultBooleanArray", &nt::GenericPublisher::SetDefaultBooleanArray,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Sets the entry's value if it does not exist.\n"
"\n"
":param defaultValue: the default value to set\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setDefaultIntegerArray", &nt::GenericPublisher::SetDefaultIntegerArray,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Sets the entry's value if it does not exist.\n"
"\n"
":param defaultValue: the default value to set\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setDefaultFloatArray", &nt::GenericPublisher::SetDefaultFloatArray,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Sets the entry's value if it does not exist.\n"
"\n"
":param defaultValue: the default value to set\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setDefaultDoubleArray", &nt::GenericPublisher::SetDefaultDoubleArray,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Sets the entry's value if it does not exist.\n"
"\n"
":param defaultValue: the default value to set\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setDefaultStringArray", &nt::GenericPublisher::SetDefaultStringArray,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Sets the entry's value if it does not exist.\n"
"\n"
":param defaultValue: the default value to set\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("getTopic", &nt::GenericPublisher::GetTopic, release_gil(), py::doc(
    "Get the corresponding topic.\n"
"\n"
":returns: Topic")
  )
  
  
  ;

  


  }

  {
  
  
  
    using SubscriberType [[maybe_unused]] = typename nt::GenericEntry::SubscriberType;
  
    using PublisherType [[maybe_unused]] = typename nt::GenericEntry::PublisherType;
  
    using TopicType [[maybe_unused]] = typename nt::GenericEntry::TopicType;
  
    using ValueType [[maybe_unused]] = typename nt::GenericEntry::ValueType;
  
    using ParamType [[maybe_unused]] = typename nt::GenericEntry::ParamType;
  
    using TimestampedValueType [[maybe_unused]] = typename nt::GenericEntry::TimestampedValueType;
  


  

  cls_GenericEntry.doc() =
    "NetworkTables generic entry.\n"
"\n"
".. note:: Unlike NetworkTableEntry, the entry goes away when this is destroyed.";

  cls_GenericEntry
  
    
  .
def
("getTopic", &nt::GenericEntry::GetTopic, release_gil(), py::doc(
    "Get the corresponding topic.\n"
"\n"
":returns: Topic")
  )
  
  
  
    
  .
def
("unpublish", &nt::GenericEntry::Unpublish, release_gil(), py::doc(
    "Stops publishing the entry if it's published.")
  )
  
  
  .def("close", [](GenericEntry *self) {
  py::gil_scoped_release release;
  *self = GenericEntry();
}, py::doc("Destroys the entry"))
.def("__enter__", [](GenericEntry *self) {
  return self;
})
.def("__exit__", [](GenericEntry *self, py::args args) {
  py::gil_scoped_release release;
  *self = GenericEntry();
})
;

  


  }






}

}; // struct rpybuild_GenericEntry_initializer

static std::unique_ptr<rpybuild_GenericEntry_initializer> cls;

void begin_init_GenericEntry(py::module &m) {
  cls = std::make_unique<rpybuild_GenericEntry_initializer>(m);
}

void finish_init_GenericEntry() {
  cls->finish();
  cls.reset();
}