
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <networktables/NetworkTableEntry.h>


#include <pybind11/stl.h>

#include <wpi_span_type_caster.h>



#include <pybind11/operators.h>











#include <networktables/NetworkTableInstance.h>

#include <networktables/Topic.h>

#include <src/py2value.h>

#include <src/pyentry.h>



#include <type_traits>


  using namespace nt;



struct rpybuild_NetworkTableEntry_initializer {


  

  












  py::class_<typename nt::NetworkTableEntry> cls_NetworkTableEntry;

    

    
    

  py::module &m;

  
  rpybuild_NetworkTableEntry_initializer(py::module &m) :

  

  

  

  
    cls_NetworkTableEntry(m, "NetworkTableEntry", py::is_final()),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_NetworkTableEntry.doc() =
    "NetworkTables Entry\n"
"\n"
".. note:: For backwards compatibility, the NetworkTableEntry destructor does not\n"
"   release the entry.\n"
"\n"
"@ingroup ntcore_cpp_api";

  cls_NetworkTableEntry
  
    
  .
def
("getInstance", &nt::NetworkTableEntry::GetInstance, release_gil(), py::doc(
    "Gets the instance for the entry.\n"
"\n"
":returns: Instance")
  )
  
  
  
    
  .
def
("exists", &nt::NetworkTableEntry::Exists, release_gil(), py::doc(
    "Determines if the entry currently exists.\n"
"\n"
":returns: True if the entry exists, false otherwise.")
  )
  
  
  
    
  .
def
("getName", &nt::NetworkTableEntry::GetName, release_gil(), py::doc(
    "Gets the name of the entry (the key).\n"
"\n"
":returns: the entry's name")
  )
  
  
  
    
  .
def
("getType", &nt::NetworkTableEntry::GetType, release_gil(), py::doc(
    "Gets the type of the entry.\n"
"\n"
":returns: the entry's type")
  )
  
  
  
    
  .
def
("getLastChange", &nt::NetworkTableEntry::GetLastChange, release_gil(), py::doc(
    "Gets the last time the entry's value was changed.\n"
"\n"
":returns: Entry last change time")
  )
  
  
  
    
  .
def
("getValue", &nt::NetworkTableEntry::GetValue, release_gil(), py::doc(
    "Gets the entry's value. If the entry does not exist, returns an empty\n"
"value.\n"
"\n"
":returns: the entry's value or an empty value if it does not exist.")
  )
  
  
  
    
  .
def
("getBoolean", &pyntcore::GetBooleanEntry
,
      py::arg("defaultValue"), py::doc(
    "Gets the entry's value as a boolean. If the entry does not exist or is of\n"
"different type, it will return the default value.\n"
"\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the entry's value or the given default value")
  )
  
  
  
    
  .
def
("getInteger", &pyntcore::GetIntegerEntry
,
      py::arg("defaultValue"), py::doc(
    "Gets the entry's value as a integer. If the entry does not exist or is of\n"
"different type, it will return the default value.\n"
"\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the entry's value or the given default value")
  )
  
  
  
    
  .
def
("getFloat", &pyntcore::GetFloatEntry
,
      py::arg("defaultValue"), py::doc(
    "Gets the entry's value as a float. If the entry does not exist or is of\n"
"different type, it will return the default value.\n"
"\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the entry's value or the given default value")
  )
  
  
  
    
  .
def
("getDouble", &pyntcore::GetDoubleEntry
,
      py::arg("defaultValue"), py::doc(
    "Gets the entry's value as a double. If the entry does not exist or is of\n"
"different type, it will return the default value.\n"
"\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the entry's value or the given default value")
  )
  
  
  
    
  .
def
("getString", &pyntcore::GetStringEntry
,
      py::arg("defaultValue"), py::doc(
    "Gets the entry's value as a string. If the entry does not exist or is of\n"
"different type, it will return the default value.\n"
"\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the entry's value or the given default value")
  )
  
  
  
    
  .
def
("getRaw", &pyntcore::GetRawEntry
,
      py::arg("defaultValue"), py::doc(
    "Gets the entry's value as a raw. If the entry does not exist or is of\n"
"different type, it will return the default value.\n"
"\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the entry's value or the given default value")
  )
  
  
  
    
  .
def
("getBooleanArray", &pyntcore::GetBooleanArrayEntry
,
      py::arg("defaultValue"), py::doc(
    "Gets the entry's value as a boolean array. If the entry does not exist\n"
"or is of different type, it will return the default value.\n"
"\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the entry's value or the given default value\n"
"          \n"
"          .. note:: This makes a copy of the array.  If the overhead of this is a\n"
"             concern, use GetValue() instead.\n"
"          \n"
"          .. note:: The returned array is std::vector<int> instead of std::vector<bool>\n"
"             because std::vector<bool> is special-cased in C++.  0 is false, any\n"
"             non-zero value is true.")
  )
  
  
  
    
  .
def
("getIntegerArray", &pyntcore::GetIntegerArrayEntry
,
      py::arg("defaultValue"), py::doc(
    "Gets the entry's value as a integer array. If the entry does not exist\n"
"or is of different type, it will return the default value.\n"
"\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the entry's value or the given default value\n"
"          \n"
"          .. note:: This makes a copy of the array.  If the overhead of this is a\n"
"             concern, use GetValue() instead.")
  )
  
  
  
    
  .
def
("getFloatArray", &pyntcore::GetFloatArrayEntry
,
      py::arg("defaultValue"), py::doc(
    "Gets the entry's value as a float array. If the entry does not exist\n"
"or is of different type, it will return the default value.\n"
"\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the entry's value or the given default value\n"
"          \n"
"          .. note:: This makes a copy of the array.  If the overhead of this is a\n"
"             concern, use GetValue() instead.")
  )
  
  
  
    
  .
def
("getDoubleArray", &pyntcore::GetDoubleArrayEntry
,
      py::arg("defaultValue"), py::doc(
    "Gets the entry's value as a double array. If the entry does not exist\n"
"or is of different type, it will return the default value.\n"
"\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the entry's value or the given default value\n"
"          \n"
"          .. note:: This makes a copy of the array.  If the overhead of this is a\n"
"             concern, use GetValue() instead.")
  )
  
  
  
    
  .
def
("getStringArray", &pyntcore::GetStringArrayEntry
,
      py::arg("defaultValue"), py::doc(
    "Gets the entry's value as a string array. If the entry does not exist\n"
"or is of different type, it will return the default value.\n"
"\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the entry's value or the given default value\n"
"          \n"
"          .. note:: This makes a copy of the array.  If the overhead of this is a\n"
"             concern, use GetValue() instead.")
  )
  
  
  
    
  .
def
("readQueue", &nt::NetworkTableEntry::ReadQueue, release_gil(), py::doc(
    "Get an array of all value changes since the last call to ReadQueue.\n"
"\n"
"The \"poll storage\" subscribe option can be used to set the queue depth.\n"
"\n"
":returns: Array of values; empty array if no new changes have been\n"
"          published since the previous call.")
  )
  
  
  
    
  .
def
("setDefaultValue", &nt::NetworkTableEntry::SetDefaultValue,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Sets the entry's value if it does not exist.\n"
"\n"
":param defaultValue: the default value to set\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setDefaultBoolean", &nt::NetworkTableEntry::SetDefaultBoolean,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Sets the entry's value if it does not exist.\n"
"\n"
":param defaultValue: the default value to set\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setDefaultInteger", &nt::NetworkTableEntry::SetDefaultInteger,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Sets the entry's value if it does not exist.\n"
"\n"
":param defaultValue: the default value to set\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setDefaultFloat", &nt::NetworkTableEntry::SetDefaultFloat,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Sets the entry's value if it does not exist.\n"
"\n"
":param defaultValue: the default value to set\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setDefaultDouble", &nt::NetworkTableEntry::SetDefaultDouble,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Sets the entry's value if it does not exist.\n"
"\n"
":param defaultValue: the default value to set\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setDefaultString", &nt::NetworkTableEntry::SetDefaultString,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Sets the entry's value if it does not exist.\n"
"\n"
":param defaultValue: the default value to set\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setDefaultRaw", &nt::NetworkTableEntry::SetDefaultRaw,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Sets the entry's value if it does not exist.\n"
"\n"
":param defaultValue: the default value to set\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setDefaultBooleanArray", &nt::NetworkTableEntry::SetDefaultBooleanArray,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Sets the entry's value if it does not exist.\n"
"\n"
":param defaultValue: the default value to set\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setDefaultIntegerArray", &nt::NetworkTableEntry::SetDefaultIntegerArray,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Sets the entry's value if it does not exist.\n"
"\n"
":param defaultValue: the default value to set\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setDefaultFloatArray", &nt::NetworkTableEntry::SetDefaultFloatArray,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Sets the entry's value if it does not exist.\n"
"\n"
":param defaultValue: the default value to set\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setDefaultDoubleArray", &nt::NetworkTableEntry::SetDefaultDoubleArray,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Sets the entry's value if it does not exist.\n"
"\n"
":param defaultValue: the default value to set\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setDefaultStringArray", &nt::NetworkTableEntry::SetDefaultStringArray,
      py::arg("defaultValue"), release_gil(), py::doc(
    "Sets the entry's value if it does not exist.\n"
"\n"
":param defaultValue: the default value to set\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setValue", &nt::NetworkTableEntry::SetValue,
      py::arg("value"), release_gil(), py::doc(
    "Sets the entry's value.\n"
"\n"
":param value: the value to set\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setBoolean", &nt::NetworkTableEntry::SetBoolean,
      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
    "Sets the entry's value.\n"
"\n"
":param value: the value to set\n"
":param time:  the timestamp to set (0 = nt::Now())\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setInteger", &nt::NetworkTableEntry::SetInteger,
      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
    "Sets the entry's value.\n"
"\n"
":param value: the value to set\n"
":param time:  the timestamp to set (0 = nt::Now())\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setFloat", &nt::NetworkTableEntry::SetFloat,
      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
    "Sets the entry's value.\n"
"\n"
":param value: the value to set\n"
":param time:  the timestamp to set (0 = nt::Now())\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setDouble", &nt::NetworkTableEntry::SetDouble,
      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
    "Sets the entry's value.\n"
"\n"
":param value: the value to set\n"
":param time:  the timestamp to set (0 = nt::Now())\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setString", &nt::NetworkTableEntry::SetString,
      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
    "Sets the entry's value.\n"
"\n"
":param value: the value to set\n"
":param time:  the timestamp to set (0 = nt::Now())\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setRaw", &nt::NetworkTableEntry::SetRaw,
      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
    "Sets the entry's value.\n"
"\n"
":param value: the value to set\n"
":param time:  the timestamp to set (0 = nt::Now())\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setBooleanArray", static_cast<bool(nt::NetworkTableEntry::*)(std::span<const bool>, int64_t)>(
        &nt::NetworkTableEntry::SetBooleanArray),
      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
    "Sets the entry's value.\n"
"\n"
":param value: the value to set\n"
":param time:  the timestamp to set (0 = nt::Now())\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setIntegerArray", &nt::NetworkTableEntry::SetIntegerArray,
      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
    "Sets the entry's value.\n"
"\n"
":param value: the value to set\n"
":param time:  the timestamp to set (0 = nt::Now())\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setFloatArray", &nt::NetworkTableEntry::SetFloatArray,
      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
    "Sets the entry's value.\n"
"\n"
":param value: the value to set\n"
":param time:  the timestamp to set (0 = nt::Now())\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setDoubleArray", &nt::NetworkTableEntry::SetDoubleArray,
      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
    "Sets the entry's value.\n"
"\n"
":param value: the value to set\n"
":param time:  the timestamp to set (0 = nt::Now())\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setStringArray", &nt::NetworkTableEntry::SetStringArray,
      py::arg("value"), py::arg("time") = 0, release_gil(), py::doc(
    "Sets the entry's value.\n"
"\n"
":param value: the value to set\n"
":param time:  the timestamp to set (0 = nt::Now())\n"
"\n"
":returns: False if the entry exists with a different type")
  )
  
  
  
    
  .
def
("setPersistent", &nt::NetworkTableEntry::SetPersistent, release_gil(), py::doc(
    "Make value persistent through program restarts.")
  )
  
  
  
    
  .
def
("clearPersistent", &nt::NetworkTableEntry::ClearPersistent, release_gil(), py::doc(
    "Stop making value persistent through program restarts.")
  )
  
  
  
    
  .
def
("isPersistent", &nt::NetworkTableEntry::IsPersistent, release_gil(), py::doc(
    "Returns whether the value is persistent through program restarts.\n"
"\n"
":returns: True if the value is persistent.")
  )
  
  
  
    
  .
def
("unpublish", &nt::NetworkTableEntry::Unpublish, release_gil(), py::doc(
    "Stops publishing the entry if it's been published.")
  )
  
  
  
    
  .
def
("getTopic", &nt::NetworkTableEntry::GetTopic, release_gil(), py::doc(
    "Gets the entry's topic.\n"
"\n"
":returns: Topic")
  )
  
  
  
    
  .def(py::self == py::self, py::doc(
    "Equality operator.  Returns true if both instances refer to the same\n"
"native handle.")
  )
  
  
  ;

  


  }







  #include <src/NetworkTableEntry.cpp.inl>


}

}; // struct rpybuild_NetworkTableEntry_initializer

static std::unique_ptr<rpybuild_NetworkTableEntry_initializer> cls;

void begin_init_NetworkTableEntry(py::module &m) {
  cls = std::make_unique<rpybuild_NetworkTableEntry_initializer>(m);
}

void finish_init_NetworkTableEntry() {
  cls->finish();
  cls.reset();
}