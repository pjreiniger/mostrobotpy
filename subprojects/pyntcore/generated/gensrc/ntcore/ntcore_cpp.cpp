
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <ntcore_cpp.h>


#include <pybind11/functional.h>

#include <pybind11/stl.h>

#include <wpi_json_type_caster.h>

#include <wpi_span_type_caster.h>













#include <pybind11/stl.h>

#include <networktables/Topic.h>



#include <type_traits>


  using namespace wpi;

  using namespace wpi::log;

  using namespace nt;

  using namespace nt::meta;





struct rpybuild_ntcore_cpp_initializer {


  

  


  

  


  

  


  

  


  

  


  

  


  

  


  

  


  

  


  

  


  

  


  

  


  

  


  

  




  py::module pkg_meta;









  py::class_<typename nt::EventFlags> cls_EventFlags;

    

    
    
  py::class_<typename nt::TopicInfo> cls_TopicInfo;

    

    
    
  py::class_<typename nt::ConnectionInfo> cls_ConnectionInfo;

    

    
    
  py::class_<typename nt::ValueEventData> cls_ValueEventData;

    

    
    
  py::class_<typename nt::LogMessage> cls_LogMessage;

    

    
    
  py::class_<typename nt::TimeSyncEventData> cls_TimeSyncEventData;

    

    
    
  py::class_<typename nt::Event> cls_Event;

    

    
    
  py::class_<typename nt::PubSubOptions> cls_PubSubOptions;

    

    
    
  py::class_<typename nt::meta::SubscriberOptions> cls_SubscriberOptions;

    

    
    
  py::class_<typename nt::meta::TopicPublisher> cls_TopicPublisher;

    

    
    
  py::class_<typename nt::meta::TopicSubscriber> cls_TopicSubscriber;

    

    
    
  py::class_<typename nt::meta::ClientPublisher> cls_ClientPublisher;

    

    
    
  py::class_<typename nt::meta::ClientSubscriber> cls_ClientSubscriber;

    

    
    
  py::class_<typename nt::meta::Client> cls_Client;

    

    
    

  py::module &m;

  
  rpybuild_ntcore_cpp_initializer(py::module &m) :

  
    pkg_meta(m.def_submodule("meta")),
  

  

  

  
    cls_EventFlags(m, "EventFlags"),

  

  
  
  
    cls_TopicInfo(m, "TopicInfo"),

  

  
  
  
    cls_ConnectionInfo(m, "ConnectionInfo"),

  

  
  
  
    cls_ValueEventData(m, "ValueEventData"),

  

  
  
  
    cls_LogMessage(m, "LogMessage"),

  

  
  
  
    cls_TimeSyncEventData(m, "TimeSyncEventData"),

  

  
  
  
    cls_Event(m, "Event"),

  

  
  
  
    cls_PubSubOptions(m, "PubSubOptions"),

  

  
  
  
    cls_SubscriberOptions(pkg_meta, "SubscriberOptions"),

  

  
  
  
    cls_TopicPublisher(pkg_meta, "TopicPublisher"),

  

  
  
  
    cls_TopicSubscriber(pkg_meta, "TopicSubscriber"),

  

  
  
  
    cls_ClientPublisher(pkg_meta, "ClientPublisher"),

  

  
  
  
    cls_ClientSubscriber(pkg_meta, "ClientSubscriber"),

  

  
  
  
    cls_Client(pkg_meta, "Client"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
  }

void finish() {





  {
  
  
  
    static constexpr auto kNone [[maybe_unused]] = nt::EventFlags::kNone;
  
    static constexpr auto kImmediate [[maybe_unused]] = nt::EventFlags::kImmediate;
  
    static constexpr auto kConnected [[maybe_unused]] = nt::EventFlags::kConnected;
  
    static constexpr auto kDisconnected [[maybe_unused]] = nt::EventFlags::kDisconnected;
  
    static constexpr auto kConnection [[maybe_unused]] = nt::EventFlags::kConnection;
  
    static constexpr auto kPublish [[maybe_unused]] = nt::EventFlags::kPublish;
  
    static constexpr auto kUnpublish [[maybe_unused]] = nt::EventFlags::kUnpublish;
  
    static constexpr auto kProperties [[maybe_unused]] = nt::EventFlags::kProperties;
  
    static constexpr auto kTopic [[maybe_unused]] = nt::EventFlags::kTopic;
  
    static constexpr auto kValueRemote [[maybe_unused]] = nt::EventFlags::kValueRemote;
  
    static constexpr auto kValueLocal [[maybe_unused]] = nt::EventFlags::kValueLocal;
  
    static constexpr auto kValueAll [[maybe_unused]] = nt::EventFlags::kValueAll;
  
    static constexpr auto kLogMessage [[maybe_unused]] = nt::EventFlags::kLogMessage;
  
    static constexpr auto kTimeSync [[maybe_unused]] = nt::EventFlags::kTimeSync;
  


  

  cls_EventFlags.doc() =
    "Event notification flags.\n"
"\n"
"The flags are a bitmask and must be OR'ed together to indicate the\n"
"combination of events desired to be received.";

  cls_EventFlags
  
    .def_readonly_static("kNone", &nt::EventFlags::kNone)
  
    .def_readonly_static("kImmediate", &nt::EventFlags::kImmediate, py::doc(
    "Initial listener addition.\n"
"Set this flag to receive immediate notification of matches to the\n"
"flag criteria."))
  
    .def_readonly_static("kConnected", &nt::EventFlags::kConnected, py::doc(
    "Client connected (on server, any client connected)."))
  
    .def_readonly_static("kDisconnected", &nt::EventFlags::kDisconnected, py::doc(
    "Client disconnected (on server, any client disconnected)."))
  
    .def_readonly_static("kConnection", &nt::EventFlags::kConnection, py::doc(
    "Any connection event (connect or disconnect)."))
  
    .def_readonly_static("kPublish", &nt::EventFlags::kPublish, py::doc(
    "New topic published."))
  
    .def_readonly_static("kUnpublish", &nt::EventFlags::kUnpublish, py::doc(
    "Topic unpublished."))
  
    .def_readonly_static("kProperties", &nt::EventFlags::kProperties, py::doc(
    "Topic properties changed."))
  
    .def_readonly_static("kTopic", &nt::EventFlags::kTopic, py::doc(
    "Any topic event (publish, unpublish, or properties changed)."))
  
    .def_readonly_static("kValueRemote", &nt::EventFlags::kValueRemote, py::doc(
    "Topic value updated (via network)."))
  
    .def_readonly_static("kValueLocal", &nt::EventFlags::kValueLocal, py::doc(
    "Topic value updated (local)."))
  
    .def_readonly_static("kValueAll", &nt::EventFlags::kValueAll, py::doc(
    "Topic value updated (network or local)."))
  
    .def_readonly_static("kLogMessage", &nt::EventFlags::kLogMessage, py::doc(
    "Log message."))
  
    .def_readonly_static("kTimeSync", &nt::EventFlags::kTimeSync, py::doc(
    "Time synchronized with server."))
  ;

  


  }

  {
  
  
  


  

  cls_TopicInfo.doc() =
    "NetworkTables Topic Information";

  cls_TopicInfo
  
    .def(py::init<>(), release_gil())
  
    
  .
def
("getProperties", &nt::TopicInfo::GetProperties, release_gil(), py::doc(
    "Get topic properties as a JSON object.")
  )
  
  
  
    .def_readwrite("name", &nt::TopicInfo::name, py::doc(
    "Topic name"))
  
    .def_readwrite("type_str", &nt::TopicInfo::type_str, py::doc(
    "Topic type string"))
  
    .def_readwrite("properties", &nt::TopicInfo::properties, py::doc(
    "Topic properties JSON string"))
  .def_property_readonly("topic", [](const TopicInfo &self) {
  return std::make_shared<nt::Topic>(self.topic);
})
.def_property_readonly("type", [](const TopicInfo &self) {
  return nt::NetworkTableType(self.type);
})
.def("__repr__", [](const TopicInfo &self) -> py::str {
  return py::str("<TopicInfo name={} type={}>")
    .format(self.name, self.type_str);
})
;

  


  }

  {
  
  
  


  

  cls_ConnectionInfo.doc() =
    "NetworkTables Connection Information";

  cls_ConnectionInfo
  
    .def(py::init<>(), release_gil())
  
    .def_readwrite("remote_id", &nt::ConnectionInfo::remote_id, py::doc(
    "The remote identifier (as set on the remote node by\n"
"NetworkTableInstance::StartClient4() or nt::StartClient4())."))
  
    .def_readwrite("remote_ip", &nt::ConnectionInfo::remote_ip, py::doc(
    "The IP address of the remote node."))
  
    .def_readwrite("remote_port", &nt::ConnectionInfo::remote_port, py::doc(
    "The port number of the remote node."))
  
    .def_readwrite("last_update", &nt::ConnectionInfo::last_update, py::doc(
    "The last time any update was received from the remote node (same scale as\n"
"returned by nt::Now())."))
  
    .def_readwrite("protocol_version", &nt::ConnectionInfo::protocol_version, py::doc(
    "The protocol version being used for this connection.  This in protocol\n"
"layer format, so 0x0200 = 2.0, 0x0300 = 3.0)."))
  .def("__repr__", [](const ConnectionInfo &self) -> py::str {
  return py::str("<ConnectionInfo id={} addr={}:{} last_update={} protocol={}>")
    .format(self.remote_id, self.remote_ip, self.remote_port, 
            self.last_update, self.protocol_version);
})
;

  


  }

  {
  
  
  


  

  cls_ValueEventData.doc() =
    "NetworkTables Value Event Data";

  cls_ValueEventData
  
    .def_readonly("value", &nt::ValueEventData::value, py::doc(
    "The new value."))
  .def_property_readonly("topic", [](const ValueEventData &self) {
  return std::make_shared<nt::Topic>(self.topic);
})
.def("__repr__", [](const ValueEventData &self) -> py::str {
  auto topicInfo = nt::GetTopicInfo(self.topic);
  return py::str("<ValueEventData topic_name=\"{}\" topic_type={} value={}>")
    .format(topicInfo.name, topicInfo.type_str, self.value);
})
;

  


  }

  {
  
  
  


  

  cls_LogMessage.doc() =
    "NetworkTables log message.";

  cls_LogMessage
  
    .def_readwrite("level", &nt::LogMessage::level, py::doc(
    "Log level of the message.  See NT_LogLevel."))
  
    .def_readonly("filename", &nt::LogMessage::filename, py::doc(
    "The filename of the source file that generated the message."))
  
    .def_readwrite("line", &nt::LogMessage::line, py::doc(
    "The line number in the source file that generated the message."))
  
    .def_readonly("message", &nt::LogMessage::message, py::doc(
    "The message."))
  ;

  


  }

  {
  
  
  


  

  cls_TimeSyncEventData.doc() =
    "NetworkTables time sync event data.";

  cls_TimeSyncEventData
  
    
  .def(py::init<int64_t, int64_t, bool>(),
      py::arg("serverTimeOffset"), py::arg("rtt2"), py::arg("valid"), release_gil()
  )
  
  
  
    .def_readwrite("serverTimeOffset", &nt::TimeSyncEventData::serverTimeOffset, py::doc(
    "Offset between local time and server time, in microseconds. Add this value\n"
"to local time to get the estimated equivalent server time."))
  
    .def_readwrite("rtt2", &nt::TimeSyncEventData::rtt2, py::doc(
    "Measured round trip time divided by 2, in microseconds."))
  
    .def_readwrite("valid", &nt::TimeSyncEventData::valid, py::doc(
    "If serverTimeOffset and RTT are valid. An event with this set to false is\n"
"sent when the client disconnects."))
  ;

  


  }

  {
  
  
  


  

  cls_Event.doc() =
    "NetworkTables event";

  cls_Event
  
    
  .
def
("is_", &nt::Event::Is,
      py::arg("kind"), release_gil(), py::doc(
    "Test event flags.\n"
"\n"
":param kind: event flag(s) to test\n"
"\n"
":returns: True if flags matches kind")
  )
  
  
  
    .def_readonly("listener", &nt::Event::listener, py::doc(
    "Listener that triggered this event."))
  
    .def_readwrite("flags", &nt::Event::flags, py::doc(
    "Event flags (NT_EventFlags). Also indicates the data included with the\n"
"event:\n"
"- NT_EVENT_CONNECTED or NT_EVENT_DISCONNECTED: GetConnectionInfo()\n"
"- NT_EVENT_PUBLISH, NT_EVENT_UNPUBLISH, or NT_EVENT_PROPERTIES:\n"
"GetTopicInfo()\n"
"- NT_EVENT_VALUE, NT_EVENT_VALUE_LOCAL: GetValueData()\n"
"- NT_EVENT_LOGMESSAGE: GetLogMessage()\n"
"- NT_EVENT_TIMESYNC: GetTimeSyncEventData()"))
  .def_property_readonly("data", [](nt::Event *self){
  return self->data;
})
.def("__repr__", [](const nt::Event &self) -> py::str {
  return py::str("<Event listener={} flags={} data={}>")
    .format(self.listener, self.flags, self.data);
})
;

  


  }

  {
  
  
  
    static constexpr auto kDefaultPeriodic [[maybe_unused]] = nt::PubSubOptions::kDefaultPeriodic;
  


  

  cls_PubSubOptions.doc() =
    "NetworkTables publish/subscribe options.";

  cls_PubSubOptions
  
    .def_readonly_static("kDefaultPeriodic", &nt::PubSubOptions::kDefaultPeriodic, py::doc(
    "Default value of periodic."))
  
    .def_readwrite("pollStorage", &nt::PubSubOptions::pollStorage, py::doc(
    "Polling storage size for a subscription. Specifies the maximum number of\n"
"updates NetworkTables should store between calls to the subscriber's\n"
"ReadQueue() function. If zero, defaults to 1 if sendAll is false, 20 if\n"
"sendAll is true."))
  
    .def_readwrite("periodic", &nt::PubSubOptions::periodic, py::doc(
    "How frequently changes will be sent over the network, in seconds.\n"
"NetworkTables may send more frequently than this (e.g. use a combined\n"
"minimum period for all values) or apply a restricted range to this value.\n"
"The default is 100 ms."))
  
    .def_readwrite("excludePublisher", &nt::PubSubOptions::excludePublisher, py::doc(
    "For subscriptions, if non-zero, value updates for ReadQueue() are not\n"
"queued for this publisher."))
  
    .def_readwrite("sendAll", &nt::PubSubOptions::sendAll, py::doc(
    "Send all value changes over the network."))
  
    .def_readwrite("topicsOnly", &nt::PubSubOptions::topicsOnly, py::doc(
    "For subscriptions, don't ask for value changes (only topic announcements)."))
  
    .def_readwrite("keepDuplicates", &nt::PubSubOptions::keepDuplicates, py::doc(
    "Preserve duplicate value changes (rather than ignoring them)."))
  
    .def_readwrite("prefixMatch", &nt::PubSubOptions::prefixMatch, py::doc(
    "Perform prefix match on subscriber topic names. Is ignored/overridden by\n"
"Subscribe() functions; only present in struct for the purposes of getting\n"
"information about subscriptions."))
  
    .def_readwrite("disableRemote", &nt::PubSubOptions::disableRemote, py::doc(
    "For subscriptions, if remote value updates should not be queued for\n"
"ReadQueue(). See also disableLocal."))
  
    .def_readwrite("disableLocal", &nt::PubSubOptions::disableLocal, py::doc(
    "For subscriptions, if local value updates should not be queued for\n"
"ReadQueue(). See also disableRemote."))
  
    .def_readwrite("excludeSelf", &nt::PubSubOptions::excludeSelf, py::doc(
    "For entries, don't queue (for ReadQueue) value updates for the entry's\n"
"internal publisher."))
  
    .def_readwrite("hidden", &nt::PubSubOptions::hidden, py::doc(
    "For subscriptions, don't share the existence of the subscription with the\n"
"network. Note this means updates will not be received from the network\n"
"unless another subscription overlaps with this one, and the subscription\n"
"will not appear in metatopics."))
  // autogenerated by gen-pubsub.py
.def(py::init([](
  unsigned int pollStorage,
  double periodic,
  std::optional<std::shared_ptr<nt::Publisher>> excludePublisher,
  bool sendAll,
  bool topicsOnly,
  bool keepDuplicates,
  bool prefixMatch,
  bool disableRemote,
  bool disableLocal,
  bool excludeSelf,
  bool hidden
) -> nt::PubSubOptions {
  return nt::PubSubOptions{
    .pollStorage = pollStorage,
    .periodic = periodic,
    .excludePublisher = excludePublisher.has_value() ? excludePublisher.value()->GetHandle() : 0,
    .sendAll = sendAll,
    .topicsOnly = topicsOnly,
    .keepDuplicates = keepDuplicates,
    .prefixMatch = prefixMatch,
    .disableRemote = disableRemote,
    .disableLocal = disableLocal,
    .excludeSelf = excludeSelf,
    .hidden = hidden
  };
}),
  py::kw_only(),
  py::arg("pollStorage") = 0,
  py::arg("periodic") = nt::PubSubOptions::kDefaultPeriodic,
  py::arg("excludePublisher") = std::nullopt,
  py::arg("sendAll") = false,
  py::arg("topicsOnly") = false,
  py::arg("keepDuplicates") = false,
  py::arg("prefixMatch") = false,
  py::arg("disableRemote") = false,
  py::arg("disableLocal") = false,
  py::arg("excludeSelf") = false,
  py::arg("hidden") = false,
  R"(
      
      
      :param pollStorage:      Polling storage size for a subscription. Specifies the maximum number of
                               updates NetworkTables should store between calls to the subscriber's
                               ReadQueue() function. If zero, defaults to 1 if sendAll is false, 20 if
                               sendAll is true.
      :param periodic:         How frequently changes will be sent over the network, in seconds.
                               NetworkTables may send more frequently than this (e.g. use a combined
                               minimum period for all values) or apply a restricted range to this value.
                               The default is 100 ms.
      :param excludePublisher: For subscriptions, if non-zero, value updates for ReadQueue() are not
                               queued for this publisher.
      :param sendAll:          Send all value changes over the network.
      :param topicsOnly:       For subscriptions, don't ask for value changes (only topic announcements).
      :param keepDuplicates:   Preserve duplicate value changes (rather than ignoring them).
      :param prefixMatch:      Perform prefix match on subscriber topic names. Is ignored/overridden by
                               Subscribe() functions; only present in struct for the purposes of getting
                               information about subscriptions.
      :param disableRemote:    For subscriptions, if remote value updates should not be queued for
                               ReadQueue(). See also disableLocal.
      :param disableLocal:     For subscriptions, if local value updates should not be queued for
                               ReadQueue(). See also disableRemote.
      :param excludeSelf:      For entries, don't queue (for ReadQueue) value updates for the entry's
                               internal publisher.
      :param hidden:           For subscriptions, don't share the existence of the subscription with the
                               network. Note this means updates will not be received from the network
                               unless another subscription overlaps with this one, and the subscription
                               will not appear in metatopics.
  )"
)
;

  


  }

  {
  
  
  


  

  cls_SubscriberOptions.doc() =
    "Subscriber options. Different from PubSubOptions in this reflects only\n"
"options that are sent over the network.";

  cls_SubscriberOptions
  
    .def(py::init<>(), release_gil())
  
    .def_readwrite("periodic", &nt::meta::SubscriberOptions::periodic)
  
    .def_readwrite("topicsOnly", &nt::meta::SubscriberOptions::topicsOnly)
  
    .def_readwrite("sendAll", &nt::meta::SubscriberOptions::sendAll)
  
    .def_readwrite("prefixMatch", &nt::meta::SubscriberOptions::prefixMatch)
  ;

  


  }

  {
  
  
  


  

  cls_TopicPublisher.doc() =
    "Topic publisher (as published via `$pub$<topic>`).";

  cls_TopicPublisher
  
    .def(py::init<>(), release_gil())
  
    .def_readwrite("client", &nt::meta::TopicPublisher::client)
  
    .def_readwrite("pubuid", &nt::meta::TopicPublisher::pubuid)
  ;

  


  }

  {
  
  
  


  

  cls_TopicSubscriber.doc() =
    "Topic subscriber (as published via `$sub$<topic>`).";

  cls_TopicSubscriber
  
    .def(py::init<>(), release_gil())
  
    .def_readwrite("client", &nt::meta::TopicSubscriber::client)
  
    .def_readwrite("subuid", &nt::meta::TopicSubscriber::subuid)
  
    .def_readwrite("options", &nt::meta::TopicSubscriber::options)
  ;

  


  }

  {
  
  
  


  

  cls_ClientPublisher.doc() =
    "Client publisher (as published via `$clientpub$<client>` or `$serverpub`).";

  cls_ClientPublisher
  
    .def(py::init<>(), release_gil())
  
    .def_readwrite("uid", &nt::meta::ClientPublisher::uid)
  
    .def_readwrite("topic", &nt::meta::ClientPublisher::topic)
  ;

  


  }

  {
  
  
  


  

  cls_ClientSubscriber.doc() =
    "Client subscriber (as published via `$clientsub$<client>` or `$serversub`).";

  cls_ClientSubscriber
  
    .def(py::init<>(), release_gil())
  
    .def_readwrite("uid", &nt::meta::ClientSubscriber::uid)
  
    .def_readwrite("topics", &nt::meta::ClientSubscriber::topics)
  
    .def_readwrite("options", &nt::meta::ClientSubscriber::options)
  ;

  


  }

  {
  
  
  


  

  cls_Client.doc() =
    "Client (as published via `$clients`).";

  cls_Client
  
    .def(py::init<>(), release_gil())
  
    .def_readwrite("id", &nt::meta::Client::id)
  
    .def_readwrite("conn", &nt::meta::Client::conn)
  
    .def_readwrite("version", &nt::meta::Client::version)
  ;

  


  }



m
  .
def
("_removeListener", &nt::RemoveListener,
      py::arg("listener"), release_gil(), py::doc(
    "Removes a listener.\n"
"\n"
":param listener: Listener handle to remove")
  )
  
  ;
m
  .
def
("_now", &nt::Now, release_gil(), py::doc(
    "Returns monotonic current time in 1 us increments.\n"
"This is the same time base used for value and connection timestamps.\n"
"This function by default simply wraps wpi::Now(), but if SetNow() is\n"
"called, this function instead returns the value passed to SetNow();\n"
"this can be used to reduce overhead.\n"
"\n"
":returns: Timestamp")
  )
  
  ;
m
  .
def
("_setNow", &nt::SetNow,
      py::arg("timestamp"), release_gil(), py::doc(
    "Sets the current timestamp used for timestamping values that do not\n"
"provide a timestamp (e.g. a value of 0 is passed).  For consistency,\n"
"it also results in Now() returning the set value.  This should generally\n"
"be used only if the overhead of calling wpi::Now() is a concern.\n"
"If used, it should be called periodically with the value of wpi::Now().\n"
"\n"
":param timestamp: timestamp (1 us increments)")
  )
  
  ;
m
  .
def
("_addPolledLogger", &nt::AddPolledLogger,
      py::arg("poller"), py::arg("min_level"), py::arg("max_level"), release_gil(), py::doc(
    "Set the log level for a log poller.  Events will only be generated for\n"
"log messages with level greater than or equal to min_level and less than or\n"
"equal to max_level; messages outside this range will be silently ignored.\n"
"\n"
":param poller:    poller handle\n"
":param min_level: minimum log level\n"
":param max_level: maximum log level\n"
"\n"
":returns: Logger handle")
  )
  
  ;
pkg_meta
  .
def
("decodeTopicPublishers", &nt::meta::DecodeTopicPublishers,
      py::arg("data"), release_gil(), py::doc(
    "Decodes `$pub$<topic>` meta-topic data.\n"
"\n"
":param data: data contents\n"
"\n"
":returns: Vector of TopicPublishers, or empty optional on decoding error.")
  )
  
  ;
pkg_meta
  .
def
("decodeTopicSubscribers", &nt::meta::DecodeTopicSubscribers,
      py::arg("data"), release_gil(), py::doc(
    "Decodes `$sub$<topic>` meta-topic data.\n"
"\n"
":param data: data contents\n"
"\n"
":returns: Vector of TopicSubscribers, or empty optional on decoding error.")
  )
  
  ;
pkg_meta
  .
def
("decodeClientPublishers", &nt::meta::DecodeClientPublishers,
      py::arg("data"), release_gil(), py::doc(
    "Decodes `$clientpub$<topic>` meta-topic data.\n"
"\n"
":param data: data contents\n"
"\n"
":returns: Vector of ClientPublishers, or empty optional on decoding error.")
  )
  
  ;
pkg_meta
  .
def
("decodeClientSubscribers", &nt::meta::DecodeClientSubscribers,
      py::arg("data"), release_gil(), py::doc(
    "Decodes `$clientsub$<topic>` meta-topic data.\n"
"\n"
":param data: data contents\n"
"\n"
":returns: Vector of ClientSubscribers, or empty optional on decoding error.")
  )
  
  ;
pkg_meta
  .
def
("decodeClients", &nt::meta::DecodeClients,
      py::arg("data"), release_gil(), py::doc(
    "Decodes `$clients` meta-topic data.\n"
"\n"
":param data: data contents\n"
"\n"
":returns: Vector of Clients, or empty optional on decoding error.")
  )
  
  ;



}

}; // struct rpybuild_ntcore_cpp_initializer

static std::unique_ptr<rpybuild_ntcore_cpp_initializer> cls;

void begin_init_ntcore_cpp(py::module &m) {
  cls = std::make_unique<rpybuild_ntcore_cpp_initializer>(m);
}

void finish_init_ntcore_cpp() {
  cls->finish();
  cls.reset();
}