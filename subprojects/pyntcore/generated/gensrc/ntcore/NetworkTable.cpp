
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <networktables/NetworkTable.h>


#include <pybind11/functional.h>

#include <pybind11/stl.h>

#include <wpi_span_type_caster.h>













#include <networktables/BooleanArrayTopic.h>

#include <networktables/BooleanTopic.h>

#include <networktables/DoubleArrayTopic.h>

#include <networktables/DoubleTopic.h>

#include <networktables/FloatArrayTopic.h>

#include <networktables/FloatTopic.h>

#include <networktables/IntegerArrayTopic.h>

#include <networktables/IntegerTopic.h>

#include <networktables/NetworkTableInstance.h>

#include <networktables/RawTopic.h>

#include <networktables/StringArrayTopic.h>

#include <networktables/StringTopic.h>

#include <networktables/StructArrayTopic.h>

#include <networktables/StructTopic.h>

#include <networktables/Topic.h>

#include <src/py2value.h>

#include <src/pyentry.h>

#include <wpystruct.h>



#include <type_traits>


  using namespace nt;



struct rpybuild_NetworkTable_initializer {


  

  












  py::class_<typename nt::NetworkTable> cls_NetworkTable;

    

    
    

  py::module &m;

  
  rpybuild_NetworkTable_initializer(py::module &m) :

  

  

  

  
    cls_NetworkTable(m, "NetworkTable", py::is_final()),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  
    static constexpr auto PATH_SEPARATOR_CHAR [[maybe_unused]] = nt::NetworkTable::PATH_SEPARATOR_CHAR;
  
    using TableEventListener [[maybe_unused]] = typename nt::NetworkTable::TableEventListener;
  
    using SubTableListener [[maybe_unused]] = typename nt::NetworkTable::SubTableListener;
  


  

  cls_NetworkTable.doc() =
    "A network table that knows its subtable path.\n"
"@ingroup ntcore_cpp_api";

  cls_NetworkTable
  
    
  .
def_static
("basenameKey", &nt::NetworkTable::BasenameKey,
      py::arg("key"), release_gil(), py::doc(
    "Gets the \"base name\" of a key. For example, \"/foo/bar\" becomes \"bar\".\n"
"If the key has a trailing slash, returns an empty string.\n"
"\n"
":param key: key\n"
"\n"
":returns: base name")
  )
  
  
  
    
  .
def_static
("normalizeKey", static_cast<std::string(*)(std::string_view, bool)>(
        &nt::NetworkTable::NormalizeKey),
      py::arg("key"), py::arg("withLeadingSlash") = true, release_gil(), py::doc(
    "Normalizes an network table key to contain no consecutive slashes and\n"
"optionally start with a leading slash. For example:\n"
"\n"
"<pre><code>\n"
"normalizeKey(\"/foo/bar\", true)  == \"/foo/bar\"\n"
"normalizeKey(\"foo/bar\", true)   == \"/foo/bar\"\n"
"normalizeKey(\"/foo/bar\", false) == \"foo/bar\"\n"
"normalizeKey(\"foo//bar\", false) == \"foo/bar\"\n"
"</code></pre>\n"
"\n"
":param key:              the key to normalize\n"
":param withLeadingSlash: whether or not the normalized key should begin\n"
"                         with a leading slash\n"
"\n"
":returns: normalized key")
  )
  
  
  
    
  .
def_static
("getHierarchy", &nt::NetworkTable::GetHierarchy,
      py::arg("key"), release_gil(), py::doc(
    "Gets a list of the names of all the super tables of a given key. For\n"
"example, the key \"/foo/bar/baz\" has a hierarchy of \"/\", \"/foo\",\n"
"\"/foo/bar\", and \"/foo/bar/baz\".\n"
"\n"
":param key: the key\n"
"\n"
":returns: List of super tables")
  )
  
  
  
    
  .
def
("getInstance", &nt::NetworkTable::GetInstance, release_gil(), py::doc(
    "Gets the instance for the table.\n"
"\n"
":returns: Instance")
  )
  
  
  
    
  .
def
("getEntry", &nt::NetworkTable::GetEntry,
      py::arg("key"), release_gil(), py::doc(
    "Gets the entry for a subkey.\n"
"\n"
":param key: the key name\n"
"\n"
":returns: Network table entry.")
  )
  
  
  
    
  .
def
("getTopic", &nt::NetworkTable::GetTopic,
      py::arg("name"), release_gil(), py::doc(
    "Get (generic) topic.\n"
"\n"
":param name: topic name\n"
"\n"
":returns: Topic")
  )
  
  
  
    
  .
def
("getBooleanTopic", &nt::NetworkTable::GetBooleanTopic,
      py::arg("name"), release_gil(), py::doc(
    "Get boolean topic.\n"
"\n"
":param name: topic name\n"
"\n"
":returns: BooleanTopic")
  )
  
  
  
    
  .
def
("getIntegerTopic", &nt::NetworkTable::GetIntegerTopic,
      py::arg("name"), release_gil(), py::doc(
    "Get integer topic.\n"
"\n"
":param name: topic name\n"
"\n"
":returns: IntegerTopic")
  )
  
  
  
    
  .
def
("getFloatTopic", &nt::NetworkTable::GetFloatTopic,
      py::arg("name"), release_gil(), py::doc(
    "Get float topic.\n"
"\n"
":param name: topic name\n"
"\n"
":returns: FloatTopic")
  )
  
  
  
    
  .
def
("getDoubleTopic", &nt::NetworkTable::GetDoubleTopic,
      py::arg("name"), release_gil(), py::doc(
    "Get double topic.\n"
"\n"
":param name: topic name\n"
"\n"
":returns: DoubleTopic")
  )
  
  
  
    
  .
def
("getStringTopic", &nt::NetworkTable::GetStringTopic,
      py::arg("name"), release_gil(), py::doc(
    "Get String topic.\n"
"\n"
":param name: topic name\n"
"\n"
":returns: StringTopic")
  )
  
  
  
    
  .
def
("getRawTopic", &nt::NetworkTable::GetRawTopic,
      py::arg("name"), release_gil(), py::doc(
    "Get raw topic.\n"
"\n"
":param name: topic name\n"
"\n"
":returns: BooleanArrayTopic")
  )
  
  
  
    
  .
def
("getBooleanArrayTopic", &nt::NetworkTable::GetBooleanArrayTopic,
      py::arg("name"), release_gil(), py::doc(
    "Get boolean[] topic.\n"
"\n"
":param name: topic name\n"
"\n"
":returns: BooleanArrayTopic")
  )
  
  
  
    
  .
def
("getIntegerArrayTopic", &nt::NetworkTable::GetIntegerArrayTopic,
      py::arg("name"), release_gil(), py::doc(
    "Get integer[] topic.\n"
"\n"
":param name: topic name\n"
"\n"
":returns: IntegerArrayTopic")
  )
  
  
  
    
  .
def
("getFloatArrayTopic", &nt::NetworkTable::GetFloatArrayTopic,
      py::arg("name"), release_gil(), py::doc(
    "Get float[] topic.\n"
"\n"
":param name: topic name\n"
"\n"
":returns: FloatArrayTopic")
  )
  
  
  
    
  .
def
("getDoubleArrayTopic", &nt::NetworkTable::GetDoubleArrayTopic,
      py::arg("name"), release_gil(), py::doc(
    "Get double[] topic.\n"
"\n"
":param name: topic name\n"
"\n"
":returns: DoubleArrayTopic")
  )
  
  
  
    
  .
def
("getStringArrayTopic", &nt::NetworkTable::GetStringArrayTopic,
      py::arg("name"), release_gil(), py::doc(
    "Get String[] topic.\n"
"\n"
":param name: topic name\n"
"\n"
":returns: StringArrayTopic")
  )
  
  
  
    
  .
def
("getStructTopic", [](const NetworkTable &self, std::string_view name, const py::type &t) {
  WPyStructInfo info(t);
  return self.GetStructTopic<WPyStruct, WPyStructInfo>(name, info);
}
,
      py::arg("name"), py::arg("type"), py::doc(
    "Gets a raw struct serialized value topic.\n"
"\n"
":param name: topic name\n"
":param type: optional struct type info\n"
"\n"
":returns: Topic")
  )
  
  
  
    
  .
def
("getStructArrayTopic", [](const NetworkTable &self, std::string_view name, const py::type &t) {
  WPyStructInfo info(t);
  return self.GetStructArrayTopic<WPyStruct, WPyStructInfo>(name, info);
}
,
      py::arg("name"), py::arg("type"), py::doc(
    "Gets a raw struct serialized array topic.\n"
"\n"
":param name: topic name\n"
":param type: optional struct type info\n"
"\n"
":returns: Topic")
  )
  
  
  
    
  .
def
("getSubTable", &nt::NetworkTable::GetSubTable,
      py::arg("key"), release_gil(), py::doc(
    "Returns the table at the specified key. If there is no table at the\n"
"specified key, it will create a new table\n"
"\n"
":param key: the key name\n"
"\n"
":returns: the networktable to be returned")
  )
  
  
  
    
  .
def
("containsKey", &nt::NetworkTable::ContainsKey,
      py::arg("key"), release_gil(), py::doc(
    "Determines whether the given key is in this table.\n"
"\n"
":param key: the key to search for\n"
"\n"
":returns: true if the table as a value assigned to the given key")
  )
  
  
  
    
  .
def
("containsSubTable", &nt::NetworkTable::ContainsSubTable,
      py::arg("key"), release_gil(), py::doc(
    "Determines whether there exists a non-empty subtable for this key\n"
"in this table.\n"
"\n"
":param key: the key to search for\n"
"\n"
":returns: true if there is a subtable with the key which contains at least\n"
"          one key/subtable of its own")
  )
  
  
  
    
  .
def
("getTopicInfo", &nt::NetworkTable::GetTopicInfo,
      py::arg("types") = 0, release_gil(), py::doc(
    "Gets topic information for all keys in the table (not including\n"
"sub-tables).\n"
"\n"
":param types: bitmask of types; 0 is treated as a \"don't care\".\n"
"\n"
":returns: topic information for keys currently in the table")
  )
  
  
  
    
  .
def
("getTopics", &nt::NetworkTable::GetTopics,
      py::arg("types") = 0, release_gil(), py::doc(
    "Gets all topics in the table (not including sub-tables).\n"
"\n"
":param types: bitmask of types; 0 is treated as a \"don't care\".\n"
"\n"
":returns: topic for keys currently in the table")
  )
  
  
  
    
  .
def
("getKeys", &nt::NetworkTable::GetKeys,
      py::arg("types") = 0, release_gil(), py::doc(
    "Gets all keys in the table (not including sub-tables).\n"
"\n"
":param types: bitmask of types; 0 is treated as a \"don't care\".\n"
"\n"
":returns: keys currently in the table")
  )
  
  
  
    
  .
def
("getSubTables", &nt::NetworkTable::GetSubTables, release_gil(), py::doc(
    "Gets the names of all subtables in the table.\n"
"\n"
":returns: subtables currently in the table")
  )
  
  
  
    
  .
def
("setPersistent", &nt::NetworkTable::SetPersistent,
      py::arg("key"), release_gil(), py::doc(
    "Makes a key's value persistent through program restarts.\n"
"\n"
":param key: the key to make persistent")
  )
  
  
  
    
  .
def
("clearPersistent", &nt::NetworkTable::ClearPersistent,
      py::arg("key"), release_gil(), py::doc(
    "Stop making a key's value persistent through program restarts.\n"
"The key cannot be null.\n"
"\n"
":param key: the key name")
  )
  
  
  
    
  .
def
("isPersistent", &nt::NetworkTable::IsPersistent,
      py::arg("key"), release_gil(), py::doc(
    "Returns whether the value is persistent through program restarts.\n"
"The key cannot be null.\n"
"\n"
":param key: the key name")
  )
  
  
  
    
  .
def
("putNumber", &nt::NetworkTable::PutNumber,
      py::arg("key"), py::arg("value"), release_gil(), py::doc(
    "Put a number in the table\n"
"\n"
":param key:   the key to be assigned to\n"
":param value: the value that will be assigned\n"
"\n"
":returns: False if the table key already exists with a different type")
  )
  
  
  
    
  .
def
("setDefaultNumber", &nt::NetworkTable::SetDefaultNumber,
      py::arg("key"), py::arg("defaultValue"), release_gil(), py::doc(
    "Gets the current value in the table, setting it if it does not exist.\n"
"\n"
":param key:          the key\n"
":param defaultValue: the default value to set if key doesn't exist.\n"
"\n"
":returns: False if the table key exists with a different type")
  )
  
  
  
    
  .
def
("getNumber", [](NetworkTable * table, std::string_view key, py::object defaultValue) -> py::object {
  nt::NetworkTableEntry entry;
  {
    py::gil_scoped_release release;
    entry = table->GetEntry(key);
  }
  return pyntcore::GetDoubleEntry(entry, defaultValue);
}
,
      py::arg("key"), py::arg("defaultValue"), py::doc(
    "Gets the number associated with the given name.\n"
"\n"
":param key:          the key to look up\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the value associated with the given key or the given default value\n"
"          if there is no value associated with the key")
  )
  
  
  
    
  .
def
("putString", &nt::NetworkTable::PutString,
      py::arg("key"), py::arg("value"), release_gil(), py::doc(
    "Put a string in the table\n"
"\n"
":param key:   the key to be assigned to\n"
":param value: the value that will be assigned\n"
"\n"
":returns: False if the table key already exists with a different type")
  )
  
  
  
    
  .
def
("setDefaultString", &nt::NetworkTable::SetDefaultString,
      py::arg("key"), py::arg("defaultValue"), release_gil(), py::doc(
    "Gets the current value in the table, setting it if it does not exist.\n"
"\n"
":param key:          the key\n"
":param defaultValue: the default value to set if key doesn't exist.\n"
"\n"
":returns: False if the table key exists with a different type")
  )
  
  
  
    
  .
def
("getString", [](NetworkTable * table, std::string_view key, py::object defaultValue) -> py::object {
  nt::NetworkTableEntry entry;
  {
    py::gil_scoped_release release;
    entry = table->GetEntry(key);
  }
  return pyntcore::GetStringEntry(entry, defaultValue);
}
,
      py::arg("key"), py::arg("defaultValue"), py::doc(
    "Gets the string associated with the given name. If the key does not\n"
"exist or is of different type, it will return the default value.\n"
"\n"
":param key:          the key to look up\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the value associated with the given key or the given default value\n"
"          if there is no value associated with the key")
  )
  
  
  
    
  .
def
("putBoolean", &nt::NetworkTable::PutBoolean,
      py::arg("key"), py::arg("value"), release_gil(), py::doc(
    "Put a boolean in the table\n"
"\n"
":param key:   the key to be assigned to\n"
":param value: the value that will be assigned\n"
"\n"
":returns: False if the table key already exists with a different type")
  )
  
  
  
    
  .
def
("setDefaultBoolean", &nt::NetworkTable::SetDefaultBoolean,
      py::arg("key"), py::arg("defaultValue"), release_gil(), py::doc(
    "Gets the current value in the table, setting it if it does not exist.\n"
"\n"
":param key:          the key\n"
":param defaultValue: the default value to set if key doesn't exist.\n"
"\n"
":returns: False if the table key exists with a different type")
  )
  
  
  
    
  .
def
("getBoolean", [](NetworkTable * table, std::string_view key, py::object defaultValue) -> py::object {
  nt::NetworkTableEntry entry;
  {
    py::gil_scoped_release release;
    entry = table->GetEntry(key);
  }
  return pyntcore::GetBooleanEntry(entry, defaultValue);
}
,
      py::arg("key"), py::arg("defaultValue"), py::doc(
    "Gets the boolean associated with the given name. If the key does not\n"
"exist or is of different type, it will return the default value.\n"
"\n"
":param key:          the key to look up\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the value associated with the given key or the given default value\n"
"          if there is no value associated with the key")
  )
  
  
  
    
  .
def
("putBooleanArray", &nt::NetworkTable::PutBooleanArray,
      py::arg("key"), py::arg("value"), release_gil(), py::doc(
    "Put a boolean array in the table\n"
"\n"
":param key:   the key to be assigned to\n"
":param value: the value that will be assigned\n"
"\n"
":returns: False if the table key already exists with a different type\n"
"          \n"
"          .. note:: The array must be of int's rather than of bool's because\n"
"             std::vector<bool> is special-cased in C++.  0 is false, any\n"
"             non-zero value is true.")
  )
  
  
  
    
  .
def
("setDefaultBooleanArray", &nt::NetworkTable::SetDefaultBooleanArray,
      py::arg("key"), py::arg("defaultValue"), release_gil(), py::doc(
    "Gets the current value in the table, setting it if it does not exist.\n"
"\n"
":param key:          the key\n"
":param defaultValue: the default value to set if key doesn't exist.\n"
"\n"
":returns: False if the table key exists with a different type")
  )
  
  
  
    
  .
def
("getBooleanArray", [](NetworkTable * table, std::string_view key, py::object defaultValue) -> py::object {
  nt::NetworkTableEntry entry;
  {
    py::gil_scoped_release release;
    entry = table->GetEntry(key);
  }
  return pyntcore::GetBooleanArrayEntry(entry, defaultValue);
}
,
      py::arg("key"), py::arg("defaultValue"), py::doc(
    "Returns the boolean array the key maps to. If the key does not exist or is\n"
"of different type, it will return the default value.\n"
"\n"
":param key:          the key to look up\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the value associated with the given key or the given default value\n"
"          if there is no value associated with the key\n"
"          \n"
"          .. note:: This makes a copy of the array.  If the overhead of this is a\n"
"             concern, use GetValue() instead.\n"
"          \n"
"          .. note:: The returned array is std::vector<int> instead of std::vector<bool>\n"
"             because std::vector<bool> is special-cased in C++.  0 is false, any\n"
"             non-zero value is true.")
  )
  
  
  
    
  .
def
("putNumberArray", &nt::NetworkTable::PutNumberArray,
      py::arg("key"), py::arg("value"), release_gil(), py::doc(
    "Put a number array in the table\n"
"\n"
":param key:   the key to be assigned to\n"
":param value: the value that will be assigned\n"
"\n"
":returns: False if the table key already exists with a different type")
  )
  
  
  
    
  .
def
("setDefaultNumberArray", &nt::NetworkTable::SetDefaultNumberArray,
      py::arg("key"), py::arg("defaultValue"), release_gil(), py::doc(
    "Gets the current value in the table, setting it if it does not exist.\n"
"\n"
":param key:          the key\n"
":param defaultValue: the default value to set if key doesn't exist.\n"
"\n"
":returns: False if the table key exists with a different type")
  )
  
  
  
    
  .
def
("getNumberArray", [](NetworkTable * table, std::string_view key, py::object defaultValue) -> py::object {
  nt::NetworkTableEntry entry;
  {
    py::gil_scoped_release release;
    entry = table->GetEntry(key);
  }
  return pyntcore::GetDoubleArrayEntry(entry, defaultValue);
}
,
      py::arg("key"), py::arg("defaultValue"), py::doc(
    "Returns the number array the key maps to. If the key does not exist or is\n"
"of different type, it will return the default value.\n"
"\n"
":param key:          the key to look up\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the value associated with the given key or the given default value\n"
"          if there is no value associated with the key\n"
"          \n"
"          .. note:: This makes a copy of the array.  If the overhead of this is a\n"
"             concern, use GetValue() instead.")
  )
  
  
  
    
  .
def
("putStringArray", &nt::NetworkTable::PutStringArray,
      py::arg("key"), py::arg("value"), release_gil(), py::doc(
    "Put a string array in the table\n"
"\n"
":param key:   the key to be assigned to\n"
":param value: the value that will be assigned\n"
"\n"
":returns: False if the table key already exists with a different type")
  )
  
  
  
    
  .
def
("setDefaultStringArray", &nt::NetworkTable::SetDefaultStringArray,
      py::arg("key"), py::arg("defaultValue"), release_gil(), py::doc(
    "Gets the current value in the table, setting it if it does not exist.\n"
"\n"
":param key:          the key\n"
":param defaultValue: the default value to set if key doesn't exist.\n"
"\n"
":returns: False if the table key exists with a different type")
  )
  
  
  
    
  .
def
("getStringArray", [](NetworkTable * table, std::string_view key, py::object defaultValue) -> py::object {
  nt::NetworkTableEntry entry;
  {
    py::gil_scoped_release release;
    entry = table->GetEntry(key);
  }
  return pyntcore::GetStringArrayEntry(entry, defaultValue);
}
,
      py::arg("key"), py::arg("defaultValue"), py::doc(
    "Returns the string array the key maps to. If the key does not exist or is\n"
"of different type, it will return the default value.\n"
"\n"
":param key:          the key to look up\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the value associated with the given key or the given default value\n"
"          if there is no value associated with the key\n"
"          \n"
"          .. note:: This makes a copy of the array.  If the overhead of this is a\n"
"             concern, use GetValue() instead.")
  )
  
  
  
    
  .
def
("putRaw", &nt::NetworkTable::PutRaw,
      py::arg("key"), py::arg("value"), release_gil(), py::doc(
    "Put a raw value (byte array) in the table\n"
"\n"
":param key:   the key to be assigned to\n"
":param value: the value that will be assigned\n"
"\n"
":returns: False if the table key already exists with a different type")
  )
  
  
  
    
  .
def
("setDefaultRaw", &nt::NetworkTable::SetDefaultRaw,
      py::arg("key"), py::arg("defaultValue"), release_gil(), py::doc(
    "Gets the current value in the table, setting it if it does not exist.\n"
"\n"
":param key:          the key\n"
":param defaultValue: the default value to set if key doesn't exist.\n"
"\n"
":returns: False if the table key exists with a different type")
  )
  
  
  
    
  .
def
("getRaw", [](NetworkTable * table, std::string_view key, py::object defaultValue) -> py::object {
  nt::NetworkTableEntry entry;
  {
    py::gil_scoped_release release;
    entry = table->GetEntry(key);
  }
  return pyntcore::GetRawEntry(entry, defaultValue);
}
,
      py::arg("key"), py::arg("defaultValue"), py::doc(
    "Returns the raw value (byte array) the key maps to. If the key does not\n"
"exist or is of different type, it will return the default value.\n"
"\n"
":param key:          the key to look up\n"
":param defaultValue: the value to be returned if no value is found\n"
"\n"
":returns: the value associated with the given key or the given default value\n"
"          if there is no value associated with the key\n"
"          \n"
"          .. note:: This makes a copy of the raw contents.  If the overhead of this is a\n"
"             concern, use GetValue() instead.")
  )
  
  
  
    
  .
def
("getPath", &nt::NetworkTable::GetPath, release_gil(), py::doc(
    "Gets the full path of this table.  Does not include the trailing \"/\".\n"
"\n"
":returns: The path (e.g \"\", \"/foo\").")
  )
  
  
  
    
  .
def
("addListener", static_cast<NT_Listener(nt::NetworkTable::*)(int, TableEventListener)>(
        &nt::NetworkTable::AddListener),
      py::arg("eventMask"), py::arg("listener"), release_gil(), py::doc(
    "Listen to topics only within this table.\n"
"\n"
":param eventMask: Bitmask of EventFlags values\n"
":param listener:  listener to add\n"
"\n"
":returns: Listener handle")
  )
  
  
  
    
  .
def
("addListener", static_cast<NT_Listener(nt::NetworkTable::*)(std::string_view, int, TableEventListener)>(
        &nt::NetworkTable::AddListener),
      py::arg("key"), py::arg("eventMask"), py::arg("listener"), release_gil(), py::doc(
    "Listen to a single key.\n"
"\n"
":param key:       the key name\n"
":param eventMask: Bitmask of EventFlags values\n"
":param listener:  listener to add\n"
"\n"
":returns: Listener handle")
  )
  
  
  
    
  .
def
("addSubTableListener", &nt::NetworkTable::AddSubTableListener,
      py::arg("listener"), release_gil(), py::doc(
    "Listen for sub-table creation. This calls the listener once for each newly\n"
"created sub-table. It immediately calls the listener for any existing\n"
"sub-tables.\n"
"\n"
":param listener: listener to add\n"
"\n"
":returns: Listener handle")
  )
  
  
  
    
  .
def
("removeListener", &nt::NetworkTable::RemoveListener,
      py::arg("listener"), release_gil(), py::doc(
    "Remove a listener.\n"
"\n"
":param listener: listener handle")
  )
  
  
  
    .def_readonly_static("PATH_SEPARATOR_CHAR", &nt::NetworkTable::PATH_SEPARATOR_CHAR, py::doc(
    "The path separator for sub-tables and keys"))
  ;

  


  }







  #include <src/NetworkTable.cpp.inl>


}

}; // struct rpybuild_NetworkTable_initializer

static std::unique_ptr<rpybuild_NetworkTable_initializer> cls;

void begin_init_NetworkTable(py::module &m) {
  cls = std::make_unique<rpybuild_NetworkTable_initializer>(m);
}

void finish_init_NetworkTable() {
  cls->finish();
  cls.reset();
}