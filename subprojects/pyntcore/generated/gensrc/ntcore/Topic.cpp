
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <networktables/Topic.h>


#include <wpi_json_type_caster.h>



#include <pybind11/operators.h>





#define RPYGEN_ENABLE_nt__Subscriber_PROTECTED_CONSTRUCTORS
#include <rpygen/nt__Subscriber.hpp>

#define RPYGEN_ENABLE_nt__Publisher_PROTECTED_CONSTRUCTORS
#include <rpygen/nt__Publisher.hpp>







#include <networktables/GenericEntry.h>

#include <networktables/NetworkTableInstance.h>



#include <type_traits>


  using namespace nt;



struct rpybuild_Topic_initializer {


  

  


  

  


  

  












  py::class_<typename nt::Topic> cls_Topic;

    

    
    
  
  using Subscriber_Trampoline = rpygen::PyTrampoline_nt__Subscriber<typename nt::Subscriber, typename rpygen::PyTrampolineCfg_nt__Subscriber<>>;
    static_assert(std::is_abstract<Subscriber_Trampoline>::value == false, "nt::Subscriber " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename nt::Subscriber, Subscriber_Trampoline> cls_Subscriber;

    

    
    
  
  using Publisher_Trampoline = rpygen::PyTrampoline_nt__Publisher<typename nt::Publisher, typename rpygen::PyTrampolineCfg_nt__Publisher<>>;
    static_assert(std::is_abstract<Publisher_Trampoline>::value == false, "nt::Publisher " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename nt::Publisher, Publisher_Trampoline> cls_Publisher;

    

    
    

  py::module &m;

  
  rpybuild_Topic_initializer(py::module &m) :

  

  

  

  
    cls_Topic(m, "Topic"),

  

  
  
  
    cls_Subscriber(m, "Subscriber"),

  

  
  
  
    cls_Publisher(m, "Publisher"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
    
  

    
    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_Topic.doc() =
    "NetworkTables Topic.";

  cls_Topic
  
    
  .
def
("getInstance", &nt::Topic::GetInstance, release_gil(), py::doc(
    "Gets the instance for the topic.\n"
"\n"
":returns: Instance")
  )
  
  
  
    
  .
def
("getName", &nt::Topic::GetName, release_gil(), py::doc(
    "Gets the name of the topic.\n"
"\n"
":returns: the topic's name")
  )
  
  
  
    
  .
def
("getType", &nt::Topic::GetType, release_gil(), py::doc(
    "Gets the type of the topic.\n"
"\n"
":returns: the topic's type")
  )
  
  
  
    
  .
def
("getTypeString", &nt::Topic::GetTypeString, release_gil(), py::doc(
    "Gets the type string of the topic. This may have more information\n"
"than the numeric type (especially for raw values).\n"
"\n"
":returns: the topic's type")
  )
  
  
  
    
  .
def
("setPersistent", &nt::Topic::SetPersistent,
      py::arg("persistent"), release_gil(), py::doc(
    "Make value persistent through server restarts.\n"
"\n"
":param persistent: True for persistent, false for not persistent.")
  )
  
  
  
    
  .
def
("isPersistent", &nt::Topic::IsPersistent, release_gil(), py::doc(
    "Returns whether the value is persistent through server restarts.\n"
"\n"
":returns: True if the value is persistent.")
  )
  
  
  
    
  .
def
("setRetained", &nt::Topic::SetRetained,
      py::arg("retained"), release_gil(), py::doc(
    "Make the server retain the topic even when there are no publishers.\n"
"\n"
":param retained: True for retained, false for not retained.")
  )
  
  
  
    
  .
def
("isRetained", &nt::Topic::IsRetained, release_gil(), py::doc(
    "Returns whether the topic is retained by server when there are no\n"
"publishers.\n"
"\n"
":returns: True if the topic is retained.")
  )
  
  
  
    
  .
def
("setCached", &nt::Topic::SetCached,
      py::arg("cached"), release_gil(), py::doc(
    "Allow storage of the topic's last value, allowing the value to be read (and\n"
"not just accessed through event queues and listeners).\n"
"\n"
":param cached: True for cached, false for not cached.")
  )
  
  
  
    
  .
def
("isCached", &nt::Topic::IsCached, release_gil(), py::doc(
    "Returns whether the topic's last value is stored.\n"
"\n"
":returns: True if the topic is cached.")
  )
  
  
  
    
  .
def
("exists", &nt::Topic::Exists, release_gil(), py::doc(
    "Determines if the topic is currently being published.\n"
"\n"
":returns: True if the topic exists, false otherwise.")
  )
  
  
  
    
  .
def
("getProperty", &nt::Topic::GetProperty,
      py::arg("name"), release_gil(), py::doc(
    "Gets the current value of a property (as a JSON object).\n"
"\n"
":param name: property name\n"
"\n"
":returns: JSON object; null object if the property does not exist.")
  )
  
  
  
    
  .
def
("setProperty", &nt::Topic::SetProperty,
      py::arg("name"), py::arg("value"), release_gil(), py::doc(
    "Sets a property value.\n"
"\n"
":param name:  property name\n"
":param value: property value")
  )
  
  
  
    
  .
def
("deleteProperty", &nt::Topic::DeleteProperty,
      py::arg("name"), release_gil(), py::doc(
    "Deletes a property.  Has no effect if the property does not exist.\n"
"\n"
":param name: property name")
  )
  
  
  
    
  .
def
("getProperties", &nt::Topic::GetProperties, release_gil(), py::doc(
    "Gets all topic properties as a JSON object.  Each key in the object\n"
"is the property name, and the corresponding value is the property value.\n"
"\n"
":returns: JSON object")
  )
  
  
  
    
  .
def
("setProperties", &nt::Topic::SetProperties,
      py::arg("properties"), release_gil(), py::doc(
    "Updates multiple topic properties.  Each key in the passed-in object is\n"
"the name of the property to add/update, and the corresponding value is the\n"
"property value to set for that property.  Null values result in deletion\n"
"of the corresponding property.\n"
"\n"
":param properties: JSON object with keys to add/update/delete\n"
"\n"
":returns: False if properties is not an object")
  )
  
  
  
    
  .
def
("getInfo", &nt::Topic::GetInfo, release_gil(), py::doc(
    "Gets combined information about the topic.\n"
"\n"
":returns: Topic information")
  )
  
  
  
    
  .
def
("genericSubscribe", static_cast<GenericSubscriber(nt::Topic::*)(const PubSubOptions&)>(
        &nt::Topic::GenericSubscribe),
      py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
    "Create a new subscriber to the topic.\n"
"\n"
"The subscriber is only active as long as the returned object\n"
"is not destroyed.\n"
"\n"
":param options: subscribe options\n"
"\n"
":returns: subscriber")
  )
  
  
  
    
  .
def
("genericSubscribe", static_cast<GenericSubscriber(nt::Topic::*)(std::string_view, const PubSubOptions&)>(
        &nt::Topic::GenericSubscribe),
      py::arg("typeString"), py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
    "Create a new subscriber to the topic.\n"
"\n"
"The subscriber is only active as long as the returned object\n"
"is not destroyed.\n"
"\n"
".. note:: Subscribers that do not match the published data type do not return\n"
"   any values. To determine if the data type matches, use the appropriate\n"
"   Topic functions.\n"
"\n"
":param typeString: type string\n"
":param options:    subscribe options\n"
"\n"
":returns: subscriber")
  )
  
  
  
    
  .
def
("genericPublish", &nt::Topic::GenericPublish,
      py::arg("typeString"), py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
    "Create a new publisher to the topic.\n"
"\n"
"The publisher is only active as long as the returned object\n"
"is not destroyed.\n"
"\n"
".. note:: It is not possible to publish two different data types to the same\n"
"   topic. Conflicts between publishers are typically resolved by the\n"
"   server on a first-come, first-served basis. Any published values that\n"
"   do not match the topic's data type are dropped (ignored). To determine\n"
"   if the data type matches, use the appropriate Topic functions.\n"
"\n"
":param typeString: type string\n"
":param options:    publish options\n"
"\n"
":returns: publisher")
  )
  
  
  
    
  .
def
("genericPublishEx", &nt::Topic::GenericPublishEx,
      py::arg("typeString"), py::arg("properties"), py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
    "Create a new publisher to the topic, with type string and initial\n"
"properties.\n"
"\n"
"The publisher is only active as long as the returned object\n"
"is not destroyed.\n"
"\n"
".. note:: It is not possible to publish two different data types to the same\n"
"   topic. Conflicts between publishers are typically resolved by the\n"
"   server on a first-come, first-served basis. Any published values that\n"
"   do not match the topic's data type are dropped (ignored). To determine\n"
"   if the data type matches, use the appropriate Topic functions.\n"
"\n"
":param typeString: type string\n"
":param properties: JSON properties\n"
":param options:    publish options\n"
"\n"
":returns: publisher")
  )
  
  
  
    
  .
def
("getGenericEntry", static_cast<GenericEntry(nt::Topic::*)(const PubSubOptions&)>(
        &nt::Topic::GetGenericEntry),
      py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
    "Create a new generic entry for the topic.\n"
"\n"
"Entries act as a combination of a subscriber and a weak publisher. The\n"
"subscriber is active as long as the entry is not destroyed. The publisher\n"
"is created when the entry is first written to, and remains active until\n"
"either Unpublish() is called or the entry is destroyed.\n"
"\n"
".. note:: It is not possible to use two different data types with the same\n"
"   topic. Conflicts between publishers are typically resolved by the\n"
"   server on a first-come, first-served basis. Any published values that\n"
"   do not match the topic's data type are dropped (ignored), and the entry\n"
"   will show no new values if the data type does not match. To determine\n"
"   if the data type matches, use the appropriate Topic functions.\n"
"\n"
":param options: publish and/or subscribe options\n"
"\n"
":returns: entry")
  )
  
  
  
    
  .
def
("getGenericEntry", static_cast<GenericEntry(nt::Topic::*)(std::string_view, const PubSubOptions&)>(
        &nt::Topic::GetGenericEntry),
      py::arg("typeString"), py::arg("options") = kDefaultPubSubOptions, release_gil(), py::doc(
    "Create a new generic entry for the topic.\n"
"\n"
"Entries act as a combination of a subscriber and a weak publisher. The\n"
"subscriber is active as long as the entry is not destroyed. The publisher\n"
"is created when the entry is first written to, and remains active until\n"
"either Unpublish() is called or the entry is destroyed.\n"
"\n"
".. note:: It is not possible to use two different data types with the same\n"
"   topic. Conflicts between publishers are typically resolved by the\n"
"   server on a first-come, first-served basis. Any published values that\n"
"   do not match the topic's data type are dropped (ignored), and the entry\n"
"   will show no new values if the data type does not match. To determine\n"
"   if the data type matches, use the appropriate Topic functions.\n"
"\n"
":param typeString: type string\n"
":param options:    publish and/or subscribe options\n"
"\n"
":returns: entry")
  )
  
  
  
    
  .def(py::self == py::self, py::doc(
    "Equality operator.  Returns true if both instances refer to the same\n"
"native handle.")
  )
  
  
  ;

  


  }

  {
  
  
  


  

  cls_Subscriber.doc() =
    "NetworkTables subscriber.";

  cls_Subscriber
  
    
  .
def
("exists", &nt::Subscriber::Exists, release_gil(), py::doc(
    "Determines if the topic is currently being published.\n"
"\n"
":returns: True if the topic exists, false otherwise.")
  )
  
  
  
    
  .
def
("getLastChange", &nt::Subscriber::GetLastChange, release_gil(), py::doc(
    "Gets the last time the value was changed.\n"
"Note: this is not atomic with Get(); use GetAtomic() to get\n"
"both the value and last change as an atomic operation.\n"
"\n"
":returns: Topic last change time")
  )
  
  
  
    
  .
def
("getTopic", &nt::Subscriber::GetTopic, release_gil(), py::doc(
    "Gets the subscribed-to topic.\n"
"\n"
":returns: Topic")
  )
  
  
  
    .def_readonly("_m_subHandle", &rpygen::PyTrampoline_nt__Subscriber<typename nt::Subscriber, typename rpygen::PyTrampolineCfg_nt__Subscriber<>>::m_subHandle);

  


  }

  {
  
  
  


  

  cls_Publisher.doc() =
    "NetworkTables publisher.";

  cls_Publisher
  
    
  .
def
("getTopic", &nt::Publisher::GetTopic, release_gil(), py::doc(
    "Gets the published-to topic.\n"
"\n"
":returns: Topic")
  )
  
  
  
    .def_readonly("_m_pubHandle", &rpygen::PyTrampoline_nt__Publisher<typename nt::Publisher, typename rpygen::PyTrampolineCfg_nt__Publisher<>>::m_pubHandle, py::doc(
    "NetworkTables handle."));

  


  }






}

}; // struct rpybuild_Topic_initializer

static std::unique_ptr<rpybuild_Topic_initializer> cls;

void begin_init_Topic(py::module &m) {
  cls = std::make_unique<rpybuild_Topic_initializer>(m);
}

void finish_init_Topic() {
  cls->finish();
  cls.reset();
}