
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <wpi/DataLog.h>


#include <pybind11/stl.h>

#include <wpi_span_type_caster.h>

#include <wpystruct.h>







#define RPYGEN_ENABLE_wpi__log__DataLog_PROTECTED_CONSTRUCTORS
#include <rpygen/wpi__log__DataLog.hpp>





#include "DataLog_tmpl.hpp"





#include <type_traits>


  using namespace wpi;

  using namespace wpi::log;

  using namespace wpi::log::impl;



struct rpybuild_DataLog_initializer {


  

  


  

  


  

  


  

  


  

  


  

  


  

  


  

  


  

  


  

  


  

  


  

  


  

  




  py::module pkg_log;




  
  py::enum_<wpi::log::impl::ControlRecordType> enum1;






  
  using DataLog_Trampoline = rpygen::PyTrampoline_wpi__log__DataLog<typename wpi::log::DataLog, typename rpygen::PyTrampolineCfg_wpi__log__DataLog<>>;
    static_assert(std::is_abstract<DataLog_Trampoline>::value == false, "wpi::log::DataLog " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename wpi::log::DataLog, DataLog_Trampoline> cls_DataLog;

    

    
    
  py::class_<typename wpi::log::DataLogEntry> cls_DataLogEntry;

    

    
    
  
      rpygen::bind_wpi__log__DataLogValueEntryImpl_2 tmplCls2;
    
      rpygen::bind_wpi__log__DataLogValueEntryImpl_3 tmplCls3;
    
      rpygen::bind_wpi__log__DataLogValueEntryImpl_4 tmplCls4;
    
      rpygen::bind_wpi__log__DataLogValueEntryImpl_5 tmplCls5;
    
      rpygen::bind_wpi__log__DataLogValueEntryImpl_6 tmplCls6;
    
      rpygen::bind_wpi__log__DataLogValueEntryImpl_7 tmplCls7;
    
      rpygen::bind_wpi__log__DataLogValueEntryImpl_8 tmplCls8;
    
      rpygen::bind_wpi__log__DataLogValueEntryImpl_9 tmplCls9;
    
      rpygen::bind_wpi__log__DataLogValueEntryImpl_10 tmplCls10;
    
      rpygen::bind_wpi__log__DataLogValueEntryImpl_11 tmplCls11;
    
      rpygen::bind_wpi__log__DataLogValueEntryImpl_12 tmplCls12;
    
  py::class_<typename wpi::log::RawLogEntry, wpi::log::DataLogValueEntryImpl<std::vector<uint8_t>>> cls_RawLogEntry;

    

    
    
  py::class_<typename wpi::log::BooleanLogEntry, wpi::log::DataLogValueEntryImpl<bool>> cls_BooleanLogEntry;

    

    
    
  py::class_<typename wpi::log::IntegerLogEntry, wpi::log::DataLogValueEntryImpl<int64_t>> cls_IntegerLogEntry;

    

    
    
  py::class_<typename wpi::log::FloatLogEntry, wpi::log::DataLogValueEntryImpl<float>> cls_FloatLogEntry;

    

    
    
  py::class_<typename wpi::log::DoubleLogEntry, wpi::log::DataLogValueEntryImpl<double>> cls_DoubleLogEntry;

    

    
    
  py::class_<typename wpi::log::StringLogEntry, wpi::log::DataLogValueEntryImpl<std::string>> cls_StringLogEntry;

    

    
    
  py::class_<typename wpi::log::BooleanArrayLogEntry, wpi::log::DataLogValueEntryImpl<std::vector<int>>> cls_BooleanArrayLogEntry;

    

    
    
  py::class_<typename wpi::log::IntegerArrayLogEntry, wpi::log::DataLogValueEntryImpl<std::vector<int64_t>>> cls_IntegerArrayLogEntry;

    

    
    
  py::class_<typename wpi::log::FloatArrayLogEntry, wpi::log::DataLogValueEntryImpl<std::vector<float>>> cls_FloatArrayLogEntry;

    

    
    
  py::class_<typename wpi::log::DoubleArrayLogEntry, wpi::log::DataLogValueEntryImpl<std::vector<double>>> cls_DoubleArrayLogEntry;

    

    
    
  py::class_<typename wpi::log::StringArrayLogEntry, wpi::log::DataLogValueEntryImpl<std::vector<std::string>>> cls_StringArrayLogEntry;

    

    
    
  
      rpygen::bind_wpi__log__StructLogEntry_0 tmplCls0;
    
  
      rpygen::bind_wpi__log__StructArrayLogEntry_1 tmplCls1;
    

  py::module &m;

  
  rpybuild_DataLog_initializer(py::module &m) :

  
    pkg_log(m.def_submodule("log")),
  

  
    enum1
  (m, "ControlRecordType"
  ),
  

  

  
    cls_DataLog(pkg_log, "DataLog"),

  

  
  
  
    cls_DataLogEntry(pkg_log, "DataLogEntry"),

  

  
  
  
    
        tmplCls2(pkg_log, "_RawLogEntryImpl"),
      
        tmplCls3(pkg_log, "_BooleanLogEntryImpl"),
      
        tmplCls4(pkg_log, "_IntegerLogEntryImpl"),
      
        tmplCls5(pkg_log, "_FloatLogEntryImpl"),
      
        tmplCls6(pkg_log, "_DoubleLogEntryImpl"),
      
        tmplCls7(pkg_log, "_StringLogEntryImpl"),
      
        tmplCls8(pkg_log, "_BooleanArrayLogEntryImpl"),
      
        tmplCls9(pkg_log, "_IntegerArrayLogEntryImpl"),
      
        tmplCls10(pkg_log, "_FloatArrayLogEntryImpl"),
      
        tmplCls11(pkg_log, "_DoubleArrayLogEntryImpl"),
      
        tmplCls12(pkg_log, "_StringArrayLogEntryImpl"),
      
  
    cls_RawLogEntry(pkg_log, "RawLogEntry"),

  

  
  
  
    cls_BooleanLogEntry(pkg_log, "BooleanLogEntry"),

  

  
  
  
    cls_IntegerLogEntry(pkg_log, "IntegerLogEntry"),

  

  
  
  
    cls_FloatLogEntry(pkg_log, "FloatLogEntry"),

  

  
  
  
    cls_DoubleLogEntry(pkg_log, "DoubleLogEntry"),

  

  
  
  
    cls_StringLogEntry(pkg_log, "StringLogEntry"),

  

  
  
  
    cls_BooleanArrayLogEntry(pkg_log, "BooleanArrayLogEntry"),

  

  
  
  
    cls_IntegerArrayLogEntry(pkg_log, "IntegerArrayLogEntry"),

  

  
  
  
    cls_FloatArrayLogEntry(pkg_log, "FloatArrayLogEntry"),

  

  
  
  
    cls_DoubleArrayLogEntry(pkg_log, "DoubleArrayLogEntry"),

  

  
  
  
    cls_StringArrayLogEntry(pkg_log, "StringArrayLogEntry"),

  

  
  
  
    
        tmplCls0(pkg_log, "StructLogEntry"),
      
  
    
        tmplCls1(pkg_log, "StructArrayLogEntry"),
      
  

    m(m)
  {
    
    
      enum1
  
    .value("kControlStart", wpi::log::impl::ControlRecordType::kControlStart)
  
    .value("kControlFinish", wpi::log::impl::ControlRecordType::kControlFinish)
  
    .value("kControlSetMetadata", wpi::log::impl::ControlRecordType::kControlSetMetadata)
  ;

    

    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
  }

void finish() {



  tmplCls0.finish(
    NULL,
    NULL
  );

  tmplCls1.finish(
    NULL,
    NULL
  );

  tmplCls2.finish(
    NULL,
    NULL
  );

  tmplCls3.finish(
    NULL,
    NULL
  );

  tmplCls4.finish(
    NULL,
    NULL
  );

  tmplCls5.finish(
    NULL,
    NULL
  );

  tmplCls6.finish(
    NULL,
    NULL
  );

  tmplCls7.finish(
    NULL,
    NULL
  );

  tmplCls8.finish(
    NULL,
    NULL
  );

  tmplCls9.finish(
    NULL,
    NULL
  );

  tmplCls10.finish(
    NULL,
    NULL
  );

  tmplCls11.finish(
    NULL,
    NULL
  );

  tmplCls12.finish(
    NULL,
    NULL
  );



  {
  
  
  


  

  cls_DataLog.doc() =
    "A data log for high-speed writing of data values.\n"
"\n"
"The lifetime of the data log object must be longer than any data log entry\n"
"objects that refer to it.\n"
"\n"
"Finish() is needed only to indicate in the log that a particular entry is\n"
"no longer being used (it releases the name to ID mapping).  Finish() is not\n"
"required to be called for data to be flushed to disk; entries in the log\n"
"are written as Append() calls are being made.  In fact, Finish() does not\n"
"need to be called at all; this is helpful to avoid shutdown races where the\n"
"DataLog object might be destroyed before other objects.  It's often not a\n"
"good idea to call Finish() from destructors for this reason.\n"
"\n"
"DataLog calls are thread safe.  DataLog uses a typical multiple-supplier,\n"
"single-consumer setup.  Writes to the log are atomic, but there is no\n"
"guaranteed order in the log when multiple threads are writing to it;\n"
"whichever thread grabs the write mutex first will get written first.\n"
"For this reason (as well as the fact that timestamps can be set to\n"
"arbitrary values), records in the log are not guaranteed to be sorted by\n"
"timestamp.";

  cls_DataLog
  
    
  .
def
("flush", &wpi::log::DataLog::Flush, release_gil(), py::doc(
    "Explicitly flushes the log data to disk.")
  )
  
  
  
    
  .
def
("pause", &wpi::log::DataLog::Pause, release_gil(), py::doc(
    "Pauses appending of data records to the log.  While paused, no data records\n"
"are saved (e.g. AppendX is a no-op).  Has no effect on entry starts /\n"
"finishes / metadata changes.")
  )
  
  
  
    
  .
def
("resume", &wpi::log::DataLog::Resume, release_gil(), py::doc(
    "Resumes appending of data records to the log.")
  )
  
  
  
    
  .
def
("stop", &wpi::log::DataLog::Stop, release_gil(), py::doc(
    "Stops appending start/metadata/schema records to the log.")
  )
  
  
  
    
  .
def
("hasSchema", &wpi::log::DataLog::HasSchema,
      py::arg("name"), release_gil(), py::doc(
    "Returns whether there is a data schema already registered with the given\n"
"name.\n"
"\n"
":param name: Name (the string passed as the data type for records using this\n"
"             schema)\n"
"\n"
":returns: True if schema already registered")
  )
  
  
  
    
  .
def
("addSchema", static_cast<void(wpi::log::DataLog::*)(std::string_view, std::string_view, std::span<const uint8_t>, int64_t)>(
        &wpi::log::DataLog::AddSchema),
      py::arg("name"), py::arg("type"), py::arg("schema"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Registers a data schema.  Data schemas provide information for how a\n"
"certain data type string can be decoded.  The type string of a data schema\n"
"indicates the type of the schema itself (e.g. \"protobuf\" for protobuf\n"
"schemas, \"struct\" for struct schemas, etc). In the data log, schemas are\n"
"saved just like normal records, with the name being generated from the\n"
"provided name: \"/.schema/<name>\".  Duplicate calls to this function with\n"
"the same name are silently ignored.\n"
"\n"
":param name:      Name (the string passed as the data type for records using this\n"
"                  schema)\n"
":param type:      Type of schema (e.g. \"protobuf\", \"struct\", etc)\n"
":param schema:    Schema data\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("addSchema", static_cast<void(wpi::log::DataLog::*)(std::string_view, std::string_view, std::string_view, int64_t)>(
        &wpi::log::DataLog::AddSchema),
      py::arg("name"), py::arg("type"), py::arg("schema"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Registers a data schema.  Data schemas provide information for how a\n"
"certain data type string can be decoded.  The type string of a data schema\n"
"indicates the type of the schema itself (e.g. \"protobuf\" for protobuf\n"
"schemas, \"struct\" for struct schemas, etc). In the data log, schemas are\n"
"saved just like normal records, with the name being generated from the\n"
"provided name: \"/.schema/<name>\".  Duplicate calls to this function with\n"
"the same name are silently ignored.\n"
"\n"
":param name:      Name (the string passed as the data type for records using this\n"
"                  schema)\n"
":param type:      Type of schema (e.g. \"protobuf\", \"struct\", etc)\n"
":param schema:    Schema data\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("addStructSchema", [](DataLog &self, const py::type &t, int64_t timestamp) {
  WPyStructInfo info(t);
  return self.AddStructSchema<WPyStruct, WPyStructInfo>(info, timestamp);
}
,
      py::arg("type"), py::arg("timestamp") = 0, py::doc(
    "Registers a struct schema. Duplicate calls to this function with the same\n"
"name are silently ignored.\n"
"\n"
"@tparam T struct serializable type\n"
"\n"
":param type:      optional struct type info\n"
":param timestamp: Time stamp (0 to indicate now)")
  )
  
  
  
    
  .
def
("start", &wpi::log::DataLog::Start,
      py::arg("name"), py::arg("type"), py::arg("metadata") = std::string_view{}, py::arg("timestamp") = 0, release_gil(), py::doc(
    "Start an entry.  Duplicate names are allowed (with the same type), and\n"
"result in the same index being returned (Start/Finish are reference\n"
"counted).  A duplicate name with a different type will result in an error\n"
"message being printed to the console and 0 being returned (which will be\n"
"ignored by the Append functions).\n"
"\n"
":param name:      Name\n"
":param type:      Data type\n"
":param metadata:  Initial metadata (e.g. data properties)\n"
":param timestamp: Time stamp (may be 0 to indicate now)\n"
"\n"
":returns: Entry index")
  )
  
  
  
    
  .
def
("finish", &wpi::log::DataLog::Finish,
      py::arg("entry"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Finish an entry.\n"
"\n"
":param entry:     Entry index\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("setMetadata", &wpi::log::DataLog::SetMetadata,
      py::arg("entry"), py::arg("metadata"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Updates the metadata for an entry.\n"
"\n"
":param entry:     Entry index\n"
":param metadata:  New metadata for the entry\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("appendRaw", &wpi::log::DataLog::AppendRaw,
      py::arg("entry"), py::arg("data"), py::arg("timestamp"), release_gil(), py::doc(
    "Appends a raw record to the log.\n"
"\n"
":param entry:     Entry index, as returned by Start()\n"
":param data:      Byte array to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("appendRaw2", &wpi::log::DataLog::AppendRaw2,
      py::arg("entry"), py::arg("data"), py::arg("timestamp"), release_gil(), py::doc(
    "Appends a raw record to the log.\n"
"\n"
":param entry:     Entry index, as returned by Start()\n"
":param data:      Byte array to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("appendBoolean", &wpi::log::DataLog::AppendBoolean,
      py::arg("entry"), py::arg("value"), py::arg("timestamp"), release_gil(), py::doc(
    "Appends a boolean record to the log.\n"
"\n"
":param entry:     Entry index, as returned by Start()\n"
":param value:     Boolean value to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("appendInteger", &wpi::log::DataLog::AppendInteger,
      py::arg("entry"), py::arg("value"), py::arg("timestamp"), release_gil(), py::doc(
    "Appends an integer record to the log.\n"
"\n"
":param entry:     Entry index, as returned by Start()\n"
":param value:     Integer value to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("appendFloat", &wpi::log::DataLog::AppendFloat,
      py::arg("entry"), py::arg("value"), py::arg("timestamp"), release_gil(), py::doc(
    "Appends a float record to the log.\n"
"\n"
":param entry:     Entry index, as returned by Start()\n"
":param value:     Float value to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("appendDouble", &wpi::log::DataLog::AppendDouble,
      py::arg("entry"), py::arg("value"), py::arg("timestamp"), release_gil(), py::doc(
    "Appends a double record to the log.\n"
"\n"
":param entry:     Entry index, as returned by Start()\n"
":param value:     Double value to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("appendString", &wpi::log::DataLog::AppendString,
      py::arg("entry"), py::arg("value"), py::arg("timestamp"), release_gil(), py::doc(
    "Appends a string record to the log.\n"
"\n"
":param entry:     Entry index, as returned by Start()\n"
":param value:     String value to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("appendBooleanArray", static_cast<void(wpi::log::DataLog::*)(int, std::span<const bool>, int64_t)>(
        &wpi::log::DataLog::AppendBooleanArray),
      py::arg("entry"), py::arg("arr"), py::arg("timestamp"), release_gil(), py::doc(
    "Appends a boolean array record to the log.\n"
"\n"
":param entry:     Entry index, as returned by Start()\n"
":param arr:       Boolean array to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("appendIntegerArray", &wpi::log::DataLog::AppendIntegerArray,
      py::arg("entry"), py::arg("arr"), py::arg("timestamp"), release_gil(), py::doc(
    "Appends an integer array record to the log.\n"
"\n"
":param entry:     Entry index, as returned by Start()\n"
":param arr:       Integer array to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("appendFloatArray", &wpi::log::DataLog::AppendFloatArray,
      py::arg("entry"), py::arg("arr"), py::arg("timestamp"), release_gil(), py::doc(
    "Appends a float array record to the log.\n"
"\n"
":param entry:     Entry index, as returned by Start()\n"
":param arr:       Float array to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("appendDoubleArray", &wpi::log::DataLog::AppendDoubleArray,
      py::arg("entry"), py::arg("arr"), py::arg("timestamp"), release_gil(), py::doc(
    "Appends a double array record to the log.\n"
"\n"
":param entry:     Entry index, as returned by Start()\n"
":param arr:       Double array to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("appendStringArray", static_cast<void(wpi::log::DataLog::*)(int, std::span<const std::string_view>, int64_t)>(
        &wpi::log::DataLog::AppendStringArray),
      py::arg("entry"), py::arg("arr"), py::arg("timestamp"), release_gil(), py::doc(
    "Appends a string array record to the log.\n"
"\n"
":param entry:     Entry index, as returned by Start()\n"
":param arr:       String array to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("_startFile", static_cast<void(wpi::log::DataLog::*)()>(&DataLog_Trampoline::StartFile), release_gil(), py::doc(
    "Starts the log.  Appends file header and Start records and schema data\n"
"values for all previously started entries and schemas.  No effect unless\n"
"the data log is currently stopped.")
  )
  
  
  
    
  .
def
("_bufferHalfFull", static_cast<void(wpi::log::DataLog::*)()>(&DataLog_Trampoline::BufferHalfFull), release_gil(), py::doc(
    "Called when internal buffers are half the maximum count.  Called with\n"
"internal mutex held; do not call any other DataLog functions from this\n"
"function.")
  )
  
  
  
    
  .
def
("_bufferFull", static_cast<bool(wpi::log::DataLog::*)()>(&DataLog_Trampoline::BufferFull), release_gil(), py::doc(
    "Called when internal buffers reach the maximum count.  Called with internal\n"
"mutex held; do not call any other DataLog functions from this function.\n"
"\n"
":returns: true if log should be paused (don't call PauseLog)")
  )
  
  
  
    .def_readonly_static("_kBlockSize", &rpygen::PyTrampoline_wpi__log__DataLog<typename wpi::log::DataLog, typename rpygen::PyTrampolineCfg_wpi__log__DataLog<>>::kBlockSize);

  


  }

  {
  
  
  


  

  cls_DataLogEntry.doc() =
    "Log entry base class.";

  cls_DataLogEntry
  
    
  .
def
("setMetadata", &wpi::log::DataLogEntry::SetMetadata,
      py::arg("metadata"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Updates the metadata for the entry.\n"
"\n"
":param metadata:  New metadata for the entry\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("finish", &wpi::log::DataLogEntry::Finish,
      py::arg("timestamp") = 0, release_gil(), py::doc(
    "Finishes the entry.\n"
"\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  ;

  


  }

  {
  
  
  
    static constexpr auto kDataType [[maybe_unused]] = wpi::log::RawLogEntry::kDataType;
  


  

  cls_RawLogEntry.doc() =
    "Log arbitrary byte data.";

  cls_RawLogEntry
  
    
  .def(py::init<DataLog&, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .def(py::init<DataLog&, std::string_view, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("metadata"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .def(py::init<DataLog&, std::string_view, std::string_view, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("metadata"), py::arg("type"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .
def
("append", &wpi::log::RawLogEntry::Append,
      py::arg("data"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Appends a record to the log.\n"
"\n"
":param data:      Data to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("update", &wpi::log::RawLogEntry::Update,
      py::arg("data"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Updates the last value and appends a record to the log if it has changed.\n"
"\n"
".. note:: The last value is local to this class instance; using Update() with\n"
"   two instances pointing to the same underlying log entry name will likely\n"
"   result in unexpected results.\n"
"\n"
":param data:      Data to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    .def_readonly_static("kDataType", &wpi::log::RawLogEntry::kDataType)
  ;

  


  }

  {
  
  
  
    static constexpr auto kDataType [[maybe_unused]] = wpi::log::BooleanLogEntry::kDataType;
  


  

  cls_BooleanLogEntry.doc() =
    "Log boolean values.";

  cls_BooleanLogEntry
  
    
  .def(py::init<DataLog&, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .def(py::init<DataLog&, std::string_view, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("metadata"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .
def
("append", &wpi::log::BooleanLogEntry::Append,
      py::arg("value"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Appends a record to the log.\n"
"\n"
":param value:     Value to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("update", &wpi::log::BooleanLogEntry::Update,
      py::arg("value"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Updates the last value and appends a record to the log if it has changed.\n"
"\n"
".. note:: The last value is local to this class instance; using Update() with\n"
"   two instances pointing to the same underlying log entry name will likely\n"
"   result in unexpected results.\n"
"\n"
":param value:     Value to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    .def_readonly_static("kDataType", &wpi::log::BooleanLogEntry::kDataType)
  ;

  


  }

  {
  
  
  
    static constexpr auto kDataType [[maybe_unused]] = wpi::log::IntegerLogEntry::kDataType;
  


  

  cls_IntegerLogEntry.doc() =
    "Log integer values.";

  cls_IntegerLogEntry
  
    
  .def(py::init<DataLog&, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .def(py::init<DataLog&, std::string_view, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("metadata"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .
def
("append", &wpi::log::IntegerLogEntry::Append,
      py::arg("value"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Appends a record to the log.\n"
"\n"
":param value:     Value to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("update", &wpi::log::IntegerLogEntry::Update,
      py::arg("value"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Updates the last value and appends a record to the log if it has changed.\n"
"\n"
".. note:: The last value is local to this class instance; using Update() with\n"
"   two instances pointing to the same underlying log entry name will likely\n"
"   result in unexpected results.\n"
"\n"
":param value:     Value to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    .def_readonly_static("kDataType", &wpi::log::IntegerLogEntry::kDataType)
  ;

  


  }

  {
  
  
  
    static constexpr auto kDataType [[maybe_unused]] = wpi::log::FloatLogEntry::kDataType;
  


  

  cls_FloatLogEntry.doc() =
    "Log float values.";

  cls_FloatLogEntry
  
    
  .def(py::init<DataLog&, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .def(py::init<DataLog&, std::string_view, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("metadata"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .
def
("append", &wpi::log::FloatLogEntry::Append,
      py::arg("value"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Appends a record to the log.\n"
"\n"
":param value:     Value to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("update", &wpi::log::FloatLogEntry::Update,
      py::arg("value"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Updates the last value and appends a record to the log if it has changed.\n"
"\n"
".. note:: The last value is local to this class instance; using Update() with\n"
"   two instances pointing to the same underlying log entry name will likely\n"
"   result in unexpected results.\n"
"\n"
":param value:     Value to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    .def_readonly_static("kDataType", &wpi::log::FloatLogEntry::kDataType)
  ;

  


  }

  {
  
  
  
    static constexpr auto kDataType [[maybe_unused]] = wpi::log::DoubleLogEntry::kDataType;
  


  

  cls_DoubleLogEntry.doc() =
    "Log double values.";

  cls_DoubleLogEntry
  
    
  .def(py::init<DataLog&, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .def(py::init<DataLog&, std::string_view, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("metadata"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .
def
("append", &wpi::log::DoubleLogEntry::Append,
      py::arg("value"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Appends a record to the log.\n"
"\n"
":param value:     Value to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("update", &wpi::log::DoubleLogEntry::Update,
      py::arg("value"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Updates the last value and appends a record to the log if it has changed.\n"
"\n"
".. note:: The last value is local to this class instance; using Update() with\n"
"   two instances pointing to the same underlying log entry name will likely\n"
"   result in unexpected results.\n"
"\n"
":param value:     Value to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    .def_readonly_static("kDataType", &wpi::log::DoubleLogEntry::kDataType)
  ;

  


  }

  {
  
  
  
    static constexpr auto kDataType [[maybe_unused]] = wpi::log::StringLogEntry::kDataType;
  


  

  cls_StringLogEntry.doc() =
    "Log string values.";

  cls_StringLogEntry
  
    
  .def(py::init<DataLog&, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .def(py::init<DataLog&, std::string_view, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("metadata"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .def(py::init<DataLog&, std::string_view, std::string_view, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("metadata"), py::arg("type"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .
def
("append", &wpi::log::StringLogEntry::Append,
      py::arg("value"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Appends a record to the log.\n"
"\n"
":param value:     Value to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("update", &wpi::log::StringLogEntry::Update,
      py::arg("value"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Updates the last value and appends a record to the log if it has changed.\n"
"\n"
".. note:: The last value is local to this class instance; using Update() with\n"
"   two instances pointing to the same underlying log entry name will likely\n"
"   result in unexpected results.\n"
"\n"
":param value:     Value to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    .def_readonly_static("kDataType", &wpi::log::StringLogEntry::kDataType)
  ;

  


  }

  {
  
  
  
    static constexpr auto kDataType [[maybe_unused]] = wpi::log::BooleanArrayLogEntry::kDataType;
  


  

  cls_BooleanArrayLogEntry.doc() =
    "Log array of boolean values.";

  cls_BooleanArrayLogEntry
  
    
  .def(py::init<DataLog&, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .def(py::init<DataLog&, std::string_view, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("metadata"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .
def
("append", static_cast<void(wpi::log::BooleanArrayLogEntry::*)(std::span<const bool>, int64_t)>(
        &wpi::log::BooleanArrayLogEntry::Append),
      py::arg("arr"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Appends a record to the log.  For find functions to work, timestamp\n"
"must be monotonically increasing.\n"
"\n"
":param arr:       Values to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("update", static_cast<void(wpi::log::BooleanArrayLogEntry::*)(std::span<const bool>, int64_t)>(
        &wpi::log::BooleanArrayLogEntry::Update),
      py::arg("arr"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Updates the last value and appends a record to the log if it has changed.\n"
"\n"
".. note:: The last value is local to this class instance; using Update() with\n"
"   two instances pointing to the same underlying log entry name will likely\n"
"   result in unexpected results.\n"
"\n"
":param arr:       Values to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("update", static_cast<void(wpi::log::BooleanArrayLogEntry::*)(std::span<const int>, int64_t)>(
        &wpi::log::BooleanArrayLogEntry::Update),
      py::arg("arr"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Updates the last value and appends a record to the log if it has changed.\n"
"\n"
".. note:: The last value is local to this class instance; using Update() with\n"
"   two instances pointing to the same underlying log entry name will likely\n"
"   result in unexpected results.\n"
"\n"
":param arr:       Values to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    .def_readonly_static("kDataType", &wpi::log::BooleanArrayLogEntry::kDataType)
  ;

  


  }

  {
  
  
  
    static constexpr auto kDataType [[maybe_unused]] = wpi::log::IntegerArrayLogEntry::kDataType;
  


  

  cls_IntegerArrayLogEntry.doc() =
    "Log array of integer values.";

  cls_IntegerArrayLogEntry
  
    
  .def(py::init<DataLog&, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .def(py::init<DataLog&, std::string_view, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("metadata"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .
def
("append", static_cast<void(wpi::log::IntegerArrayLogEntry::*)(std::span<const int64_t>, int64_t)>(
        &wpi::log::IntegerArrayLogEntry::Append),
      py::arg("arr"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Appends a record to the log.\n"
"\n"
":param arr:       Values to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("update", static_cast<void(wpi::log::IntegerArrayLogEntry::*)(std::span<const int64_t>, int64_t)>(
        &wpi::log::IntegerArrayLogEntry::Update),
      py::arg("arr"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Updates the last value and appends a record to the log if it has changed.\n"
"\n"
".. note:: The last value is local to this class instance; using Update() with\n"
"   two instances pointing to the same underlying log entry name will likely\n"
"   result in unexpected results.\n"
"\n"
":param arr:       Values to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    .def_readonly_static("kDataType", &wpi::log::IntegerArrayLogEntry::kDataType)
  ;

  


  }

  {
  
  
  
    static constexpr auto kDataType [[maybe_unused]] = wpi::log::FloatArrayLogEntry::kDataType;
  


  

  cls_FloatArrayLogEntry.doc() =
    "Log array of float values.";

  cls_FloatArrayLogEntry
  
    
  .def(py::init<DataLog&, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .def(py::init<DataLog&, std::string_view, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("metadata"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .
def
("append", static_cast<void(wpi::log::FloatArrayLogEntry::*)(std::span<const float>, int64_t)>(
        &wpi::log::FloatArrayLogEntry::Append),
      py::arg("arr"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Appends a record to the log.\n"
"\n"
":param arr:       Values to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("update", static_cast<void(wpi::log::FloatArrayLogEntry::*)(std::span<const float>, int64_t)>(
        &wpi::log::FloatArrayLogEntry::Update),
      py::arg("arr"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Updates the last value and appends a record to the log if it has changed.\n"
"\n"
".. note:: The last value is local to this class instance; using Update() with\n"
"   two instances pointing to the same underlying log entry name will likely\n"
"   result in unexpected results.\n"
"\n"
":param arr:       Values to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    .def_readonly_static("kDataType", &wpi::log::FloatArrayLogEntry::kDataType)
  ;

  


  }

  {
  
  
  
    static constexpr auto kDataType [[maybe_unused]] = wpi::log::DoubleArrayLogEntry::kDataType;
  


  

  cls_DoubleArrayLogEntry.doc() =
    "Log array of double values.";

  cls_DoubleArrayLogEntry
  
    
  .def(py::init<DataLog&, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .def(py::init<DataLog&, std::string_view, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("metadata"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .
def
("append", static_cast<void(wpi::log::DoubleArrayLogEntry::*)(std::span<const double>, int64_t)>(
        &wpi::log::DoubleArrayLogEntry::Append),
      py::arg("arr"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Appends a record to the log.\n"
"\n"
":param arr:       Values to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("update", static_cast<void(wpi::log::DoubleArrayLogEntry::*)(std::span<const double>, int64_t)>(
        &wpi::log::DoubleArrayLogEntry::Update),
      py::arg("arr"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Updates the last value and appends a record to the log if it has changed.\n"
"\n"
".. note:: The last value is local to this class instance; using Update() with\n"
"   two instances pointing to the same underlying log entry name will likely\n"
"   result in unexpected results.\n"
"\n"
":param arr:       Values to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    .def_readonly_static("kDataType", &wpi::log::DoubleArrayLogEntry::kDataType)
  ;

  


  }

  {
  
  
  
    static constexpr auto kDataType [[maybe_unused]] = wpi::log::StringArrayLogEntry::kDataType;
  


  

  cls_StringArrayLogEntry.doc() =
    "Log array of string values.";

  cls_StringArrayLogEntry
  
    
  .def(py::init<DataLog&, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .def(py::init<DataLog&, std::string_view, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("metadata"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .
def
("append", static_cast<void(wpi::log::StringArrayLogEntry::*)(std::span<const std::string_view>, int64_t)>(
        &wpi::log::StringArrayLogEntry::Append),
      py::arg("arr"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Appends a record to the log.\n"
"\n"
":param arr:       Values to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("update", static_cast<void(wpi::log::StringArrayLogEntry::*)(std::span<const std::string_view>, int64_t)>(
        &wpi::log::StringArrayLogEntry::Update),
      py::arg("arr"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Updates the last value and appends a record to the log if it has changed.\n"
"\n"
".. note:: The last value is local to this class instance; using Update() with\n"
"   two instances pointing to the same underlying log entry name will likely\n"
"   result in unexpected results.\n"
"\n"
":param arr:       Values to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    .def_readonly_static("kDataType", &wpi::log::StringArrayLogEntry::kDataType)
  ;

  


  }






}

}; // struct rpybuild_DataLog_initializer

static std::unique_ptr<rpybuild_DataLog_initializer> cls;

void begin_init_DataLog(py::module &m) {
  cls = std::make_unique<rpybuild_DataLog_initializer>(m);
}

void finish_init_DataLog() {
  cls->finish();
  cls.reset();
}