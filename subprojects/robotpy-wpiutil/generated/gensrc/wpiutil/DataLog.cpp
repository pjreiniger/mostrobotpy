
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <wpi/DataLog.h>


#include <pybind11/functional.h>

#include <wpi_span_type_caster.h>

#include <wpystruct.h>











#include "DataLog_tmpl.hpp"





#include <type_traits>


  using namespace wpi;

  using namespace wpi::log;

  using namespace wpi::log::impl;





struct rpybuild_DataLog_initializer {


  

  


  

  


  

  


  

  


  

  


  

  


  

  


  

  


  

  


  

  


  

  


  

  


  

  




  py::module pkg_log;




  
  py::enum_<wpi::log::impl::ControlRecordType> enum1;






  py::class_<typename wpi::log::DataLog> cls_DataLog;

    

    
    
  py::class_<typename wpi::log::DataLogEntry> cls_DataLogEntry;

    

    
    
  py::class_<typename wpi::log::RawLogEntry, wpi::log::DataLogEntry> cls_RawLogEntry;

    

    
    
  py::class_<typename wpi::log::BooleanLogEntry, wpi::log::DataLogEntry> cls_BooleanLogEntry;

    

    
    
  py::class_<typename wpi::log::IntegerLogEntry, wpi::log::DataLogEntry> cls_IntegerLogEntry;

    

    
    
  py::class_<typename wpi::log::FloatLogEntry, wpi::log::DataLogEntry> cls_FloatLogEntry;

    

    
    
  py::class_<typename wpi::log::DoubleLogEntry, wpi::log::DataLogEntry> cls_DoubleLogEntry;

    

    
    
  py::class_<typename wpi::log::StringLogEntry, wpi::log::DataLogEntry> cls_StringLogEntry;

    

    
    
  py::class_<typename wpi::log::BooleanArrayLogEntry, wpi::log::DataLogEntry> cls_BooleanArrayLogEntry;

    

    
    
  py::class_<typename wpi::log::IntegerArrayLogEntry, wpi::log::DataLogEntry> cls_IntegerArrayLogEntry;

    

    
    
  py::class_<typename wpi::log::FloatArrayLogEntry, wpi::log::DataLogEntry> cls_FloatArrayLogEntry;

    

    
    
  py::class_<typename wpi::log::DoubleArrayLogEntry, wpi::log::DataLogEntry> cls_DoubleArrayLogEntry;

    

    
    
  py::class_<typename wpi::log::StringArrayLogEntry, wpi::log::DataLogEntry> cls_StringArrayLogEntry;

    

    
    
  
      rpygen::bind_wpi__log__StructLogEntry_0 tmplCls0;
    
  
      rpygen::bind_wpi__log__StructArrayLogEntry_1 tmplCls1;
    

  py::module &m;

  
  rpybuild_DataLog_initializer(py::module &m) :

  
    pkg_log(m.def_submodule("log")),
  

  
    enum1
  (m, "ControlRecordType"
  ),
  

  

  
    cls_DataLog(pkg_log, "DataLog", py::is_final()),

  

  
  
  
    cls_DataLogEntry(pkg_log, "DataLogEntry"),

  

  
  
  
    cls_RawLogEntry(pkg_log, "RawLogEntry"),

  

  
  
  
    cls_BooleanLogEntry(pkg_log, "BooleanLogEntry"),

  

  
  
  
    cls_IntegerLogEntry(pkg_log, "IntegerLogEntry"),

  

  
  
  
    cls_FloatLogEntry(pkg_log, "FloatLogEntry"),

  

  
  
  
    cls_DoubleLogEntry(pkg_log, "DoubleLogEntry"),

  

  
  
  
    cls_StringLogEntry(pkg_log, "StringLogEntry"),

  

  
  
  
    cls_BooleanArrayLogEntry(pkg_log, "BooleanArrayLogEntry"),

  

  
  
  
    cls_IntegerArrayLogEntry(pkg_log, "IntegerArrayLogEntry"),

  

  
  
  
    cls_FloatArrayLogEntry(pkg_log, "FloatArrayLogEntry"),

  

  
  
  
    cls_DoubleArrayLogEntry(pkg_log, "DoubleArrayLogEntry"),

  

  
  
  
    cls_StringArrayLogEntry(pkg_log, "StringArrayLogEntry"),

  

  
  
  
    
        tmplCls0(pkg_log, "StructLogEntry"),
      
  
    
        tmplCls1(pkg_log, "StructArrayLogEntry"),
      
  

    m(m)
  {
    
    
      enum1
  
    .value("kControlStart", wpi::log::impl::ControlRecordType::kControlStart)
  
    .value("kControlFinish", wpi::log::impl::ControlRecordType::kControlFinish)
  
    .value("kControlSetMetadata", wpi::log::impl::ControlRecordType::kControlSetMetadata)
  ;

    

    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
  }

void finish() {



  tmplCls0.finish(
    NULL,
    NULL
  );

  tmplCls1.finish(
    NULL,
    NULL
  );



  {
  
  
  


  

  cls_DataLog.doc() =
    "A data log. The log file is created immediately upon construction with a\n"
"temporary filename.  The file may be renamed at any time using the\n"
"SetFilename() function.\n"
"\n"
"The lifetime of the data log object must be longer than any data log entry\n"
"objects that refer to it.\n"
"\n"
"The data log is periodically flushed to disk.  It can also be explicitly\n"
"flushed to disk by using the Flush() function.\n"
"\n"
"Finish() is needed only to indicate in the log that a particular entry is\n"
"no longer being used (it releases the name to ID mapping).  Finish() is not\n"
"required to be called for data to be flushed to disk; entries in the log\n"
"are written as Append() calls are being made.  In fact, Finish() does not\n"
"need to be called at all; this is helpful to avoid shutdown races where the\n"
"DataLog object might be destroyed before other objects.  It's often not a\n"
"good idea to call Finish() from destructors for this reason.\n"
"\n"
"DataLog calls are thread safe.  DataLog uses a typical multiple-supplier,\n"
"single-consumer setup.  Writes to the log are atomic, but there is no\n"
"guaranteed order in the log when multiple threads are writing to it;\n"
"whichever thread grabs the write mutex first will get written first.\n"
"For this reason (as well as the fact that timestamps can be set to\n"
"arbitrary values), records in the log are not guaranteed to be sorted by\n"
"timestamp.";

  cls_DataLog
  
    
  .def(py::init<std::string_view, std::string_view, double, std::string_view>(),
      py::arg("dir") = "", py::arg("filename") = "", py::arg("period") = 0.25, py::arg("extraHeader") = "", release_gil(), py::doc(
    "Construct a new Data Log.  The log will be initially created with a\n"
"temporary filename.\n"
"\n"
":param dir:         directory to store the log\n"
":param filename:    filename to use; if none provided, a random filename is\n"
"                    generated of the form \"wpilog\\_{}.wpilog\"\n"
":param period:      time between automatic flushes to disk, in seconds;\n"
"                    this is a time/storage tradeoff\n"
":param extraHeader: extra header data")
  )
  
  
  
    
  .def(py::init<std::function<void (std::span<const uint8_t> data)>, double, std::string_view>(),
      py::arg("write").none(false), py::arg("period") = 0.25, py::arg("extraHeader") = "", release_gil(), py::doc(
    "Construct a new Data Log that passes its output to the provided function\n"
"rather than a file.  The write function will be called on a separate\n"
"background thread and may block.  The write function is called with an\n"
"empty data array when the thread is terminating.\n"
"\n"
":param write:       write function\n"
":param period:      time between automatic calls to write, in seconds;\n"
"                    this is a time/storage tradeoff\n"
":param extraHeader: extra header data")
  )
  
  
  
    
  .
def
("setFilename", &wpi::log::DataLog::SetFilename,
      py::arg("filename"), release_gil(), py::doc(
    "Change log filename.\n"
"\n"
":param filename: filename")
  )
  
  
  
    
  .
def
("flush", &wpi::log::DataLog::Flush, release_gil(), py::doc(
    "Explicitly flushes the log data to disk.")
  )
  
  
  
    
  .
def
("pause", &wpi::log::DataLog::Pause, release_gil(), py::doc(
    "Pauses appending of data records to the log.  While paused, no data records\n"
"are saved (e.g. AppendX is a no-op).  Has no effect on entry starts /\n"
"finishes / metadata changes.")
  )
  
  
  
    
  .
def
("resume", &wpi::log::DataLog::Resume, release_gil(), py::doc(
    "Resumes appending of data records to the log.  If called after Stop(),\n"
"opens a new file (with random name if SetFilename was not called after\n"
"Stop()) and appends Start records and schema data values for all previously\n"
"started entries and schemas.")
  )
  
  
  
    
  .
def
("stop", &wpi::log::DataLog::Stop, release_gil(), py::doc(
    "Stops appending all records to the log, and closes the log file.")
  )
  
  
  
    
  .
def
("hasSchema", &wpi::log::DataLog::HasSchema,
      py::arg("name"), release_gil(), py::doc(
    "Returns whether there is a data schema already registered with the given\n"
"name.\n"
"\n"
":param name: Name (the string passed as the data type for records using this\n"
"             schema)\n"
"\n"
":returns: True if schema already registered")
  )
  
  
  
    
  .
def
("addSchema", static_cast<void(wpi::log::DataLog::*)(std::string_view, std::string_view, std::span<const uint8_t>, int64_t)>(
        &wpi::log::DataLog::AddSchema),
      py::arg("name"), py::arg("type"), py::arg("schema"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Registers a data schema.  Data schemas provide information for how a\n"
"certain data type string can be decoded.  The type string of a data schema\n"
"indicates the type of the schema itself (e.g. \"protobuf\" for protobuf\n"
"schemas, \"struct\" for struct schemas, etc). In the data log, schemas are\n"
"saved just like normal records, with the name being generated from the\n"
"provided name: \"/.schema/<name>\".  Duplicate calls to this function with\n"
"the same name are silently ignored.\n"
"\n"
":param name:      Name (the string passed as the data type for records using this\n"
"                  schema)\n"
":param type:      Type of schema (e.g. \"protobuf\", \"struct\", etc)\n"
":param schema:    Schema data\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("addSchema", static_cast<void(wpi::log::DataLog::*)(std::string_view, std::string_view, std::string_view, int64_t)>(
        &wpi::log::DataLog::AddSchema),
      py::arg("name"), py::arg("type"), py::arg("schema"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Registers a data schema.  Data schemas provide information for how a\n"
"certain data type string can be decoded.  The type string of a data schema\n"
"indicates the type of the schema itself (e.g. \"protobuf\" for protobuf\n"
"schemas, \"struct\" for struct schemas, etc). In the data log, schemas are\n"
"saved just like normal records, with the name being generated from the\n"
"provided name: \"/.schema/<name>\".  Duplicate calls to this function with\n"
"the same name are silently ignored.\n"
"\n"
":param name:      Name (the string passed as the data type for records using this\n"
"                  schema)\n"
":param type:      Type of schema (e.g. \"protobuf\", \"struct\", etc)\n"
":param schema:    Schema data\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("addStructSchema", [](DataLog &self, const py::type &t, int64_t timestamp) {
  WPyStructInfo info(t);
  return self.AddStructSchema<WPyStruct, WPyStructInfo>(info, timestamp);
}
,
      py::arg("type"), py::arg("timestamp") = 0, py::doc(
    "Registers a struct schema. Duplicate calls to this function with the same\n"
"name are silently ignored.\n"
"\n"
"@tparam T struct serializable type\n"
"\n"
":param type:      optional struct type info\n"
":param timestamp: Time stamp (0 to indicate now)")
  )
  
  
  
    
  .
def
("start", &wpi::log::DataLog::Start,
      py::arg("name"), py::arg("type"), py::arg("metadata") = std::string_view{}, py::arg("timestamp") = 0, release_gil(), py::doc(
    "Start an entry.  Duplicate names are allowed (with the same type), and\n"
"result in the same index being returned (Start/Finish are reference\n"
"counted).  A duplicate name with a different type will result in an error\n"
"message being printed to the console and 0 being returned (which will be\n"
"ignored by the Append functions).\n"
"\n"
":param name:      Name\n"
":param type:      Data type\n"
":param metadata:  Initial metadata (e.g. data properties)\n"
":param timestamp: Time stamp (may be 0 to indicate now)\n"
"\n"
":returns: Entry index")
  )
  
  
  
    
  .
def
("finish", &wpi::log::DataLog::Finish,
      py::arg("entry"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Finish an entry.\n"
"\n"
":param entry:     Entry index\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("setMetadata", &wpi::log::DataLog::SetMetadata,
      py::arg("entry"), py::arg("metadata"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Updates the metadata for an entry.\n"
"\n"
":param entry:     Entry index\n"
":param metadata:  New metadata for the entry\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("appendRaw", &wpi::log::DataLog::AppendRaw,
      py::arg("entry"), py::arg("data"), py::arg("timestamp"), release_gil(), py::doc(
    "Appends a raw record to the log.\n"
"\n"
":param entry:     Entry index, as returned by Start()\n"
":param data:      Byte array to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("appendRaw2", &wpi::log::DataLog::AppendRaw2,
      py::arg("entry"), py::arg("data"), py::arg("timestamp"), release_gil(), py::doc(
    "Appends a raw record to the log.\n"
"\n"
":param entry:     Entry index, as returned by Start()\n"
":param data:      Byte array to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("appendBoolean", &wpi::log::DataLog::AppendBoolean,
      py::arg("entry"), py::arg("value"), py::arg("timestamp"), release_gil(), py::doc(
    "Appends a boolean record to the log.\n"
"\n"
":param entry:     Entry index, as returned by Start()\n"
":param value:     Boolean value to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("appendInteger", &wpi::log::DataLog::AppendInteger,
      py::arg("entry"), py::arg("value"), py::arg("timestamp"), release_gil(), py::doc(
    "Appends an integer record to the log.\n"
"\n"
":param entry:     Entry index, as returned by Start()\n"
":param value:     Integer value to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("appendFloat", &wpi::log::DataLog::AppendFloat,
      py::arg("entry"), py::arg("value"), py::arg("timestamp"), release_gil(), py::doc(
    "Appends a float record to the log.\n"
"\n"
":param entry:     Entry index, as returned by Start()\n"
":param value:     Float value to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("appendDouble", &wpi::log::DataLog::AppendDouble,
      py::arg("entry"), py::arg("value"), py::arg("timestamp"), release_gil(), py::doc(
    "Appends a double record to the log.\n"
"\n"
":param entry:     Entry index, as returned by Start()\n"
":param value:     Double value to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("appendString", &wpi::log::DataLog::AppendString,
      py::arg("entry"), py::arg("value"), py::arg("timestamp"), release_gil(), py::doc(
    "Appends a string record to the log.\n"
"\n"
":param entry:     Entry index, as returned by Start()\n"
":param value:     String value to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("appendBooleanArray", static_cast<void(wpi::log::DataLog::*)(int, std::span<const bool>, int64_t)>(
        &wpi::log::DataLog::AppendBooleanArray),
      py::arg("entry"), py::arg("arr"), py::arg("timestamp"), release_gil(), py::doc(
    "Appends a boolean array record to the log.\n"
"\n"
":param entry:     Entry index, as returned by Start()\n"
":param arr:       Boolean array to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("appendIntegerArray", &wpi::log::DataLog::AppendIntegerArray,
      py::arg("entry"), py::arg("arr"), py::arg("timestamp"), release_gil(), py::doc(
    "Appends an integer array record to the log.\n"
"\n"
":param entry:     Entry index, as returned by Start()\n"
":param arr:       Integer array to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("appendFloatArray", &wpi::log::DataLog::AppendFloatArray,
      py::arg("entry"), py::arg("arr"), py::arg("timestamp"), release_gil(), py::doc(
    "Appends a float array record to the log.\n"
"\n"
":param entry:     Entry index, as returned by Start()\n"
":param arr:       Float array to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("appendDoubleArray", &wpi::log::DataLog::AppendDoubleArray,
      py::arg("entry"), py::arg("arr"), py::arg("timestamp"), release_gil(), py::doc(
    "Appends a double array record to the log.\n"
"\n"
":param entry:     Entry index, as returned by Start()\n"
":param arr:       Double array to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("appendStringArray", static_cast<void(wpi::log::DataLog::*)(int, std::span<const std::string_view>, int64_t)>(
        &wpi::log::DataLog::AppendStringArray),
      py::arg("entry"), py::arg("arr"), py::arg("timestamp"), release_gil(), py::doc(
    "Appends a string array record to the log.\n"
"\n"
":param entry:     Entry index, as returned by Start()\n"
":param arr:       String array to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  ;

  


  }

  {
  
  
  


  

  cls_DataLogEntry.doc() =
    "Log entry base class.";

  cls_DataLogEntry
  
    
  .
def
("setMetadata", &wpi::log::DataLogEntry::SetMetadata,
      py::arg("metadata"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Updates the metadata for the entry.\n"
"\n"
":param metadata:  New metadata for the entry\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    
  .
def
("finish", &wpi::log::DataLogEntry::Finish,
      py::arg("timestamp") = 0, release_gil(), py::doc(
    "Finishes the entry.\n"
"\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  ;

  


  }

  {
  
  
  
    static constexpr auto kDataType [[maybe_unused]] = wpi::log::RawLogEntry::kDataType;
  


  

  cls_RawLogEntry.doc() =
    "Log arbitrary byte data.";

  cls_RawLogEntry
  
    
  .def(py::init<DataLog&, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .def(py::init<DataLog&, std::string_view, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("metadata"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .def(py::init<DataLog&, std::string_view, std::string_view, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("metadata"), py::arg("type"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .
def
("append", &wpi::log::RawLogEntry::Append,
      py::arg("data"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Appends a record to the log.\n"
"\n"
":param data:      Data to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    .def_readonly_static("kDataType", &wpi::log::RawLogEntry::kDataType)
  ;

  


  }

  {
  
  
  
    static constexpr auto kDataType [[maybe_unused]] = wpi::log::BooleanLogEntry::kDataType;
  


  

  cls_BooleanLogEntry.doc() =
    "Log boolean values.";

  cls_BooleanLogEntry
  
    
  .def(py::init<DataLog&, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .def(py::init<DataLog&, std::string_view, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("metadata"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .
def
("append", &wpi::log::BooleanLogEntry::Append,
      py::arg("value"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Appends a record to the log.\n"
"\n"
":param value:     Value to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    .def_readonly_static("kDataType", &wpi::log::BooleanLogEntry::kDataType)
  ;

  


  }

  {
  
  
  
    static constexpr auto kDataType [[maybe_unused]] = wpi::log::IntegerLogEntry::kDataType;
  


  

  cls_IntegerLogEntry.doc() =
    "Log integer values.";

  cls_IntegerLogEntry
  
    
  .def(py::init<DataLog&, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .def(py::init<DataLog&, std::string_view, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("metadata"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .
def
("append", &wpi::log::IntegerLogEntry::Append,
      py::arg("value"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Appends a record to the log.\n"
"\n"
":param value:     Value to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    .def_readonly_static("kDataType", &wpi::log::IntegerLogEntry::kDataType)
  ;

  


  }

  {
  
  
  
    static constexpr auto kDataType [[maybe_unused]] = wpi::log::FloatLogEntry::kDataType;
  


  

  cls_FloatLogEntry.doc() =
    "Log float values.";

  cls_FloatLogEntry
  
    
  .def(py::init<DataLog&, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .def(py::init<DataLog&, std::string_view, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("metadata"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .
def
("append", &wpi::log::FloatLogEntry::Append,
      py::arg("value"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Appends a record to the log.\n"
"\n"
":param value:     Value to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    .def_readonly_static("kDataType", &wpi::log::FloatLogEntry::kDataType)
  ;

  


  }

  {
  
  
  
    static constexpr auto kDataType [[maybe_unused]] = wpi::log::DoubleLogEntry::kDataType;
  


  

  cls_DoubleLogEntry.doc() =
    "Log double values.";

  cls_DoubleLogEntry
  
    
  .def(py::init<DataLog&, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .def(py::init<DataLog&, std::string_view, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("metadata"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .
def
("append", &wpi::log::DoubleLogEntry::Append,
      py::arg("value"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Appends a record to the log.\n"
"\n"
":param value:     Value to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    .def_readonly_static("kDataType", &wpi::log::DoubleLogEntry::kDataType)
  ;

  


  }

  {
  
  
  
    static constexpr auto kDataType [[maybe_unused]] = wpi::log::StringLogEntry::kDataType;
  


  

  cls_StringLogEntry.doc() =
    "Log string values.";

  cls_StringLogEntry
  
    
  .def(py::init<DataLog&, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .def(py::init<DataLog&, std::string_view, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("metadata"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .def(py::init<DataLog&, std::string_view, std::string_view, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("metadata"), py::arg("type"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .
def
("append", &wpi::log::StringLogEntry::Append,
      py::arg("value"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Appends a record to the log.\n"
"\n"
":param value:     Value to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    .def_readonly_static("kDataType", &wpi::log::StringLogEntry::kDataType)
  ;

  


  }

  {
  
  
  
    static constexpr auto kDataType [[maybe_unused]] = wpi::log::BooleanArrayLogEntry::kDataType;
  


  

  cls_BooleanArrayLogEntry.doc() =
    "Log array of boolean values.";

  cls_BooleanArrayLogEntry
  
    
  .def(py::init<DataLog&, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .def(py::init<DataLog&, std::string_view, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("metadata"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .
def
("append", static_cast<void(wpi::log::BooleanArrayLogEntry::*)(std::span<const bool>, int64_t)>(
        &wpi::log::BooleanArrayLogEntry::Append),
      py::arg("arr"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Appends a record to the log.  For find functions to work, timestamp\n"
"must be monotonically increasing.\n"
"\n"
":param arr:       Values to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    .def_readonly_static("kDataType", &wpi::log::BooleanArrayLogEntry::kDataType)
  ;

  


  }

  {
  
  
  
    static constexpr auto kDataType [[maybe_unused]] = wpi::log::IntegerArrayLogEntry::kDataType;
  


  

  cls_IntegerArrayLogEntry.doc() =
    "Log array of integer values.";

  cls_IntegerArrayLogEntry
  
    
  .def(py::init<DataLog&, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .def(py::init<DataLog&, std::string_view, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("metadata"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .
def
("append", static_cast<void(wpi::log::IntegerArrayLogEntry::*)(std::span<const int64_t>, int64_t)>(
        &wpi::log::IntegerArrayLogEntry::Append),
      py::arg("arr"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Appends a record to the log.\n"
"\n"
":param arr:       Values to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    .def_readonly_static("kDataType", &wpi::log::IntegerArrayLogEntry::kDataType)
  ;

  


  }

  {
  
  
  
    static constexpr auto kDataType [[maybe_unused]] = wpi::log::FloatArrayLogEntry::kDataType;
  


  

  cls_FloatArrayLogEntry.doc() =
    "Log array of float values.";

  cls_FloatArrayLogEntry
  
    
  .def(py::init<DataLog&, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .def(py::init<DataLog&, std::string_view, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("metadata"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .
def
("append", static_cast<void(wpi::log::FloatArrayLogEntry::*)(std::span<const float>, int64_t)>(
        &wpi::log::FloatArrayLogEntry::Append),
      py::arg("arr"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Appends a record to the log.\n"
"\n"
":param arr:       Values to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    .def_readonly_static("kDataType", &wpi::log::FloatArrayLogEntry::kDataType)
  ;

  


  }

  {
  
  
  
    static constexpr auto kDataType [[maybe_unused]] = wpi::log::DoubleArrayLogEntry::kDataType;
  


  

  cls_DoubleArrayLogEntry.doc() =
    "Log array of double values.";

  cls_DoubleArrayLogEntry
  
    
  .def(py::init<DataLog&, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .def(py::init<DataLog&, std::string_view, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("metadata"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .
def
("append", static_cast<void(wpi::log::DoubleArrayLogEntry::*)(std::span<const double>, int64_t)>(
        &wpi::log::DoubleArrayLogEntry::Append),
      py::arg("arr"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Appends a record to the log.\n"
"\n"
":param arr:       Values to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    .def_readonly_static("kDataType", &wpi::log::DoubleArrayLogEntry::kDataType)
  ;

  


  }

  {
  
  
  
    static constexpr auto kDataType [[maybe_unused]] = wpi::log::StringArrayLogEntry::kDataType;
  


  

  cls_StringArrayLogEntry.doc() =
    "Log array of string values.";

  cls_StringArrayLogEntry
  
    
  .def(py::init<DataLog&, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .def(py::init<DataLog&, std::string_view, std::string_view, int64_t>(),
      py::arg("log"), py::arg("name"), py::arg("metadata"), py::arg("timestamp") = 0, release_gil()
    , py::keep_alive<1, 2>()
  )
  
  
  
    
  .
def
("append", static_cast<void(wpi::log::StringArrayLogEntry::*)(std::span<const std::string_view>, int64_t)>(
        &wpi::log::StringArrayLogEntry::Append),
      py::arg("arr"), py::arg("timestamp") = 0, release_gil(), py::doc(
    "Appends a record to the log.\n"
"\n"
":param arr:       Values to record\n"
":param timestamp: Time stamp (may be 0 to indicate now)")
  )
  
  
  
    .def_readonly_static("kDataType", &wpi::log::StringArrayLogEntry::kDataType)
  ;

  


  }






}

}; // struct rpybuild_DataLog_initializer

static std::unique_ptr<rpybuild_DataLog_initializer> cls;

void begin_init_DataLog(py::module &m) {
  cls = std::make_unique<rpybuild_DataLog_initializer>(m);
}

void finish_init_DataLog() {
  cls->finish();
  cls.reset();
}