
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <wpi/DataLogReader.h>


#include <pybind11/stl.h>

#include <wpi_span_type_caster.h>















#include <type_traits>


  using namespace wpi::log;



struct rpybuild_DataLogReader_initializer {


  

  


  

  


  

  


  
    using MemoryBuffer = wpi::MemoryBuffer;
  

  




  py::module pkg_log;









  py::class_<typename wpi::log::StartRecordData> cls_StartRecordData;

    

    
    
  py::class_<typename wpi::log::MetadataRecordData> cls_MetadataRecordData;

    

    
    
  py::class_<typename wpi::log::DataLogRecord> cls_DataLogRecord;

    

    
    
  py::class_<typename wpi::log::DataLogReader> cls_DataLogReader;

    

    
    

  py::module &m;

  
  rpybuild_DataLogReader_initializer(py::module &m) :

  
    pkg_log(m.def_submodule("log")),
  

  

  

  
    cls_StartRecordData(pkg_log, "StartRecordData"),

  

  
  
  
    cls_MetadataRecordData(pkg_log, "MetadataRecordData"),

  

  
  
  
    cls_DataLogRecord(pkg_log, "DataLogRecord"),

  

  
  
  
    cls_DataLogReader(pkg_log, "DataLogReader"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
    
  

    
    
    
  

    
    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_StartRecordData.doc() =
    "Data contained in a start control record as created by DataLog::Start() when\n"
"writing the log. This can be read by calling DataLogRecord::GetStartData().";

  cls_StartRecordData
  
    .def(py::init<>(), release_gil())
  
    .def_readonly("entry", &wpi::log::StartRecordData::entry, py::doc(
    "Entry ID; this will be used for this entry in future records."))
  
    .def_readonly("name", &wpi::log::StartRecordData::name, py::doc(
    "Entry name."))
  
    .def_readonly("type", &wpi::log::StartRecordData::type, py::doc(
    "Type of the stored data for this entry, as a string, e.g. \"double\"."))
  
    .def_readonly("metadata", &wpi::log::StartRecordData::metadata, py::doc(
    "Initial metadata."))
  ;

  


  }

  {
  
  
  


  

  cls_MetadataRecordData.doc() =
    "Data contained in a set metadata control record as created by\n"
"DataLog::SetMetadata(). This can be read by calling\n"
"DataLogRecord::GetSetMetadataData().";

  cls_MetadataRecordData
  
    .def(py::init<>(), release_gil())
  
    .def_readonly("entry", &wpi::log::MetadataRecordData::entry, py::doc(
    "Entry ID."))
  
    .def_readonly("metadata", &wpi::log::MetadataRecordData::metadata, py::doc(
    "New metadata for the entry."))
  ;

  


  }

  {
  
  
  


  

  cls_DataLogRecord.doc() =
    "A record in the data log. May represent either a control record (entry == 0)\n"
"or a data record. Used only for reading (e.g. with DataLogReader).";

  cls_DataLogRecord
  
    
  .
def
("getEntry", &wpi::log::DataLogRecord::GetEntry, release_gil(), py::doc(
    "Gets the entry ID.\n"
"\n"
":returns: entry ID")
  )
  
  
  
    
  .
def
("getTimestamp", &wpi::log::DataLogRecord::GetTimestamp, release_gil(), py::doc(
    "Gets the record timestamp.\n"
"\n"
":returns: Timestamp, in integer microseconds")
  )
  
  
  
    
  .
def
("getSize", &wpi::log::DataLogRecord::GetSize, release_gil(), py::doc(
    "Gets the size of the raw data.\n"
"\n"
":returns: size")
  )
  
  
  
    
  .
def
("getRaw", [](const DataLogRecord *self) {
  auto data = self->GetRaw();
  return py::bytes((char*)data.data(), data.size());
}
, py::doc(
    "Gets the raw data. Use the GetX functions to decode based on the data type\n"
"in the entry's start record.")
  )
  
  
  
    
  .
def
("isControl", &wpi::log::DataLogRecord::IsControl, release_gil(), py::doc(
    "Returns true if the record is a control record.\n"
"\n"
":returns: True if control record, false if normal data record.")
  )
  
  
  
    
  .
def
("isStart", &wpi::log::DataLogRecord::IsStart, release_gil(), py::doc(
    "Returns true if the record is a start control record. Use GetStartData()\n"
"to decode the contents.\n"
"\n"
":returns: True if start control record, false otherwise.")
  )
  
  
  
    
  .
def
("isFinish", &wpi::log::DataLogRecord::IsFinish, release_gil(), py::doc(
    "Returns true if the record is a finish control record. Use GetFinishEntry()\n"
"to decode the contents.\n"
"\n"
":returns: True if finish control record, false otherwise.")
  )
  
  
  
    
  .
def
("isSetMetadata", &wpi::log::DataLogRecord::IsSetMetadata, release_gil(), py::doc(
    "Returns true if the record is a set metadata control record. Use\n"
"GetSetMetadataData() to decode the contents.\n"
"\n"
":returns: True if set metadata control record, false otherwise.")
  )
  
  
  
    
  .
def
("getStartData", [](const DataLogRecord *self) {
  auto ptr = std::make_unique<wpi::log::StartRecordData>();
  if (!self->GetStartData(ptr.get())) {
    throw py::type_error("not a start record");
  }
  return ptr;
}
, py::return_value_policy::reference_internal, py::doc(
    "Decodes a start control record. Raises TypeError on error.\n")
  )
  
  
  
    
  .
def
("getFinishEntry", [](const DataLogRecord *self) {
  int value;
  if (!self->GetFinishEntry(&value)) {
    throw py::type_error("not a finish entry");
  }
  return value;
}
, py::doc(
    "Decodes a finish control record. Raises TypeError on error.\n")
  )
  
  
  
    
  .
def
("getSetMetadataData", [](const DataLogRecord *self) {
  auto ptr = std::make_unique<wpi::log::MetadataRecordData>();
  if (!self->GetSetMetadataData(ptr.get())) {
    throw py::type_error("not a metadata control record");
  }
  return ptr;
}
, py::return_value_policy::reference_internal, py::doc(
    "Decodes a set metadata control record. Raises TypeError on error.\n")
  )
  
  
  
    
  .
def
("getBoolean", [](const DataLogRecord *self) {
  bool value;
  if (!self->GetBoolean(&value)) {
    throw py::type_error("not a boolean");
  }
  return value;
}
, py::doc(
    "Decodes a data record as a boolean. Note if the data type (as indicated in\n"
"the corresponding start control record for this entry) is not \"boolean\",\n"
"invalid results may be returned or TypeError will be raised.\n")
  )
  
  
  
    
  .
def
("getInteger", [](const DataLogRecord *self) {
  int64_t value;
  if (!self->GetInteger(&value)) {
    throw py::type_error("not an integer");
  }
  return value;
}
, py::doc(
    "Decodes a data record as an integer. Note if the data type (as indicated in\n"
"the corresponding start control record for this entry) is not \"int64\",\n"
"invalid results may be returned or TypeError will be raised.\n")
  )
  
  
  
    
  .
def
("getFloat", [](const DataLogRecord *self) {
  float value;
  if (!self->GetFloat(&value)) {
    throw py::type_error("not a float");
  }
  return value;
}
, py::doc(
    "Decodes a data record as a float. Note if the data type (as indicated in\n"
"the corresponding start control record for this entry) is not \"float\",\n"
"invalid results may be returned or TypeError will be raised.\n")
  )
  
  
  
    
  .
def
("getDouble", [](const DataLogRecord *self) {
  double value;
  if (!self->GetDouble(&value)) {
    throw py::type_error("not a double");
  }
  return value;
}
, py::doc(
    "Decodes a data record as a double. Note if the data type (as indicated in\n"
"the corresponding start control record for this entry) is not \"double\",\n"
"invalid results may be returned or TypeError will be raised.\n")
  )
  
  
  
    
  .
def
("getString", [](const DataLogRecord *self) {
  std::string_view value;
  if (!self->GetString(&value)) {
    throw py::type_error("not a string");
  }
  return value;
}
, py::doc(
    "Decodes a data record as a string. Note if the data type (as indicated in\n"
"the corresponding start control record for this entry) is not \"string\",\n"
"invalid results may be returned or TypeError will be raised.\n")
  )
  
  
  
    
  .
def
("getBooleanArray", [](const DataLogRecord *self) {
  std::vector<int> arr;
  if (!self->GetBooleanArray(&arr)) {
    throw py::type_error("not a boolean array");
  }
  py::list l(arr.size());
  for (size_t i = 0; i < arr.size(); i++) {
    auto b = py::bool_(arr[i]);
    PyList_SET_ITEM(l.ptr(), i, b.release().ptr());
  }
  return l;
}
, py::doc(
    "Decodes a data record as a boolean array. Note if the data type (as\n"
"indicated in the corresponding start control record for this entry) is not\n"
"\"boolean[]\", invalid results may be returned or a TypeError may be raised.\n")
  )
  
  
  
    
  .
def
("getIntegerArray", [](const DataLogRecord *self) {
  std::vector<int64_t> arr;
  if (!self->GetIntegerArray(&arr)) {
    throw py::type_error("not an integer array");
  }
  return arr;
}
, py::doc(
    "Decodes a data record as an integer array. Note if the data type (as\n"
"indicated in the corresponding start control record for this entry) is not\n"
"\"int64[]\", invalid results may be returned or a TypeError may be raised.\n")
  )
  
  
  
    
  .
def
("getFloatArray", [](const DataLogRecord *self) {
  std::vector<float> arr;
  if (!self->GetFloatArray(&arr)) {
    throw py::type_error("not a float array");
  }
  return arr;
}
, py::doc(
    "Decodes a data record as a float array. Note if the data type (as\n"
"indicated in the corresponding start control record for this entry) is not\n"
"\"float[]\", invalid results may be returned or a TypeError may be raised.\n")
  )
  
  
  
    
  .
def
("getDoubleArray", [](const DataLogRecord *self) {
  std::vector<double> arr;
  if (!self->GetDoubleArray(&arr)) {
    throw py::type_error("not a double array");
  }
  return arr;
}
, py::doc(
    "Decodes a data record as a double array. Note if the data type (as\n"
"indicated in the corresponding start control record for this entry) is not\n"
"\"double[]\", invalid results may be returned or a TypeError may be raised.\n")
  )
  
  
  
    
  .
def
("getStringArray", [](const DataLogRecord *self) {
  std::vector<std::string_view> arr;
  if (!self->GetStringArray(&arr)) {
    throw py::type_error("not a string array");
  }
  return arr;
}
, py::doc(
    "Decodes a data record as a string array. Note if the data type (as\n"
"indicated in the corresponding start control record for this entry) is not\n"
"\"string[]\", invalid results may be returned or a TypeError may be raised.\n")
  )
  
  
  ;

  


  }

  {
  
  
  
    using iterator [[maybe_unused]] = typename wpi::log::DataLogReader::iterator;
  


  

  cls_DataLogReader.doc() =
    "Data log reader (reads logs written by the DataLog class).";

  cls_DataLogReader
  
    
  .
def
("isValid", &wpi::log::DataLogReader::IsValid, release_gil(), py::doc(
    "Returns true if the data log is valid (e.g. has a valid header).")
  )
  
  
  
    
  .
def
("getVersion", &wpi::log::DataLogReader::GetVersion, release_gil(), py::doc(
    "Gets the data log version. Returns 0 if data log is invalid.\n"
"\n"
":returns: Version number; most significant byte is major, least significant\n"
"          is minor (so version 1.0 will be 0x0100)")
  )
  
  
  
    
  .
def
("getExtraHeader", &wpi::log::DataLogReader::GetExtraHeader, release_gil(), py::doc(
    "Gets the extra header data.\n"
"\n"
":returns: Extra header data")
  )
  
  
  
    
  .
def
("getBufferIdentifier", &wpi::log::DataLogReader::GetBufferIdentifier, release_gil(), py::doc(
    "Gets the buffer identifier, typically the filename.\n"
"\n"
":returns: Identifier string")
  )
  
  
  ;

  


  }







  cls_StartRecordData
  .def("__repr__", [](const wpi::log::StartRecordData &data) -> std::string {
    return "StartRecordData(entry=" + std::to_string(data.entry) + ", "
                           "name=\"" + std::string(data.name) + "\", "
                           "type=\"" + std::string(data.type) + "\", "
                           "metadata=\"" + std::string(data.metadata) + "\")";
  });

cls_MetadataRecordData
  .def("__repr__", [](const wpi::log::MetadataRecordData &data) -> std::string {
    return "MetadataRecordData(entry=" + std::to_string(data.entry) + ", "
                              "metadata=\"" + std::string(data.metadata) + "\")";
  });


cls_DataLogReader
  .def(py::init([](const std::string &filename) {
    auto mbuf = wpi::MemoryBuffer::GetFile(filename);
    if (!mbuf) {
      py::gil_scoped_acquire gil;
      #ifdef _WIN32
        PyErr_SetFromWindowsErr(mbuf.error().value());
      #else
        errno = mbuf.error().value();
        PyErr_SetFromErrno(PyExc_OSError);
      #endif
      throw py::error_already_set();
    }

    return std::make_shared<wpi::log::DataLogReader>(std::move(*mbuf));
  }),
    release_gil(), py::arg("filename"))

  .def(py::init([](const py::buffer &buffer, const std::string &name) {
    auto req = buffer.request();
    if (req.itemsize != 1) {
      throw py::value_error("buffer must only contain bytes");
    } else if (req.ndim != 1) {
      throw py::value_error("buffer must only have a single dimension");
    }

    auto mbuf = wpi::MemoryBuffer::GetMemBuffer(std::span((uint8_t*)req.ptr, req.size), name);

    {
      py::gil_scoped_release gil;
      return std::make_shared<wpi::log::DataLogReader>(std::move(mbuf));
    }
  }),
    py::arg("buffer"), py::arg("name") = "",
    py::keep_alive<1, 2>())
  .def("__iter__", [](wpi::log::DataLogReader * that) {
    return py::make_iterator(that->begin(), that->end());
  }, py::keep_alive<0,1>());


}

}; // struct rpybuild_DataLogReader_initializer

static std::unique_ptr<rpybuild_DataLogReader_initializer> cls;

void begin_init_DataLogReader(py::module &m) {
  cls = std::make_unique<rpybuild_DataLogReader_initializer>(m);
}

void finish_init_DataLogReader() {
  cls->finish();
  cls.reset();
}