
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <wpi/Synchronization.h>


#include <wpi_span_type_caster.h>













#include <pybind11/stl.h>



#include <type_traits>


  using namespace wpi;





struct rpybuild_Synchronization_initializer {




  py::module pkg_sync;










  py::module &m;

  
  rpybuild_Synchronization_initializer(py::module &m) :

  
    pkg_sync(m.def_submodule("sync")),
  

  

  

  

    m(m)
  {
    
    

    
  }

void finish() {







pkg_sync
  .
def
("createEvent", &wpi::CreateEvent,
      py::arg("manualReset") = false, py::arg("initialState") = false, release_gil(), py::doc(
    "Creates an event.  Events have binary state (signaled or not signaled) and\n"
"may be either automatically reset or manually reset.  Automatic-reset events\n"
"go to non-signaled state when a WaitForObject is woken up by the event;\n"
"manual-reset events require ResetEvent() to be called to set the event to\n"
"non-signaled state; if ResetEvent() is not called, any waiter on that event\n"
"will immediately wake when called.\n"
"\n"
":param manualReset:  true for manual reset, false for automatic reset\n"
":param initialState: true to make the event initially in signaled state\n"
"\n"
":returns: Event handle")
  )
  
  ;
pkg_sync
  .
def
("destroyEvent", &wpi::DestroyEvent,
      py::arg("handle"), release_gil(), py::doc(
    "Destroys an event.  Destruction wakes up any waiters.\n"
"\n"
":param handle: event handle")
  )
  
  ;
pkg_sync
  .
def
("setEvent", &wpi::SetEvent,
      py::arg("handle"), release_gil(), py::doc(
    "Sets an event to signaled state.\n"
"\n"
":param handle: event handle")
  )
  
  ;
pkg_sync
  .
def
("resetEvent", &wpi::ResetEvent,
      py::arg("handle"), release_gil(), py::doc(
    "Sets an event to non-signaled state.\n"
"\n"
":param handle: event handle")
  )
  
  ;
pkg_sync
  .
def
("createSemaphore", &wpi::CreateSemaphore,
      py::arg("initialCount") = 0, py::arg("maximumCount") = INT_MAX, release_gil(), py::doc(
    "Creates a semaphore.  Semaphores keep an internal counter.  Releasing the\n"
"semaphore increases the count.  A semaphore with a non-zero count is\n"
"considered signaled.  When a waiter wakes up it atomically decrements the\n"
"count by 1.  This is generally useful in a single-supplier,\n"
"multiple-consumer scenario.\n"
"\n"
":param initialCount: initial value for the semaphore's internal counter\n"
":param maximumCount: maximum value for the samephore's internal counter\n"
"\n"
":returns: Semaphore handle")
  )
  
  ;
pkg_sync
  .
def
("destroySemaphore", &wpi::DestroySemaphore,
      py::arg("handle"), release_gil(), py::doc(
    "Destroys a semaphore.  Destruction wakes up any waiters.\n"
"\n"
":param handle: semaphore handle")
  )
  
  ;
pkg_sync
  .
def
("releaseSemaphore", [](WPI_SemaphoreHandle handle, int releaseCount) {
                    int prevCount = 0;
          auto __ret =wpi::ReleaseSemaphore(std::move(handle), std::move(releaseCount), &prevCount);
          return std::make_tuple(__ret,prevCount);
        },
      py::arg("handle"), py::arg("releaseCount") = 1, release_gil(), py::doc(
    "Releases N counts of a semaphore.\n"
"\n"
":param handle:       semaphore handle\n"
":param releaseCount: amount to add to semaphore's internal counter;\n"
"                     must be positive\n"
":param prevCount:    if non-null, previous count (output parameter)\n"
"\n"
":returns: True on successful release, false on failure (e.g. release count\n"
"          would exceed maximum value, or handle invalid)")
  )
  
  ;
pkg_sync
  .
def
("waitForObject", static_cast<bool(*)(WPI_Handle)>(
        &wpi::WaitForObject),
      py::arg("handle"), release_gil(), py::doc(
    "Waits for an handle to be signaled.\n"
"\n"
":param handle: handle to wait on\n"
"\n"
":returns: True if handle was signaled, false otherwise (e.g. object was\n"
"          destroyed)")
  )
  
  ;
pkg_sync
  .
def
("waitForObject", [](WPI_Handle handle, double timeout) {
                    bool timedOut;
          auto __ret =wpi::WaitForObject(std::move(handle), std::move(timeout), &timedOut);
          return std::make_tuple(__ret,timedOut);
        },
      py::arg("handle"), py::arg("timeout"), release_gil(), py::doc(
    "Waits for an handle to be signaled, with timeout.\n"
"\n"
":param handle:   handle to wait on\n"
":param timeout:  timeout in seconds\n"
":param timedOut: if non-null, set to true if timeout reached without handle\n"
"                 being signaled; set to false otherwise (output)\n"
"\n"
":returns: True if handle was signaled, false otherwise (e.g. object was\n"
"          destroyed or timed out)")
  )
  
  ;
pkg_sync
  .
def
("waitForObjects", [](std::span<const WPI_Handle> handles) {
  py::gil_scoped_release release;
  std::vector<WPI_Handle> signaled(handles.size());
  auto result = wpi::WaitForObjects(handles, signaled);
  signaled.resize(result.size());
  return signaled;
}
,
      py::arg("handles"), py::doc(
    "Waits for one or more handles to be signaled.\n"
"\n"
"Invalid handles are treated as signaled; the returned array will have the\n"
"handle error bit set for any invalid handles.\n"
"\n"
":param handles:  array of handles to wait on\n"
":param signaled: output array for storage of signaled handles; must be at\n"
"                 least the size of the handles input array\n"
"\n"
":returns: array of signaled handles (points into signaled array)")
  )
  
  ;
pkg_sync
  .
def
("waitForObjects", [](std::span<const WPI_Handle> handles, double timeout) {
  py::gil_scoped_release release;
  std::vector<WPI_Handle> signaled(handles.size());
  bool timedOut = false;
  auto result = wpi::WaitForObjects(handles, signaled, timeout, &timedOut);
  signaled.resize(result.size());
  return std::make_tuple(signaled, timedOut);
}
,
      py::arg("handles"), py::arg("timeout"), py::doc(
    "Waits for one or more handles to be signaled, with timeout.\n"
"\n"
"Invalid handles are treated as signaled; the returned array will have the\n"
"handle error bit set for any invalid handles.\n"
"\n"
":param handles:  array of handles to wait on\n"
":param signaled: output array for storage of signaled handles; must be at\n"
"                 least the size of the handles input array\n"
":param timeout:  timeout in seconds\n"
":param timedOut: if non-null, set to true if timeout reached without any\n"
"                 handle being signaled; set to false otherwise (output)\n"
"\n"
":returns: array of signaled handles (points into signaled array)")
  )
  
  ;
pkg_sync
  .
def
("createSignalObject", &wpi::CreateSignalObject,
      py::arg("handle"), py::arg("manualReset") = false, py::arg("initialState") = false, release_gil(), py::doc(
    "Sets up signaling for an arbitrary handle.  With this function, any handle\n"
"can operate like an event handle.\n"
"\n"
":param handle:       Event handle\n"
":param manualReset:  true for manual reset, false for automatic reset\n"
":param initialState: true to make the handle initially in signaled state")
  )
  
  ;
pkg_sync
  .
def
("setSignalObject", &wpi::SetSignalObject,
      py::arg("handle"), release_gil(), py::doc(
    "Sets a handle to signaled state.\n"
"\n"
":param handle: handle")
  )
  
  ;
pkg_sync
  .
def
("resetSignalObject", &wpi::ResetSignalObject,
      py::arg("handle"), release_gil(), py::doc(
    "Sets a handle to non-signaled state.\n"
"\n"
":param handle: handle")
  )
  
  ;
pkg_sync
  .
def
("destroySignalObject", &wpi::DestroySignalObject,
      py::arg("handle"), release_gil(), py::doc(
    "Cleans up signaling for a handle.  Destruction wakes up any waiters.\n"
"\n"
":param handle: handle")
  )
  
  ;



}

}; // struct rpybuild_Synchronization_initializer

static std::unique_ptr<rpybuild_Synchronization_initializer> cls;

void begin_init_Synchronization(py::module &m) {
  cls = std::make_unique<rpybuild_Synchronization_initializer>(m);
}

void finish_init_Synchronization() {
  cls->finish();
  cls.reset();
}