
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <wpi/sendable/SendableRegistry.h>


#include <pybind11/functional.h>













#include <wpi/sendable/Sendable.h>

#include <wpi/sendable/SendableBuilder.h>



#include <type_traits>


  using namespace wpi;



PYBIND11_TYPE_CASTER_BASE_HOLDER(typename wpi::SendableRegistry, std::unique_ptr<typename wpi::SendableRegistry, py::nodelete>);



struct rpybuild_SendableRegistry_initializer {


  

  












  py::class_<typename wpi::SendableRegistry, std::unique_ptr<typename wpi::SendableRegistry, py::nodelete>> cls_SendableRegistry;

    

    
    

  py::module &m;

  
  rpybuild_SendableRegistry_initializer(py::module &m) :

  

  

  

  
    cls_SendableRegistry(m, "SendableRegistry", py::is_final()),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  
    using UID [[maybe_unused]] = typename wpi::SendableRegistry::UID;
  


  

  cls_SendableRegistry.doc() =
    "The SendableRegistry class is the public interface for registering sensors\n"
"and actuators for use on dashboards and LiveWindow.";

  cls_SendableRegistry
  
    
  .
def_static
("setLiveWindowBuilderFactory", &wpi::SendableRegistry::SetLiveWindowBuilderFactory,
      py::arg("factory").none(false), release_gil(), py::doc(
    "Sets the factory for LiveWindow builders.\n"
"\n"
":param factory: factory function")
  )
  
  
  
    
  .
def_static
("add", static_cast<void(*)(Sendable*, std::string_view)>(
        &wpi::SendableRegistry::Add),
      py::arg("sendable"), py::arg("name"), release_gil()
    , py::keep_alive<1, 2>(), py::doc(
    "Adds an object to the registry.\n"
"\n"
":param sendable: object to add\n"
":param name:     component name")
  )
  
  
  
    
  .
def_static
("add", static_cast<void(*)(Sendable*, std::string_view, int)>(
        &wpi::SendableRegistry::Add),
      py::arg("sendable"), py::arg("moduleType"), py::arg("channel"), release_gil()
    , py::keep_alive<1, 2>(), py::doc(
    "Adds an object to the registry.\n"
"\n"
":param sendable:   object to add\n"
":param moduleType: A string that defines the module name in the label for\n"
"                   the value\n"
":param channel:    The channel number the device is plugged into")
  )
  
  
  
    
  .
def_static
("add", static_cast<void(*)(Sendable*, std::string_view, int, int)>(
        &wpi::SendableRegistry::Add),
      py::arg("sendable"), py::arg("moduleType"), py::arg("moduleNumber"), py::arg("channel"), release_gil()
    , py::keep_alive<1, 2>(), py::doc(
    "Adds an object to the registry.\n"
"\n"
":param sendable:     object to add\n"
":param moduleType:   A string that defines the module name in the label for\n"
"                     the value\n"
":param moduleNumber: The number of the particular module type\n"
":param channel:      The channel number the device is plugged into")
  )
  
  
  
    
  .
def_static
("add", static_cast<void(*)(Sendable*, std::string_view, std::string_view)>(
        &wpi::SendableRegistry::Add),
      py::arg("sendable"), py::arg("subsystem"), py::arg("name"), release_gil()
    , py::keep_alive<1, 2>(), py::doc(
    "Adds an object to the registry.\n"
"\n"
":param sendable:  object to add\n"
":param subsystem: subsystem name\n"
":param name:      component name")
  )
  
  
  
    
  .
def_static
("addLW", static_cast<void(*)(Sendable*, std::string_view)>(
        &wpi::SendableRegistry::AddLW),
      py::arg("sendable"), py::arg("name"), release_gil()
    , py::keep_alive<1, 2>(), py::doc(
    "Adds an object to the registry and LiveWindow.\n"
"\n"
":param sendable: object to add\n"
":param name:     component name")
  )
  
  
  
    
  .
def_static
("addLW", static_cast<void(*)(Sendable*, std::string_view, int)>(
        &wpi::SendableRegistry::AddLW),
      py::arg("sendable"), py::arg("moduleType"), py::arg("channel"), release_gil()
    , py::keep_alive<1, 2>(), py::doc(
    "Adds an object to the registry and LiveWindow.\n"
"\n"
":param sendable:   object to add\n"
":param moduleType: A string that defines the module name in the label for\n"
"                   the value\n"
":param channel:    The channel number the device is plugged into")
  )
  
  
  
    
  .
def_static
("addLW", static_cast<void(*)(Sendable*, std::string_view, int, int)>(
        &wpi::SendableRegistry::AddLW),
      py::arg("sendable"), py::arg("moduleType"), py::arg("moduleNumber"), py::arg("channel"), release_gil()
    , py::keep_alive<1, 2>(), py::doc(
    "Adds an object to the registry and LiveWindow.\n"
"\n"
":param sendable:     object to add\n"
":param moduleType:   A string that defines the module name in the label for\n"
"                     the value\n"
":param moduleNumber: The number of the particular module type\n"
":param channel:      The channel number the device is plugged into")
  )
  
  
  
    
  .
def_static
("addLW", static_cast<void(*)(Sendable*, std::string_view, std::string_view)>(
        &wpi::SendableRegistry::AddLW),
      py::arg("sendable"), py::arg("subsystem"), py::arg("name"), release_gil()
    , py::keep_alive<1, 2>(), py::doc(
    "Adds an object to the registry and LiveWindow.\n"
"\n"
":param sendable:  object to add\n"
":param subsystem: subsystem name\n"
":param name:      component name")
  )
  
  
  
    
  .
def_static
("addChild", static_cast<void(*)(Sendable*, Sendable*)>(
        &wpi::SendableRegistry::AddChild),
      py::arg("parent"), py::arg("child"), release_gil()
    , py::keep_alive<1, 2>()
    , py::keep_alive<2, 3>(), py::doc(
    "Adds a child object to an object.  Adds the child object to the registry\n"
"if it's not already present.\n"
"\n"
":param parent: parent object\n"
":param child:  child object")
  )
  
  
  
    
  .
def_static
("remove", &wpi::SendableRegistry::Remove,
      py::arg("sendable"), release_gil(), py::doc(
    "Removes an object from the registry.\n"
"\n"
":param sendable: object to remove\n"
"\n"
":returns: true if the object was removed; false if it was not present")
  )
  
  
  
    
  .
def_static
("contains", &wpi::SendableRegistry::Contains,
      py::arg("sendable"), release_gil(), py::doc(
    "Determines if an object is in the registry.\n"
"\n"
":param sendable: object to check\n"
"\n"
":returns: True if in registry, false if not.")
  )
  
  
  
    
  .
def_static
("getName", &wpi::SendableRegistry::GetName,
      py::arg("sendable"), release_gil(), py::doc(
    "Gets the name of an object.\n"
"\n"
":param sendable: object\n"
"\n"
":returns: Name (empty if object is not in registry)")
  )
  
  
  
    
  .
def_static
("setName", static_cast<void(*)(Sendable*, std::string_view)>(
        &wpi::SendableRegistry::SetName),
      py::arg("sendable"), py::arg("name"), release_gil(), py::doc(
    "Sets the name of an object.\n"
"\n"
":param sendable: object\n"
":param name:     name")
  )
  
  
  
    
  .
def_static
("setName", static_cast<void(*)(Sendable*, std::string_view, int)>(
        &wpi::SendableRegistry::SetName),
      py::arg("sendable"), py::arg("moduleType"), py::arg("channel"), release_gil(), py::doc(
    "Sets the name of an object with a channel number.\n"
"\n"
":param sendable:   object\n"
":param moduleType: A string that defines the module name in the label for\n"
"                   the value\n"
":param channel:    The channel number the device is plugged into")
  )
  
  
  
    
  .
def_static
("setName", static_cast<void(*)(Sendable*, std::string_view, int, int)>(
        &wpi::SendableRegistry::SetName),
      py::arg("sendable"), py::arg("moduleType"), py::arg("moduleNumber"), py::arg("channel"), release_gil(), py::doc(
    "Sets the name of an object with a module and channel number.\n"
"\n"
":param sendable:     object\n"
":param moduleType:   A string that defines the module name in the label for\n"
"                     the value\n"
":param moduleNumber: The number of the particular module type\n"
":param channel:      The channel number the device is plugged into")
  )
  
  
  
    
  .
def_static
("setName", static_cast<void(*)(Sendable*, std::string_view, std::string_view)>(
        &wpi::SendableRegistry::SetName),
      py::arg("sendable"), py::arg("subsystem"), py::arg("name"), release_gil(), py::doc(
    "Sets both the subsystem name and device name of an object.\n"
"\n"
":param sendable:  object\n"
":param subsystem: subsystem name\n"
":param name:      device name")
  )
  
  
  
    
  .
def_static
("getSubsystem", &wpi::SendableRegistry::GetSubsystem,
      py::arg("sendable"), release_gil(), py::doc(
    "Gets the subsystem name of an object.\n"
"\n"
":param sendable: object\n"
"\n"
":returns: Subsystem name (empty if object is not in registry)")
  )
  
  
  
    
  .
def_static
("setSubsystem", &wpi::SendableRegistry::SetSubsystem,
      py::arg("sendable"), py::arg("subsystem"), release_gil(), py::doc(
    "Sets the subsystem name of an object.\n"
"\n"
":param sendable:  object\n"
":param subsystem: subsystem name")
  )
  
  
  
    
  .
def_static
("enableLiveWindow", &wpi::SendableRegistry::EnableLiveWindow,
      py::arg("sendable"), release_gil(), py::doc(
    "Enables LiveWindow for an object.\n"
"\n"
":param sendable: object")
  )
  
  
  
    
  .
def_static
("disableLiveWindow", &wpi::SendableRegistry::DisableLiveWindow,
      py::arg("sendable"), release_gil(), py::doc(
    "Disables LiveWindow for an object.\n"
"\n"
":param sendable: object")
  )
  
  
  
    
  .
def_static
("getUniqueId", &wpi::SendableRegistry::GetUniqueId,
      py::arg("sendable"), release_gil(), py::doc(
    "Get unique id for an object.  Since objects can move, use this instead\n"
"of storing Sendable* directly if ownership is in question.\n"
"\n"
":param sendable: object\n"
"\n"
":returns: unique id")
  )
  
  
  
    
  .
def_static
("getSendable", &wpi::SendableRegistry::GetSendable,
      py::arg("uid"), release_gil(), py::doc(
    "Get sendable object for a given unique id.\n"
"\n"
":param uid: unique id\n"
"\n"
":returns: sendable object (may be null)")
  )
  
  
  
    
  .
def_static
("publish", &wpi::SendableRegistry::Publish,
      py::arg("sendableUid"), py::arg("builder"), release_gil(), py::doc(
    "Publishes an object in the registry.\n"
"\n"
":param sendableUid: sendable unique id\n"
":param builder:     publisher backend")
  )
  
  
  
    
  .
def_static
("update", &wpi::SendableRegistry::Update,
      py::arg("sendableUid"), release_gil(), py::doc(
    "Updates published information from an object.\n"
"\n"
":param sendableUid: sendable unique id")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_SendableRegistry_initializer

static std::unique_ptr<rpybuild_SendableRegistry_initializer> cls;

void begin_init_SendableRegistry(py::module &m) {
  cls = std::make_unique<rpybuild_SendableRegistry_initializer>(m);
}

void finish_init_SendableRegistry() {
  cls->finish();
  cls.reset();
}