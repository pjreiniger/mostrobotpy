
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/GenericHID.h>








#define RPYGEN_ENABLE_frc__GenericHID_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__GenericHID.hpp>







#include <frc/DriverStation.h>

#include <frc/event/BooleanEvent.h>



#include <type_traits>


  using namespace frc;



struct rpybuild_GenericHID_initializer {


  

  












  
  using GenericHID_Trampoline = rpygen::PyTrampoline_frc__GenericHID<typename frc::GenericHID, typename rpygen::PyTrampolineCfg_frc__GenericHID<>>;
    static_assert(std::is_abstract<GenericHID_Trampoline>::value == false, "frc::GenericHID " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::GenericHID, GenericHID_Trampoline> cls_GenericHID;

    
    
  py::enum_<frc::GenericHID::RumbleType> cls_GenericHID_enum1;
    
    
  py::enum_<frc::GenericHID::HIDType> cls_GenericHID_enum2;
    

    
    

  py::module &m;

  
  rpybuild_GenericHID_initializer(py::module &m) :

  

  

  

  
    cls_GenericHID(m, "GenericHID"),

  
    cls_GenericHID_enum1
  (cls_GenericHID, "RumbleType"
  ,
    "Represents a rumble output on the Joystick."),
  
    cls_GenericHID_enum2
  (cls_GenericHID, "HIDType"
  ,
    "USB HID interface type."),
  

  
  
  

    m(m)
  {
    
    

    
    
  
    cls_GenericHID_enum1
  
    .value("kLeftRumble", frc::GenericHID::RumbleType::kLeftRumble,
      "Left rumble motor.")
  
    .value("kRightRumble", frc::GenericHID::RumbleType::kRightRumble,
      "Right rumble motor.")
  
    .value("kBothRumble", frc::GenericHID::RumbleType::kBothRumble,
      "Both left and right rumble motors.")
  ;

  
    cls_GenericHID_enum2
  
    .value("kUnknown", frc::GenericHID::HIDType::kUnknown,
      "Unknown.")
  
    .value("kXInputUnknown", frc::GenericHID::HIDType::kXInputUnknown,
      "XInputUnknown.")
  
    .value("kXInputGamepad", frc::GenericHID::HIDType::kXInputGamepad,
      "XInputGamepad.")
  
    .value("kXInputWheel", frc::GenericHID::HIDType::kXInputWheel,
      "XInputWheel.")
  
    .value("kXInputArcadeStick", frc::GenericHID::HIDType::kXInputArcadeStick,
      "XInputArcadeStick.")
  
    .value("kXInputFlightStick", frc::GenericHID::HIDType::kXInputFlightStick,
      "XInputFlightStick.")
  
    .value("kXInputDancePad", frc::GenericHID::HIDType::kXInputDancePad,
      "XInputDancePad.")
  
    .value("kXInputGuitar", frc::GenericHID::HIDType::kXInputGuitar,
      "XInputGuitar.")
  
    .value("kXInputGuitar2", frc::GenericHID::HIDType::kXInputGuitar2,
      "XInputGuitar2.")
  
    .value("kXInputDrumKit", frc::GenericHID::HIDType::kXInputDrumKit,
      "XInputDrumKit.")
  
    .value("kXInputGuitar3", frc::GenericHID::HIDType::kXInputGuitar3,
      "XInputGuitar3.")
  
    .value("kXInputArcadePad", frc::GenericHID::HIDType::kXInputArcadePad,
      "XInputArcadePad.")
  
    .value("kHIDJoystick", frc::GenericHID::HIDType::kHIDJoystick,
      "HIDJoystick.")
  
    .value("kHIDGamepad", frc::GenericHID::HIDType::kHIDGamepad,
      "HIDGamepad.")
  
    .value("kHIDDriving", frc::GenericHID::HIDType::kHIDDriving,
      "HIDDriving.")
  
    .value("kHIDFlight", frc::GenericHID::HIDType::kHIDFlight,
      "HIDFlight.")
  
    .value("kHID1stPerson", frc::GenericHID::HIDType::kHID1stPerson,
      "HID1stPerson.")
  ;

  

    
    
  }

void finish() {





  {
  
  
  using RumbleType [[maybe_unused]] = typename frc::GenericHID::RumbleType;
  
  using HIDType [[maybe_unused]] = typename frc::GenericHID::HIDType;
  
  


  

  cls_GenericHID.doc() =
    "Handle input from standard HID devices connected to the Driver Station.\n"
"\n"
"This class handles standard input that comes from the Driver Station. Each\n"
"time a value is requested the most recent value is returned. There is a\n"
"single class instance for each device and the mapping of ports to hardware\n"
"buttons depends on the code in the Driver Station.";

  cls_GenericHID
  
    
  .def(py::init<int>(),
      py::arg("port"), release_gil()
  )
  
  
  
    
  .
def
("getRawButton", &frc::GenericHID::GetRawButton,
      py::arg("button"), release_gil(), py::doc(
    "Get the button value (starting at button 1).\n"
"\n"
"The buttons are returned in a single 16 bit value with one bit representing\n"
"the state of each button. The appropriate button is returned as a boolean\n"
"value.\n"
"\n"
"This method returns true if the button is being held down at the time\n"
"that this method is being called.\n"
"\n"
":param button: The button number to be read (starting at 1)\n"
"\n"
":returns: The state of the button.")
  )
  
  
  
    
  .
def
("getRawButtonPressed", &frc::GenericHID::GetRawButtonPressed,
      py::arg("button"), release_gil(), py::doc(
    "Whether the button was pressed since the last check. %Button indexes begin\n"
"at 1.\n"
"\n"
"This method returns true if the button went from not pressed to held down\n"
"since the last time this method was called. This is useful if you only\n"
"want to call a function once when you press the button.\n"
"\n"
":param button: The button index, beginning at 1.\n"
"\n"
":returns: Whether the button was pressed since the last check.")
  )
  
  
  
    
  .
def
("getRawButtonReleased", &frc::GenericHID::GetRawButtonReleased,
      py::arg("button"), release_gil(), py::doc(
    "Whether the button was released since the last check. %Button indexes begin\n"
"at 1.\n"
"\n"
"This method returns true if the button went from held down to not pressed\n"
"since the last time this method was called. This is useful if you only\n"
"want to call a function once when you release the button.\n"
"\n"
":param button: The button index, beginning at 1.\n"
"\n"
":returns: Whether the button was released since the last check.")
  )
  
  
  
    
  .
def
("button", &frc::GenericHID::Button,
      py::arg("button"), py::arg("loop"), release_gil(), py::doc(
    "Constructs an event instance around this button's digital signal.\n"
"\n"
":param button: the button index\n"
":param loop:   the event loop instance to attach the event to.\n"
"\n"
":returns: an event instance representing the button's digital signal attached\n"
"          to the given loop.")
  )
  
  
  
    
  .
def
("getRawAxis", &frc::GenericHID::GetRawAxis,
      py::arg("axis"), release_gil(), py::doc(
    "Get the value of the axis.\n"
"\n"
":param axis: The axis to read, starting at 0.\n"
"\n"
":returns: The value of the axis.")
  )
  
  
  
    
  .
def
("getPOV", &frc::GenericHID::GetPOV,
      py::arg("pov") = 0, release_gil(), py::doc(
    "Get the angle in degrees of a POV on the HID.\n"
"\n"
"The POV angles start at 0 in the up direction, and increase clockwise\n"
"(e.g. right is 90, upper-left is 315).\n"
"\n"
":param pov: The index of the POV to read (starting at 0)\n"
"\n"
":returns: the angle of the POV in degrees, or -1 if the POV is not pressed.")
  )
  
  
  
    
  .
def
("POV", static_cast<BooleanEvent(frc::GenericHID::*)(int, EventLoop*) const>(
        &frc::GenericHID::POV),
      py::arg("angle"), py::arg("loop"), release_gil(), py::doc(
    "Constructs a BooleanEvent instance based around this angle of a POV on the\n"
"HID.\n"
"\n"
"The POV angles start at 0 in the up direction, and increase clockwise\n"
"(eg right is 90, upper-left is 315).\n"
"\n"
":param loop:  the event loop instance to attach the event to.\n"
":param angle: POV angle in degrees, or -1 for the center / not pressed.\n"
"\n"
":returns: a BooleanEvent instance based around this angle of a POV on the\n"
"          HID.")
  )
  
  
  
    
  .
def
("POV", static_cast<BooleanEvent(frc::GenericHID::*)(int, int, EventLoop*) const>(
        &frc::GenericHID::POV),
      py::arg("pov"), py::arg("angle"), py::arg("loop"), release_gil(), py::doc(
    "Constructs a BooleanEvent instance based around this angle of a POV on the\n"
"HID.\n"
"\n"
"The POV angles start at 0 in the up direction, and increase clockwise\n"
"(eg right is 90, upper-left is 315).\n"
"\n"
":param loop:  the event loop instance to attach the event to.\n"
":param pov:   index of the POV to read (starting at 0). Defaults to 0.\n"
":param angle: POV angle in degrees, or -1 for the center / not pressed.\n"
"\n"
":returns: a BooleanEvent instance based around this angle of a POV on the\n"
"          HID.")
  )
  
  
  
    
  .
def
("POVUp", &frc::GenericHID::POVUp,
      py::arg("loop"), release_gil(), py::doc(
    "Constructs a BooleanEvent instance based around the 0 degree angle (up) of\n"
"the default (index 0) POV on the HID.\n"
"\n"
":returns: a BooleanEvent instance based around the 0 degree angle of a POV on\n"
"          the HID.")
  )
  
  
  
    
  .
def
("POVUpRight", &frc::GenericHID::POVUpRight,
      py::arg("loop"), release_gil(), py::doc(
    "Constructs a BooleanEvent instance based around the 45 degree angle (right\n"
"up) of the default (index 0) POV on the HID.\n"
"\n"
":returns: a BooleanEvent instance based around the 45 degree angle of a POV\n"
"          on the HID.")
  )
  
  
  
    
  .
def
("POVRight", &frc::GenericHID::POVRight,
      py::arg("loop"), release_gil(), py::doc(
    "Constructs a BooleanEvent instance based around the 90 degree angle (right)\n"
"of the default (index 0) POV on the HID.\n"
"\n"
":returns: a BooleanEvent instance based around the 90 degree angle of a POV\n"
"          on the HID.")
  )
  
  
  
    
  .
def
("POVDownRight", &frc::GenericHID::POVDownRight,
      py::arg("loop"), release_gil(), py::doc(
    "Constructs a BooleanEvent instance based around the 135 degree angle (right\n"
"down) of the default (index 0) POV on the HID.\n"
"\n"
":returns: a BooleanEvent instance based around the 135 degree angle of a POV\n"
"          on the HID.")
  )
  
  
  
    
  .
def
("POVDown", &frc::GenericHID::POVDown,
      py::arg("loop"), release_gil(), py::doc(
    "Constructs a BooleanEvent instance based around the 180 degree angle (down)\n"
"of the default (index 0) POV on the HID.\n"
"\n"
":returns: a BooleanEvent instance based around the 180 degree angle of a POV\n"
"          on the HID.")
  )
  
  
  
    
  .
def
("POVDownLeft", &frc::GenericHID::POVDownLeft,
      py::arg("loop"), release_gil(), py::doc(
    "Constructs a BooleanEvent instance based around the 225 degree angle (down\n"
"left) of the default (index 0) POV on the HID.\n"
"\n"
":returns: a BooleanEvent instance based around the 225 degree angle of a POV\n"
"          on the HID.")
  )
  
  
  
    
  .
def
("POVLeft", &frc::GenericHID::POVLeft,
      py::arg("loop"), release_gil(), py::doc(
    "Constructs a BooleanEvent instance based around the 270 degree angle (left)\n"
"of the default (index 0) POV on the HID.\n"
"\n"
":returns: a BooleanEvent instance based around the 270 degree angle of a POV\n"
"          on the HID.")
  )
  
  
  
    
  .
def
("POVUpLeft", &frc::GenericHID::POVUpLeft,
      py::arg("loop"), release_gil(), py::doc(
    "Constructs a BooleanEvent instance based around the 315 degree angle (left\n"
"up) of the default (index 0) POV on the HID.\n"
"\n"
":returns: a BooleanEvent instance based around the 315 degree angle of a POV\n"
"          on the HID.")
  )
  
  
  
    
  .
def
("POVCenter", &frc::GenericHID::POVCenter,
      py::arg("loop"), release_gil(), py::doc(
    "Constructs a BooleanEvent instance based around the center (not pressed) of\n"
"the default (index 0) POV on the HID.\n"
"\n"
":returns: a BooleanEvent instance based around the center of a POV on the\n"
"          HID.")
  )
  
  
  
    
  .
def
("axisLessThan", &frc::GenericHID::AxisLessThan,
      py::arg("axis"), py::arg("threshold"), py::arg("loop"), release_gil(), py::doc(
    "Constructs an event instance that is true when the axis value is less than\n"
"threshold\n"
"\n"
":param axis:      The axis to read, starting at 0.\n"
":param threshold: The value below which this trigger should return true.\n"
":param loop:      the event loop instance to attach the event to.\n"
"\n"
":returns: an event instance that is true when the axis value is less than the\n"
"          provided threshold.")
  )
  
  
  
    
  .
def
("axisGreaterThan", &frc::GenericHID::AxisGreaterThan,
      py::arg("axis"), py::arg("threshold"), py::arg("loop"), release_gil(), py::doc(
    "Constructs an event instance that is true when the axis value is greater\n"
"than threshold\n"
"\n"
":param axis:      The axis to read, starting at 0.\n"
":param threshold: The value above which this trigger should return true.\n"
":param loop:      the event loop instance to attach the event to.\n"
"\n"
":returns: an event instance that is true when the axis value is greater than\n"
"          the provided threshold.")
  )
  
  
  
    
  .
def
("getAxisCount", &frc::GenericHID::GetAxisCount, release_gil(), py::doc(
    "Get the number of axes for the HID.\n"
"\n"
":returns: the number of axis for the current HID")
  )
  
  
  
    
  .
def
("getPOVCount", &frc::GenericHID::GetPOVCount, release_gil(), py::doc(
    "Get the number of POVs for the HID.\n"
"\n"
":returns: the number of POVs for the current HID")
  )
  
  
  
    
  .
def
("getButtonCount", &frc::GenericHID::GetButtonCount, release_gil(), py::doc(
    "Get the number of buttons for the HID.\n"
"\n"
":returns: the number of buttons on the current HID")
  )
  
  
  
    
  .
def
("isConnected", &frc::GenericHID::IsConnected, release_gil(), py::doc(
    "Get if the HID is connected.\n"
"\n"
":returns: true if the HID is connected")
  )
  
  
  
    
  .
def
("getType", &frc::GenericHID::GetType, release_gil(), py::doc(
    "Get the type of the HID.\n"
"\n"
":returns: the type of the HID.")
  )
  
  
  
    
  .
def
("getName", &frc::GenericHID::GetName, release_gil(), py::doc(
    "Get the name of the HID.\n"
"\n"
":returns: the name of the HID.")
  )
  
  
  
    
  .
def
("getAxisType", &frc::GenericHID::GetAxisType,
      py::arg("axis"), release_gil(), py::doc(
    "Get the axis type of a joystick axis.\n"
"\n"
":returns: the axis type of a joystick axis.")
  )
  
  
  
    
  .
def
("getPort", &frc::GenericHID::GetPort, release_gil(), py::doc(
    "Get the port number of the HID.\n"
"\n"
":returns: The port number of the HID.")
  )
  
  
  
    
  .
def
("setOutput", &frc::GenericHID::SetOutput,
      py::arg("outputNumber"), py::arg("value"), release_gil(), py::doc(
    "Set a single HID output value for the HID.\n"
"\n"
":param outputNumber: The index of the output to set (1-32)\n"
":param value:        The value to set the output to")
  )
  
  
  
    
  .
def
("setOutputs", &frc::GenericHID::SetOutputs,
      py::arg("value"), release_gil(), py::doc(
    "Set all output values for the HID.\n"
"\n"
":param value: The 32 bit output value (1 bit for each output)")
  )
  
  
  
    
  .
def
("setRumble", &frc::GenericHID::SetRumble,
      py::arg("type"), py::arg("value"), release_gil(), py::doc(
    "Set the rumble output for the HID.\n"
"\n"
"The DS currently supports 2 rumble values, left rumble and right rumble.\n"
"\n"
":param type:  Which rumble value to set\n"
":param value: The normalized value (0 to 1) to set the rumble to")
  )
  
  
  ;

  


  }







  cls_GenericHID
  .def("__repr__", [](py::handle self) {
    py::object type_name = self.get_type().attr("__qualname__");
    int port = self.cast<GenericHID&>().GetPort();
    return py::str("<{} {}>").format(type_name, port);
  });


}

}; // struct rpybuild_GenericHID_initializer

static std::unique_ptr<rpybuild_GenericHID_initializer> cls;

void begin_init_GenericHID(py::module &m) {
  cls = std::make_unique<rpybuild_GenericHID_initializer>(m);
}

void finish_init_GenericHID() {
  cls->finish();
  cls.reset();
}