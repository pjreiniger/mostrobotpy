
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/interfaces/Gyro.h>








#define RPYGEN_ENABLE_frc__Gyro_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__Gyro.hpp>









#include <type_traits>


  using namespace frc;





struct rpybuild_Gyro_initializer {


  

  












  
  using Gyro_Trampoline = rpygen::PyTrampoline_frc__Gyro<typename frc::Gyro, typename rpygen::PyTrampolineCfg_frc__Gyro<>>;
    static_assert(std::is_abstract<Gyro_Trampoline>::value == false, "frc::Gyro " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::Gyro, Gyro_Trampoline> cls_Gyro;

    

    
    

  py::module &m;

  
  rpybuild_Gyro_initializer(py::module &m) :

  

  

  

  
    cls_Gyro(m, "Gyro"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_Gyro.doc() =
    "Interface for yaw rate gyros.\n"
"\n"
":deprecated: This interface is being removed with no replacement.";

  cls_Gyro
  
    
  .def(py::init<>(), release_gil()
  )
  
  
  
    
  .
def
("calibrate", &frc::Gyro::Calibrate, release_gil(), py::doc(
    "Calibrate the gyro. It's important to make sure that the robot is not\n"
"moving while the calibration is in progress, this is typically\n"
"done when the robot is first turned on while it's sitting at rest before\n"
"the match starts.")
  )
  
  
  
    
  .
def
("reset", &frc::Gyro::Reset, release_gil(), py::doc(
    "Reset the gyro. Resets the gyro to a heading of zero. This can be used if\n"
"there is significant drift in the gyro and it needs to be recalibrated\n"
"after it has been running.")
  )
  
  
  
    
  .
def
("getAngle", &frc::Gyro::GetAngle, release_gil(), py::doc(
    "Return the heading of the robot in degrees.\n"
"\n"
"The angle is continuous, that is it will continue from 360 to 361 degrees.\n"
"This allows algorithms that wouldn't want to see a discontinuity in the\n"
"gyro output as it sweeps past from 360 to 0 on the second time around.\n"
"\n"
"The angle is expected to increase as the gyro turns clockwise when looked\n"
"at from the top. It needs to follow the NED axis convention.\n"
"\n"
":returns: the current heading of the robot in degrees. This heading is based\n"
"          on integration of the returned rate from the gyro.")
  )
  
  
  
    
  .
def
("getRate", &frc::Gyro::GetRate, release_gil(), py::doc(
    "Return the rate of rotation of the gyro.\n"
"\n"
"The rate is based on the most recent reading of the gyro analog value.\n"
"\n"
"The rate is expected to be positive as the gyro turns clockwise when looked\n"
"at from the top. It needs to follow the NED axis convention.\n"
"\n"
":returns: the current rate in degrees per second")
  )
  
  
  
    
  .
def
("getRotation2d", &frc::Gyro::GetRotation2d, release_gil(), py::doc(
    "Return the heading of the robot as a Rotation2d.\n"
"\n"
"The angle is continuous, that is it will continue from 360 to 361 degrees.\n"
"This allows algorithms that wouldn't want to see a discontinuity in the\n"
"gyro output as it sweeps past from 360 to 0 on the second time around.\n"
"\n"
"The angle is expected to increase as the gyro turns counterclockwise when\n"
"looked at from the top. It needs to follow the NWU axis convention.\n"
"\n"
":returns: the current heading of the robot as a Rotation2d. This heading is\n"
"          based on integration of the returned rate from the gyro.")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_Gyro_initializer

static std::unique_ptr<rpybuild_Gyro_initializer> cls;

void begin_init_Gyro(py::module &m) {
  cls = std::make_unique<rpybuild_Gyro_initializer>(m);
}

void finish_init_Gyro() {
  cls->finish();
  cls.reset();
}