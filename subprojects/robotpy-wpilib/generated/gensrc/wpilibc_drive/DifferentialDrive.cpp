
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/drive/DifferentialDrive.h>


#include <pybind11/functional.h>







#define RPYGEN_ENABLE_frc__DifferentialDrive_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__DifferentialDrive.hpp>







#include <wpi/sendable/SendableBuilder.h>

#include <frc/motorcontrol/MotorController.h>



#include <type_traits>


  using namespace frc;



struct rpybuild_DifferentialDrive_initializer {


  

  












  
  using DifferentialDrive_Trampoline = rpygen::PyTrampoline_frc__DifferentialDrive<typename frc::DifferentialDrive, typename rpygen::PyTrampolineCfg_frc__DifferentialDrive<>>;
    static_assert(std::is_abstract<DifferentialDrive_Trampoline>::value == false, "frc::DifferentialDrive " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::DifferentialDrive, DifferentialDrive_Trampoline, frc::RobotDriveBase, wpi::Sendable> cls_DifferentialDrive;

    

    
    
    py::class_<typename frc::DifferentialDrive::WheelSpeeds> cls_WheelSpeeds;

    

    
    
    

  py::module &m;

  
  rpybuild_DifferentialDrive_initializer(py::module &m) :

  

  

  

  
    cls_DifferentialDrive(m, "DifferentialDrive"),

  

  
  
    cls_WheelSpeeds(cls_DifferentialDrive, "WheelSpeeds"),

  

  
  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  

    
    
  }

void finish() {





  {
  
  using WheelSpeeds [[maybe_unused]] = typename frc::DifferentialDrive::WheelSpeeds;
  
  
  


  

  cls_DifferentialDrive.doc() =
    "A class for driving differential drive/skid-steer drive platforms such as\n"
"the Kit of Parts drive base, \"tank drive\", or West Coast Drive.\n"
"\n"
"These drive bases typically have drop-center / skid-steer with two or more\n"
"wheels per side (e.g., 6WD or 8WD). This class takes a MotorController per\n"
"side. For four and six motor drivetrains, construct and pass in\n"
":class:`MotorControllerGroup` instances as follows.\n"
"\n"
"Four motor drivetrain::\n"
"\n"
"  import wpilib.drive\n"
"\n"
"  class Robot(wpilib.TimedRobot):\n"
"      def robotInit(self):\n"
"          self.front_left = wpilib.PWMVictorSPX(1)\n"
"          self.rear_left = wpilib.PWMVictorSPX(2)\n"
"          self.left = wpilib.MotorControllerGroup(self.front_left, self.rear_left)\n"
"\n"
"          self.front_right = wpilib.PWMVictorSPX(3)\n"
"          self.rear_right = wpilib.PWMVictorSPX(4)\n"
"          self.right = wpilib.MotorControllerGroup(self.front_right, self.rear_right)\n"
"\n"
"          self.drive = wpilib.drive.DifferentialDrive(self.left, self.right)\n"
"\n"
"Six motor drivetrain::\n"
"\n"
"  import wpilib.drive\n"
"\n"
"  class Robot(wpilib.TimedRobot):\n"
"      def robotInit(self):\n"
"          self.front_left = wpilib.PWMVictorSPX(1)\n"
"          self.mid_left = wpilib.PWMVictorSPX(2)\n"
"          self.rear_left = wpilib.PWMVictorSPX(3)\n"
"          self.left = wpilib.MotorControllerGroup(self.front_left, self.mid_left, self.rear_left)\n"
"\n"
"          self.front_right = wpilib.PWMVictorSPX(4)\n"
"          self.mid_right = wpilib.PWMVictorSPX(5)\n"
"          self.rear_right = wpilib.PWMVictorSPX(6)\n"
"          self.right = wpilib.MotorControllerGroup(self.front_right, self.mid_right, self.rear_right)\n"
"\n"
"          self.drive = wpilib.drive.DifferentialDrive(self.left, self.right)\n"
"\n"
"A differential drive robot has left and right wheels separated by an\n"
"arbitrary width.\n"
"\n"
"Drive base diagram::\n"
"\n"
"  |_______|\n"
"  | |   | |\n"
"    |   |\n"
"  |_|___|_|\n"
"  |       |\n"
"\n"
"Each Drive() function provides different inverse kinematic relations for a\n"
"differential drive robot. Motor outputs for the right side are negated, so\n"
"motor direction inversion by the user is usually unnecessary.\n"
"\n"
"This library uses the NED axes convention (North-East-Down as external\n"
"reference in the world frame):\n"
"http://www.nuclearprojects.com/ins/images/axis_big.png.\n"
"\n"
"The positive X axis points ahead, the positive Y axis points to the right,\n"
"and the positive Z axis points down. Rotations follow the right-hand rule,\n"
"so clockwise rotation around the Z axis is positive.\n"
"\n"
"Inputs smaller then 0.02 will be set to 0, and larger values will be scaled\n"
"so that the full range is still used. This deadband value can be changed\n"
"with SetDeadband().\n"
"\n"
"RobotDrive porting guide:\n"
"\n"
"* :meth:`tankDrive` is equivalent to ``RobotDrive.tankDrive``\n"
"  if a deadband of 0 is used.\n"
"* :meth:`arcadeDrive` is equivalent to ``RobotDrive.arcadeDrive``\n"
"  if a deadband of 0 is used and the the rotation input is inverted,\n"
"  e.g. ``arcadeDrive(y, -rotation, squareInputs=False)``\n"
"* :meth:`curvatureDrive` is similar in concept to\n"
"  ``RobotDrive.drive`` with the addition of a quick turn\n"
"  mode. However, it is not designed to give exactly the same response.\n";

  cls_DifferentialDrive
  
    
  .def(py::init<MotorController&, MotorController&>(),
      py::arg("leftMotor"), py::arg("rightMotor"), release_gil()
    , py::keep_alive<1, 2>()
    , py::keep_alive<1, 3>(), py::doc(
    "Construct a DifferentialDrive.\n"
"\n"
"To pass multiple motors per side, use CAN motor controller followers or\n"
"PWMSpeedController::AddFollower(). If a motor needs to be inverted, do so\n"
"before passing it in.\n"
"\n"
":param leftMotor:  Left motor.\n"
":param rightMotor: Right motor.")
  )
  
  
  
    
  .def(py::init<std::function<void (double)>, std::function<void (double)>>(),
      py::arg("leftMotor").none(false), py::arg("rightMotor").none(false), release_gil(), py::doc(
    "Construct a DifferentialDrive.\n"
"\n"
"To pass multiple motors per side, use CAN motor controller followers or\n"
"PWMSpeedController::AddFollower(). If a motor needs to be inverted, do so\n"
"before passing it in.\n"
"\n"
":param leftMotor:  Left motor setter.\n"
":param rightMotor: Right motor setter.")
  )
  
  
  
    
  .
def
("arcadeDrive", &frc::DifferentialDrive::ArcadeDrive,
      py::arg("xSpeed"), py::arg("zRotation"), py::arg("squareInputs") = true, release_gil(), py::doc(
    "Arcade drive method for differential drive platform.\n"
"\n"
"Note: Some drivers may prefer inverted rotation controls. This can be done\n"
"by negating the value passed for rotation.\n"
"\n"
":param xSpeed:       The speed at which the robot should drive along the X\n"
"                     axis [-1.0..1.0]. Forward is positive.\n"
":param zRotation:    The rotation rate of the robot around the Z axis\n"
"                     [-1.0..1.0]. Counterclockwise is positive.\n"
":param squareInputs: If set, decreases the input sensitivity at low speeds.")
  )
  
  
  
    
  .
def
("curvatureDrive", &frc::DifferentialDrive::CurvatureDrive,
      py::arg("xSpeed"), py::arg("zRotation"), py::arg("allowTurnInPlace"), release_gil(), py::doc(
    "Curvature drive method for differential drive platform.\n"
"\n"
"The rotation argument controls the curvature of the robot's path rather\n"
"than its rate of heading change. This makes the robot more controllable at\n"
"high speeds.\n"
"\n"
":param xSpeed:           The robot's speed along the X axis [-1.0..1.0].\n"
"                         Forward is positive.\n"
":param zRotation:        The normalized curvature [-1.0..1.0].\n"
"                         Counterclockwise is positive.\n"
":param allowTurnInPlace: If set, overrides constant-curvature turning for\n"
"                         turn-in-place maneuvers. zRotation will control\n"
"                         turning rate instead of curvature.")
  )
  
  
  
    
  .
def
("tankDrive", &frc::DifferentialDrive::TankDrive,
      py::arg("leftSpeed"), py::arg("rightSpeed"), py::arg("squareInputs") = true, release_gil(), py::doc(
    "Tank drive method for differential drive platform.\n"
"\n"
":param leftSpeed:    The robot left side's speed along the X axis\n"
"                     [-1.0..1.0]. Forward is positive.\n"
":param rightSpeed:   The robot right side's speed along the X axis\n"
"                     [-1.0..1.0]. Forward is positive.\n"
":param squareInputs: If set, decreases the input sensitivity at low speeds.")
  )
  
  
  
    
  .
def_static
("arcadeDriveIK", &frc::DifferentialDrive::ArcadeDriveIK,
      py::arg("xSpeed"), py::arg("zRotation"), py::arg("squareInputs") = true, release_gil(), py::doc(
    "Arcade drive inverse kinematics for differential drive platform.\n"
"\n"
"Note: Some drivers may prefer inverted rotation controls. This can be done\n"
"by negating the value passed for rotation.\n"
"\n"
":param xSpeed:       The speed at which the robot should drive along the X\n"
"                     axis [-1.0..1.0]. Forward is positive.\n"
":param zRotation:    The rotation rate of the robot around the Z axis\n"
"                     [-1.0..1.0]. Clockwise is positive.\n"
":param squareInputs: If set, decreases the input sensitivity at low speeds.\n"
"\n"
":returns: Wheel speeds [-1.0..1.0].")
  )
  
  
  
    
  .
def_static
("curvatureDriveIK", &frc::DifferentialDrive::CurvatureDriveIK,
      py::arg("xSpeed"), py::arg("zRotation"), py::arg("allowTurnInPlace"), release_gil(), py::doc(
    "Curvature drive inverse kinematics for differential drive platform.\n"
"\n"
"The rotation argument controls the curvature of the robot's path rather\n"
"than its rate of heading change. This makes the robot more controllable at\n"
"high speeds.\n"
"\n"
":param xSpeed:           The robot's speed along the X axis [-1.0..1.0].\n"
"                         Forward is positive.\n"
":param zRotation:        The normalized curvature [-1.0..1.0]. Clockwise is\n"
"                         positive.\n"
":param allowTurnInPlace: If set, overrides constant-curvature turning for\n"
"                         turn-in-place maneuvers. zRotation will control\n"
"                         turning rate instead of curvature.\n"
"\n"
":returns: Wheel speeds [-1.0..1.0].")
  )
  
  
  
    
  .
def_static
("tankDriveIK", &frc::DifferentialDrive::TankDriveIK,
      py::arg("leftSpeed"), py::arg("rightSpeed"), py::arg("squareInputs") = true, release_gil(), py::doc(
    "Tank drive inverse kinematics for differential drive platform.\n"
"\n"
":param leftSpeed:    The robot left side's speed along the X axis\n"
"                     [-1.0..1.0]. Forward is positive.\n"
":param rightSpeed:   The robot right side's speed along the X axis\n"
"                     [-1.0..1.0]. Forward is positive.\n"
":param squareInputs: If set, decreases the input sensitivity at low speeds.\n"
"\n"
":returns: Wheel speeds [-1.0..1.0].")
  )
  
  
  
    
  .
def
("stopMotor", &frc::DifferentialDrive::StopMotor, release_gil()
  )
  
  
  
    
  .
def
("getDescription", &frc::DifferentialDrive::GetDescription, release_gil()
  )
  
  
  
    
  .
def
("initSendable", &frc::DifferentialDrive::InitSendable,
      py::arg("builder"), release_gil()
  )
  
  
  ;

  


  

  cls_WheelSpeeds.doc() =
    "Wheel speeds for a differential drive.\n"
"\n"
"Uses normalized voltage [-1.0..1.0].";

  cls_WheelSpeeds
  
    .def(py::init<>(), release_gil())
  
    .def_readwrite("left", &frc::DifferentialDrive::WheelSpeeds::left, py::doc(
    "Left wheel speed."))
  
    .def_readwrite("right", &frc::DifferentialDrive::WheelSpeeds::right, py::doc(
    "Right wheel speed."))
  ;

  


  
  }






}

}; // struct rpybuild_DifferentialDrive_initializer

static std::unique_ptr<rpybuild_DifferentialDrive_initializer> cls;

void begin_init_DifferentialDrive(py::module &m) {
  cls = std::make_unique<rpybuild_DifferentialDrive_initializer>(m);
}

void finish_init_DifferentialDrive() {
  cls->finish();
  cls.reset();
}