
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/simulation/PneumaticsBaseSim.h>


#include <pybind11/functional.h>







#define RPYGEN_ENABLE_frc__sim__PneumaticsBaseSim_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__sim__PneumaticsBaseSim.hpp>









#include <type_traits>


  using namespace frc::sim;





struct rpybuild_PneumaticsBaseSim_initializer {


  
    using PneumaticsBase = frc::PneumaticsBase;
  

  












  
  using PneumaticsBaseSim_Trampoline = rpygen::PyTrampoline_frc__sim__PneumaticsBaseSim<typename frc::sim::PneumaticsBaseSim, typename rpygen::PyTrampolineCfg_frc__sim__PneumaticsBaseSim<>>;
    static_assert(std::is_abstract<PneumaticsBaseSim_Trampoline>::value == false, "frc::sim::PneumaticsBaseSim " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::sim::PneumaticsBaseSim, PneumaticsBaseSim_Trampoline> cls_PneumaticsBaseSim;

    

    
    

  py::module &m;

  
  rpybuild_PneumaticsBaseSim_initializer(py::module &m) :

  

  

  

  
    cls_PneumaticsBaseSim(m, "PneumaticsBaseSim"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  

  cls_PneumaticsBaseSim
  
    
  .
def_static
("getForType", &frc::sim::PneumaticsBaseSim::GetForType,
      py::arg("module"), py::arg("type"), release_gil()
  )
  
  
  
    
  .
def
("getInitialized", &frc::sim::PneumaticsBaseSim::GetInitialized, release_gil(), py::doc(
    "Check whether the PCM/PH has been initialized.\n"
"\n"
":returns: true if initialized")
  )
  
  
  
    
  .
def
("setInitialized", &frc::sim::PneumaticsBaseSim::SetInitialized,
      py::arg("initialized"), release_gil(), py::doc(
    "Define whether the PCM/PH has been initialized.\n"
"\n"
":param initialized: true for initialized")
  )
  
  
  
    
  .
def
("registerInitializedCallback", &frc::sim::PneumaticsBaseSim::RegisterInitializedCallback,
      py::arg("callback"), py::arg("initialNotify"), release_gil(), py::doc(
    "Register a callback to be run when the PCM/PH is initialized.\n"
"\n"
":param callback:      the callback\n"
":param initialNotify: whether to run the callback with the initial state\n"
"\n"
":returns: the :class:`.CallbackStore` object associated with this callback.\n"
"          Save a reference to this object; it being deconstructed cancels the\n"
"          callback.")
  )
  
  
  
    
  .
def
("getCompressorOn", &frc::sim::PneumaticsBaseSim::GetCompressorOn, release_gil(), py::doc(
    "Check if the compressor is on.\n"
"\n"
":returns: true if the compressor is active")
  )
  
  
  
    
  .
def
("setCompressorOn", &frc::sim::PneumaticsBaseSim::SetCompressorOn,
      py::arg("compressorOn"), release_gil(), py::doc(
    "Set whether the compressor is active.\n"
"\n"
":param compressorOn: the new value")
  )
  
  
  
    
  .
def
("registerCompressorOnCallback", &frc::sim::PneumaticsBaseSim::RegisterCompressorOnCallback,
      py::arg("callback"), py::arg("initialNotify"), release_gil(), py::doc(
    "Register a callback to be run when the compressor activates.\n"
"\n"
":param callback:      the callback\n"
":param initialNotify: whether to run the callback with the initial state\n"
"\n"
":returns: the :class:`.CallbackStore` object associated with this callback.\n"
"          Save a reference to this object; it being deconstructed cancels the\n"
"          callback.")
  )
  
  
  
    
  .
def
("getSolenoidOutput", &frc::sim::PneumaticsBaseSim::GetSolenoidOutput,
      py::arg("channel"), release_gil(), py::doc(
    "Check the solenoid output on a specific channel.\n"
"\n"
":param channel: the channel to check\n"
"\n"
":returns: the solenoid output")
  )
  
  
  
    
  .
def
("setSolenoidOutput", &frc::sim::PneumaticsBaseSim::SetSolenoidOutput,
      py::arg("channel"), py::arg("solenoidOutput"), release_gil(), py::doc(
    "Change the solenoid output on a specific channel.\n"
"\n"
":param channel:        the channel to check\n"
":param solenoidOutput: the new solenoid output")
  )
  
  
  
    
  .
def
("registerSolenoidOutputCallback", &frc::sim::PneumaticsBaseSim::RegisterSolenoidOutputCallback,
      py::arg("channel"), py::arg("callback"), py::arg("initialNotify"), release_gil(), py::doc(
    "Register a callback to be run when the solenoid output on a channel\n"
"changes.\n"
"\n"
":param channel:       the channel to monitor\n"
":param callback:      the callback\n"
":param initialNotify: should the callback be run with the initial value\n"
"\n"
":returns: the :class:`.CallbackStore` object associated with this callback.\n"
"          Save a reference to this object; it being deconstructed cancels the\n"
"          callback.")
  )
  
  
  
    
  .
def
("getPressureSwitch", &frc::sim::PneumaticsBaseSim::GetPressureSwitch, release_gil(), py::doc(
    "Check the value of the pressure switch.\n"
"\n"
":returns: the pressure switch value")
  )
  
  
  
    
  .
def
("setPressureSwitch", &frc::sim::PneumaticsBaseSim::SetPressureSwitch,
      py::arg("pressureSwitch"), release_gil(), py::doc(
    "Set the value of the pressure switch.\n"
"\n"
":param pressureSwitch: the new value")
  )
  
  
  
    
  .
def
("registerPressureSwitchCallback", &frc::sim::PneumaticsBaseSim::RegisterPressureSwitchCallback,
      py::arg("callback"), py::arg("initialNotify"), release_gil(), py::doc(
    "Register a callback to be run whenever the pressure switch value changes.\n"
"\n"
":param callback:      the callback\n"
":param initialNotify: whether the callback should be called with the initial\n"
"                      value\n"
"\n"
":returns: the :class:`.CallbackStore` object associated with this callback.\n"
"          Save a reference to this object; it being deconstructed cancels the\n"
"          callback.")
  )
  
  
  
    
  .
def
("getCompressorCurrent", &frc::sim::PneumaticsBaseSim::GetCompressorCurrent, release_gil(), py::doc(
    "Read the compressor current.\n"
"\n"
":returns: the current of the compressor connected to this module")
  )
  
  
  
    
  .
def
("setCompressorCurrent", &frc::sim::PneumaticsBaseSim::SetCompressorCurrent,
      py::arg("compressorCurrent"), release_gil(), py::doc(
    "Set the compressor current.\n"
"\n"
":param compressorCurrent: the new compressor current")
  )
  
  
  
    
  .
def
("registerCompressorCurrentCallback", &frc::sim::PneumaticsBaseSim::RegisterCompressorCurrentCallback,
      py::arg("callback"), py::arg("initialNotify"), release_gil(), py::doc(
    "Register a callback to be run whenever the compressor current changes.\n"
"\n"
":param callback:      the callback\n"
":param initialNotify: whether to call the callback with the initial state\n"
"\n"
":returns: the :class:`.CallbackStore` object associated with this callback.\n"
"          Save a reference to this object; it being deconstructed cancels the\n"
"          callback.")
  )
  
  
  
    
  .
def
("getAllSolenoidOutputs", &frc::sim::PneumaticsBaseSim::GetAllSolenoidOutputs, release_gil(), py::doc(
    "Get the current value of all solenoid outputs.\n"
"\n"
":returns: the solenoid outputs (1 bit per output)")
  )
  
  
  
    
  .
def
("setAllSolenoidOutputs", &frc::sim::PneumaticsBaseSim::SetAllSolenoidOutputs,
      py::arg("outputs"), release_gil(), py::doc(
    "Change all of the solenoid outputs.\n"
"\n"
":param outputs: the new solenoid outputs (1 bit per output)")
  )
  
  
  
    
  .
def
("resetData", &frc::sim::PneumaticsBaseSim::ResetData, release_gil(), py::doc(
    "Reset all simulation data for this object.")
  )
  
  
  
    
  .def(py::init_alias<const int>(),
      py::arg("index"), release_gil(), py::doc(
    "Constructs a PneumaticsBaseSim with the given index.\n"
"\n"
":param index: The index.")
  )
  
  
  
    
  .def(py::init_alias<const PneumaticsBase&>(),
      py::arg("module"), release_gil()
    , py::keep_alive<1, 2>(), py::doc(
    "Constructs a PneumaticsBaseSim for the given module.\n"
"\n"
":param module: The module.")
  )
  
  
  
    .def_readonly("_m_index", &rpygen::PyTrampoline_frc__sim__PneumaticsBaseSim<typename frc::sim::PneumaticsBaseSim, typename rpygen::PyTrampolineCfg_frc__sim__PneumaticsBaseSim<>>::m_index, py::doc(
    "PneumaticsBase index."));

  


  }






}

}; // struct rpybuild_PneumaticsBaseSim_initializer

static std::unique_ptr<rpybuild_PneumaticsBaseSim_initializer> cls;

void begin_init_PneumaticsBaseSim(py::module &m) {
  cls = std::make_unique<rpybuild_PneumaticsBaseSim_initializer>(m);
}

void finish_init_PneumaticsBaseSim() {
  cls->finish();
  cls.reset();
}