
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/simulation/ElevatorSim.h>


#include <pybind11/eigen.h>

#include <pybind11/stl.h>

#include <units_compound_type_caster.h>

#include <units_current_type_caster.h>

#include <units_length_type_caster.h>

#include <units_mass_type_caster.h>

#include <units_time_type_caster.h>

#include <units_velocity_type_caster.h>

#include <units_voltage_type_caster.h>







#define RPYGEN_ENABLE_frc__sim__ElevatorSim_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__sim__ElevatorSim.hpp>









#include <type_traits>


  using namespace frc::sim;



struct rpybuild_ElevatorSim_initializer {


  
    using DCMotor = frc::DCMotor;
  
    template <int S, int I, int O> using LinearSystem = frc::LinearSystem<S, I, O>;
  
    template <int I> using Vectord = frc::Vectord<I>;
  

  












  
  using ElevatorSim_Trampoline = rpygen::PyTrampoline_frc__sim__ElevatorSim<typename frc::sim::ElevatorSim, typename rpygen::PyTrampolineCfg_frc__sim__ElevatorSim<>>;
    static_assert(std::is_abstract<ElevatorSim_Trampoline>::value == false, "frc::sim::ElevatorSim " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::sim::ElevatorSim, ElevatorSim_Trampoline, frc::sim::LinearSystemSim<2, 1, 2>> cls_ElevatorSim;

    

    
    

  py::module &m;

  
  rpybuild_ElevatorSim_initializer(py::module &m) :

  

  

  

  
    cls_ElevatorSim(m, "ElevatorSim"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_ElevatorSim.doc() =
    "Represents a simulated elevator mechanism.";

  cls_ElevatorSim
  
    
  .def(py::init<const LinearSystem<2, 1, 2>&, const DCMotor&, units::meter_t, units::meter_t, bool, units::meter_t, const std::array<double, 2>&>(),
      py::arg("plant"), py::arg("gearbox"), py::arg("minHeight"), py::arg("maxHeight"), py::arg("simulateGravity"), py::arg("startingHeight"), py::arg("measurementStdDevs") = std::array<double, 2>{0.0, 0.0}, release_gil()
    , py::keep_alive<1, 2>()
    , py::keep_alive<1, 3>()
    , py::keep_alive<1, 8>(), py::doc(
    "Constructs a simulated elevator mechanism.\n"
"\n"
":param plant:              The linear system that represents the elevator.\n"
"                           This system can be created with\n"
"                           LinearSystemId::ElevatorSystem().\n"
":param gearbox:            The type of and number of motors in your\n"
"                           elevator gearbox.\n"
":param minHeight:          The minimum allowed height of the elevator.\n"
":param maxHeight:          The maximum allowed height of the elevator.\n"
":param simulateGravity:    Whether gravity should be simulated or not.\n"
":param startingHeight:     The starting height of the elevator.\n"
":param measurementStdDevs: The standard deviation of the measurements.")
  )
  
  
  
    
  .def(py::init<const DCMotor&, double, units::kilogram_t, units::meter_t, units::meter_t, units::meter_t, bool, units::meter_t, const std::array<double, 2>&>(),
      py::arg("gearbox"), py::arg("gearing"), py::arg("carriageMass"), py::arg("drumRadius"), py::arg("minHeight"), py::arg("maxHeight"), py::arg("simulateGravity"), py::arg("startingHeight"), py::arg("measurementStdDevs") = std::array<double, 2>{0.0}, release_gil()
    , py::keep_alive<1, 2>()
    , py::keep_alive<1, 10>(), py::doc(
    "Constructs a simulated elevator mechanism.\n"
"\n"
":param gearbox:            The type of and number of motors in your\n"
"                           elevator gearbox.\n"
":param gearing:            The gearing of the elevator (numbers greater\n"
"                           than 1 represent reductions).\n"
":param carriageMass:       The mass of the elevator carriage.\n"
":param drumRadius:         The radius of the drum that your cable is\n"
"                           wrapped around.\n"
":param minHeight:          The minimum allowed height of the elevator.\n"
":param maxHeight:          The maximum allowed height of the elevator.\n"
":param simulateGravity:    Whether gravity should be simulated or not.\n"
":param startingHeight:     The starting height of the elevator.\n"
":param measurementStdDevs: The standard deviation of the measurements.")
  )
  
  
  
    
  .
def
("setState", static_cast<void(frc::sim::ElevatorSim::*)(units::meter_t, units::meters_per_second_t)>(
        &frc::sim::ElevatorSim::SetState),
      py::arg("position"), py::arg("velocity"), release_gil(), py::doc(
    "Sets the elevator's state. The new position will be limited between the\n"
"minimum and maximum allowed heights.\n"
"\n"
":param position: The new position\n"
":param velocity: The new velocity")
  )
  
  
  
    
  .
def
("wouldHitLowerLimit", &frc::sim::ElevatorSim::WouldHitLowerLimit,
      py::arg("elevatorHeight"), release_gil(), py::doc(
    "Returns whether the elevator would hit the lower limit.\n"
"\n"
":param elevatorHeight: The elevator height.\n"
"\n"
":returns: Whether the elevator would hit the lower limit.")
  )
  
  
  
    
  .
def
("wouldHitUpperLimit", &frc::sim::ElevatorSim::WouldHitUpperLimit,
      py::arg("elevatorHeight"), release_gil(), py::doc(
    "Returns whether the elevator would hit the upper limit.\n"
"\n"
":param elevatorHeight: The elevator height.\n"
"\n"
":returns: Whether the elevator would hit the upper limit.")
  )
  
  
  
    
  .
def
("hasHitLowerLimit", &frc::sim::ElevatorSim::HasHitLowerLimit, release_gil(), py::doc(
    "Returns whether the elevator has hit the lower limit.\n"
"\n"
":returns: Whether the elevator has hit the lower limit.")
  )
  
  
  
    
  .
def
("hasHitUpperLimit", &frc::sim::ElevatorSim::HasHitUpperLimit, release_gil(), py::doc(
    "Returns whether the elevator has hit the upper limit.\n"
"\n"
":returns: Whether the elevator has hit the upper limit.")
  )
  
  
  
    
  .
def
("getPosition", &frc::sim::ElevatorSim::GetPosition, release_gil(), py::doc(
    "Returns the position of the elevator.\n"
"\n"
":returns: The position of the elevator.")
  )
  
  
  
    
  .
def
("getVelocity", &frc::sim::ElevatorSim::GetVelocity, release_gil(), py::doc(
    "Returns the velocity of the elevator.\n"
"\n"
":returns: The velocity of the elevator.")
  )
  
  
  
    
  .
def
("getCurrentDraw", &frc::sim::ElevatorSim::GetCurrentDraw, release_gil(), py::doc(
    "Returns the elevator current draw.\n"
"\n"
":returns: The elevator current draw.")
  )
  
  
  
    
  .
def
("setInputVoltage", &frc::sim::ElevatorSim::SetInputVoltage,
      py::arg("voltage"), release_gil(), py::doc(
    "Sets the input voltage for the elevator.\n"
"\n"
":param voltage: The input voltage.")
  )
  
  
  
    
  .
def
("_updateX", static_cast<Vectord<2>(frc::sim::ElevatorSim::*)(const Vectord<2>&, const Vectord<1>&, units::second_t)>(&ElevatorSim_Trampoline::UpdateX),
      py::arg("currentXhat"), py::arg("u"), py::arg("dt"), release_gil(), py::doc(
    "Updates the state estimate of the elevator.\n"
"\n"
":param currentXhat: The current state estimate.\n"
":param u:           The system inputs (voltage).\n"
":param dt:          The time difference between controller updates.")
  )
  
  
  ;

  


  }







  cls_ElevatorSim
  .def("getPositionFeet", [](ElevatorSim * self) -> units::foot_t {
    return self->GetPosition();
  })
  .def("getPositionInches", [](ElevatorSim * self) -> units::inch_t {
    return self->GetPosition();
  })
  .def("getVelocityFps", [](ElevatorSim * self) -> units::feet_per_second_t {
    return self->GetVelocity();
  })
;

}

}; // struct rpybuild_ElevatorSim_initializer

static std::unique_ptr<rpybuild_ElevatorSim_initializer> cls;

void begin_init_ElevatorSim(py::module &m) {
  cls = std::make_unique<rpybuild_ElevatorSim_initializer>(m);
}

void finish_init_ElevatorSim() {
  cls->finish();
  cls.reset();
}