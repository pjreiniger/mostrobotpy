
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/simulation/SingleJointedArmSim.h>


#include <pybind11/eigen.h>

#include <pybind11/stl.h>

#include <units_angle_type_caster.h>

#include <units_angular_velocity_type_caster.h>

#include <units_current_type_caster.h>

#include <units_length_type_caster.h>

#include <units_mass_type_caster.h>

#include <units_moment_of_inertia_type_caster.h>

#include <units_time_type_caster.h>

#include <units_voltage_type_caster.h>







#define RPYGEN_ENABLE_frc__sim__SingleJointedArmSim_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__sim__SingleJointedArmSim.hpp>









#include <type_traits>


  using namespace frc::sim;



struct rpybuild_SingleJointedArmSim_initializer {


  
    using DCMotor = frc::DCMotor;
  
    template <int S, int I, int O> using LinearSystem = frc::LinearSystem<S, I, O>;
  
    template <int I> using Vectord = frc::Vectord<I>;
  

  












  
  using SingleJointedArmSim_Trampoline = rpygen::PyTrampoline_frc__sim__SingleJointedArmSim<typename frc::sim::SingleJointedArmSim, typename rpygen::PyTrampolineCfg_frc__sim__SingleJointedArmSim<>>;
    static_assert(std::is_abstract<SingleJointedArmSim_Trampoline>::value == false, "frc::sim::SingleJointedArmSim " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::sim::SingleJointedArmSim, SingleJointedArmSim_Trampoline, frc::sim::LinearSystemSim<2, 1, 2>> cls_SingleJointedArmSim;

    

    
    

  py::module &m;

  
  rpybuild_SingleJointedArmSim_initializer(py::module &m) :

  

  

  

  
    cls_SingleJointedArmSim(m, "SingleJointedArmSim"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_SingleJointedArmSim.doc() =
    "Represents a simulated arm mechanism.";

  cls_SingleJointedArmSim
  
    
  .def(py::init<const LinearSystem<2, 1, 2>&, const DCMotor&, double, units::meter_t, units::radian_t, units::radian_t, bool, units::radian_t, const std::array<double, 2>&>(),
      py::arg("system"), py::arg("gearbox"), py::arg("gearing"), py::arg("armLength"), py::arg("minAngle"), py::arg("maxAngle"), py::arg("simulateGravity"), py::arg("startingAngle"), py::arg("measurementStdDevs") = std::array<double, 2>{0.0, 0.0}, release_gil()
    , py::keep_alive<1, 2>()
    , py::keep_alive<1, 3>()
    , py::keep_alive<1, 10>(), py::doc(
    "Creates a simulated arm mechanism.\n"
"\n"
":param system:             The system representing this arm. This system can\n"
"                           be created with\n"
"                           LinearSystemId::SingleJointedArmSystem().\n"
":param gearbox:            The type and number of motors on the arm gearbox.\n"
":param gearing:            The gear ratio of the arm (numbers greater than 1\n"
"                           represent reductions).\n"
":param armLength:          The length of the arm.\n"
":param minAngle:           The minimum angle that the arm is capable of.\n"
":param maxAngle:           The maximum angle that the arm is capable of.\n"
":param simulateGravity:    Whether gravity should be simulated or not.\n"
":param startingAngle:      The initial position of the arm.\n"
":param measurementStdDevs: The standard deviations of the measurements.")
  )
  
  
  
    
  .def(py::init<const DCMotor&, double, units::kilogram_square_meter_t, units::meter_t, units::radian_t, units::radian_t, bool, units::radian_t, const std::array<double, 2>&>(),
      py::arg("gearbox"), py::arg("gearing"), py::arg("moi"), py::arg("armLength"), py::arg("minAngle"), py::arg("maxAngle"), py::arg("simulateGravity"), py::arg("startingAngle"), py::arg("measurementStdDevs") = std::array<double, 2>{0.0, 0.0}, release_gil()
    , py::keep_alive<1, 2>()
    , py::keep_alive<1, 10>(), py::doc(
    "Creates a simulated arm mechanism.\n"
"\n"
":param gearbox:            The type and number of motors on the arm gearbox.\n"
":param gearing:            The gear ratio of the arm (numbers greater than 1\n"
"                           represent reductions).\n"
":param moi:                The moment of inertia of the arm. This can be\n"
"                           calculated from CAD software.\n"
":param armLength:          The length of the arm.\n"
":param minAngle:           The minimum angle that the arm is capable of.\n"
":param maxAngle:           The maximum angle that the arm is capable of.\n"
":param simulateGravity:    Whether gravity should be simulated or not.\n"
":param startingAngle:      The initial position of the arm.\n"
":param measurementStdDevs: The standard deviation of the measurement noise.")
  )
  
  
  
    
  .
def
("setState", static_cast<void(frc::sim::SingleJointedArmSim::*)(units::radian_t, units::radians_per_second_t)>(
        &frc::sim::SingleJointedArmSim::SetState),
      py::arg("angle"), py::arg("velocity"), release_gil(), py::doc(
    "Sets the arm's state. The new angle will be limited between the minimum and\n"
"maximum allowed limits.\n"
"\n"
":param angle:    The new angle.\n"
":param velocity: The new angular velocity.")
  )
  
  
  
    
  .
def
("wouldHitLowerLimit", &frc::sim::SingleJointedArmSim::WouldHitLowerLimit,
      py::arg("armAngle"), release_gil(), py::doc(
    "Returns whether the arm would hit the lower limit.\n"
"\n"
":param armAngle: The arm height.\n"
"\n"
":returns: Whether the arm would hit the lower limit.")
  )
  
  
  
    
  .
def
("wouldHitUpperLimit", &frc::sim::SingleJointedArmSim::WouldHitUpperLimit,
      py::arg("armAngle"), release_gil(), py::doc(
    "Returns whether the arm would hit the upper limit.\n"
"\n"
":param armAngle: The arm height.\n"
"\n"
":returns: Whether the arm would hit the upper limit.")
  )
  
  
  
    
  .
def
("hasHitLowerLimit", &frc::sim::SingleJointedArmSim::HasHitLowerLimit, release_gil(), py::doc(
    "Returns whether the arm has hit the lower limit.\n"
"\n"
":returns: Whether the arm has hit the lower limit.")
  )
  
  
  
    
  .
def
("hasHitUpperLimit", &frc::sim::SingleJointedArmSim::HasHitUpperLimit, release_gil(), py::doc(
    "Returns whether the arm has hit the upper limit.\n"
"\n"
":returns: Whether the arm has hit the upper limit.")
  )
  
  
  
    
  .
def
("getAngle", &frc::sim::SingleJointedArmSim::GetAngle, release_gil(), py::doc(
    "Returns the current arm angle.\n"
"\n"
":returns: The current arm angle.")
  )
  
  
  
    
  .
def
("getVelocity", &frc::sim::SingleJointedArmSim::GetVelocity, release_gil(), py::doc(
    "Returns the current arm velocity.\n"
"\n"
":returns: The current arm velocity.")
  )
  
  
  
    
  .
def
("getCurrentDraw", &frc::sim::SingleJointedArmSim::GetCurrentDraw, release_gil(), py::doc(
    "Returns the arm current draw.\n"
"\n"
":returns: The arm current draw.")
  )
  
  
  
    
  .
def
("setInputVoltage", &frc::sim::SingleJointedArmSim::SetInputVoltage,
      py::arg("voltage"), release_gil(), py::doc(
    "Sets the input voltage for the arm.\n"
"\n"
":param voltage: The input voltage.")
  )
  
  
  
    
  .
def_static
("estimateMOI", &frc::sim::SingleJointedArmSim::EstimateMOI,
      py::arg("length"), py::arg("mass"), release_gil(), py::doc(
    "Calculates a rough estimate of the moment of inertia of an arm given its\n"
"length and mass.\n"
"\n"
":param length: The length of the arm.\n"
":param mass:   The mass of the arm.\n"
"\n"
":returns: The calculated moment of inertia.")
  )
  
  
  
    
  .
def
("_updateX", static_cast<Vectord<2>(frc::sim::SingleJointedArmSim::*)(const Vectord<2>&, const Vectord<1>&, units::second_t)>(&SingleJointedArmSim_Trampoline::UpdateX),
      py::arg("currentXhat"), py::arg("u"), py::arg("dt"), release_gil(), py::doc(
    "Updates the state estimate of the arm.\n"
"\n"
":param currentXhat: The current state estimate.\n"
":param u:           The system inputs (voltage).\n"
":param dt:          The time difference between controller updates.")
  )
  
  
  ;

  


  }







  cls_SingleJointedArmSim
  .def("getAngleDegrees", [](SingleJointedArmSim * self) -> units::degree_t {
    return self->GetAngle();
  })
  .def("getVelocityDps", [](SingleJointedArmSim * self) -> units::degrees_per_second_t {
    return self->GetVelocity();
  })
;

}

}; // struct rpybuild_SingleJointedArmSim_initializer

static std::unique_ptr<rpybuild_SingleJointedArmSim_initializer> cls;

void begin_init_SingleJointedArmSim(py::module &m) {
  cls = std::make_unique<rpybuild_SingleJointedArmSim_initializer>(m);
}

void finish_init_SingleJointedArmSim() {
  cls->finish();
  cls.reset();
}