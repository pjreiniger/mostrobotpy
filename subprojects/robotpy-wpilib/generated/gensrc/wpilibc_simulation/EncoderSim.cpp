
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/simulation/EncoderSim.h>


#include <pybind11/functional.h>













#include <frc/Encoder.h>



#include <type_traits>


  using namespace frc;

  using namespace frc::sim;





struct rpybuild_EncoderSim_initializer {


  

  












  py::class_<typename frc::sim::EncoderSim> cls_EncoderSim;

    

    
    

  py::module &m;

  
  rpybuild_EncoderSim_initializer(py::module &m) :

  

  

  

  
    cls_EncoderSim(m, "EncoderSim"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_EncoderSim.doc() =
    "Class to control a simulated encoder.";

  cls_EncoderSim
  
    
  .def(py::init<const Encoder&>(),
      py::arg("encoder"), release_gil()
    , py::keep_alive<1, 2>(), py::doc(
    "Constructs from an Encoder object.\n"
"\n"
":param encoder: Encoder to simulate")
  )
  
  
  
    
  .
def_static
("createForChannel", &frc::sim::EncoderSim::CreateForChannel,
      py::arg("channel"), release_gil(), py::doc(
    "Creates an EncoderSim for a digital input channel.  Encoders take two\n"
"channels, so either one may be specified.\n"
"\n"
":param channel: digital input channel\n"
"\n"
":returns: Simulated object\n"
"          @throws NoSuchElementException if no Encoder is configured for that channel")
  )
  
  
  
    
  .
def_static
("createForIndex", &frc::sim::EncoderSim::CreateForIndex,
      py::arg("index"), release_gil(), py::doc(
    "Creates an EncoderSim for a simulated index.\n"
"The index is incremented for each simulated Encoder.\n"
"\n"
":param index: simulator index\n"
"\n"
":returns: Simulated object")
  )
  
  
  
    
  .
def
("registerInitializedCallback", &frc::sim::EncoderSim::RegisterInitializedCallback,
      py::arg("callback"), py::arg("initialNotify"), release_gil(), py::doc(
    "Register a callback on the Initialized property of the encoder.\n"
"\n"
":param callback:      the callback that will be called whenever the Initialized\n"
"                      property is changed\n"
":param initialNotify: if true, the callback will be run on the initial value\n"
"\n"
":returns: the CallbackStore object associated with this callback")
  )
  
  
  
    
  .
def
("getInitialized", &frc::sim::EncoderSim::GetInitialized, release_gil(), py::doc(
    "Read the Initialized value of the encoder.\n"
"\n"
":returns: true if initialized")
  )
  
  
  
    
  .
def
("setInitialized", &frc::sim::EncoderSim::SetInitialized,
      py::arg("initialized"), release_gil(), py::doc(
    "Change the Initialized value of the encoder.\n"
"\n"
":param initialized: the new value")
  )
  
  
  
    
  .
def
("registerCountCallback", &frc::sim::EncoderSim::RegisterCountCallback,
      py::arg("callback"), py::arg("initialNotify"), release_gil(), py::doc(
    "Register a callback on the count property of the encoder.\n"
"\n"
":param callback:      the callback that will be called whenever the count\n"
"                      property is changed\n"
":param initialNotify: if true, the callback will be run on the initial value\n"
"\n"
":returns: the CallbackStore object associated with this callback")
  )
  
  
  
    
  .
def
("getCount", &frc::sim::EncoderSim::GetCount, release_gil(), py::doc(
    "Read the count of the encoder.\n"
"\n"
":returns: the count")
  )
  
  
  
    
  .
def
("setCount", &frc::sim::EncoderSim::SetCount,
      py::arg("count"), release_gil(), py::doc(
    "Change the count of the encoder.\n"
"\n"
":param count: the new count")
  )
  
  
  
    
  .
def
("registerPeriodCallback", &frc::sim::EncoderSim::RegisterPeriodCallback,
      py::arg("callback"), py::arg("initialNotify"), release_gil(), py::doc(
    "Register a callback on the period of the encoder.\n"
"\n"
":param callback:      the callback that will be called whenever the period is\n"
"                      changed\n"
":param initialNotify: if true, the callback will be run on the initial value\n"
"\n"
":returns: the CallbackStore object associated with this callback")
  )
  
  
  
    
  .
def
("getPeriod", &frc::sim::EncoderSim::GetPeriod, release_gil(), py::doc(
    "Read the period of the encoder.\n"
"\n"
":returns: the encoder period")
  )
  
  
  
    
  .
def
("setPeriod", &frc::sim::EncoderSim::SetPeriod,
      py::arg("period"), release_gil(), py::doc(
    "Change the encoder period.\n"
"\n"
":param period: the new period")
  )
  
  
  
    
  .
def
("registerResetCallback", &frc::sim::EncoderSim::RegisterResetCallback,
      py::arg("callback"), py::arg("initialNotify"), release_gil(), py::doc(
    "Register a callback to be called whenever the encoder is reset.\n"
"\n"
":param callback:      the callback\n"
":param initialNotify: whether to run the callback on the initial value\n"
"\n"
":returns: the CallbackStore object associated with this callback")
  )
  
  
  
    
  .
def
("getReset", &frc::sim::EncoderSim::GetReset, release_gil(), py::doc(
    "Check if the encoder has been reset.\n"
"\n"
":returns: true if reset")
  )
  
  
  
    
  .
def
("setReset", &frc::sim::EncoderSim::SetReset,
      py::arg("reset"), release_gil(), py::doc(
    "Change the reset property of the encoder.\n"
"\n"
":param reset: the new value")
  )
  
  
  
    
  .
def
("registerMaxPeriodCallback", &frc::sim::EncoderSim::RegisterMaxPeriodCallback,
      py::arg("callback"), py::arg("initialNotify"), release_gil(), py::doc(
    "Register a callback to be run whenever the max period of the encoder is\n"
"changed.\n"
"\n"
":param callback:      the callback\n"
":param initialNotify: whether to run the callback on the initial value\n"
"\n"
":returns: the CallbackStore object associated with this callback")
  )
  
  
  
    
  .
def
("getMaxPeriod", &frc::sim::EncoderSim::GetMaxPeriod, release_gil(), py::doc(
    "Get the max period of the encoder.\n"
"\n"
":returns: the max period of the encoder")
  )
  
  
  
    
  .
def
("setMaxPeriod", &frc::sim::EncoderSim::SetMaxPeriod,
      py::arg("maxPeriod"), release_gil(), py::doc(
    "Change the max period of the encoder.\n"
"\n"
":param maxPeriod: the new value")
  )
  
  
  
    
  .
def
("registerDirectionCallback", &frc::sim::EncoderSim::RegisterDirectionCallback,
      py::arg("callback"), py::arg("initialNotify"), release_gil(), py::doc(
    "Register a callback on the direction of the encoder.\n"
"\n"
":param callback:      the callback that will be called whenever the direction\n"
"                      is changed\n"
":param initialNotify: if true, the callback will be run on the initial value\n"
"\n"
":returns: the CallbackStore object associated with this callback")
  )
  
  
  
    
  .
def
("getDirection", &frc::sim::EncoderSim::GetDirection, release_gil(), py::doc(
    "Get the direction of the encoder.\n"
"\n"
":returns: the direction of the encoder")
  )
  
  
  
    
  .
def
("setDirection", &frc::sim::EncoderSim::SetDirection,
      py::arg("direction"), release_gil(), py::doc(
    "Set the direction of the encoder.\n"
"\n"
":param direction: the new direction")
  )
  
  
  
    
  .
def
("registerReverseDirectionCallback", &frc::sim::EncoderSim::RegisterReverseDirectionCallback,
      py::arg("callback"), py::arg("initialNotify"), release_gil(), py::doc(
    "Register a callback on the reverse direction.\n"
"\n"
":param callback:      the callback that will be called whenever the reverse\n"
"                      direction is changed\n"
":param initialNotify: if true, the callback will be run on the initial value\n"
"\n"
":returns: the CallbackStore object associated with this callback")
  )
  
  
  
    
  .
def
("getReverseDirection", &frc::sim::EncoderSim::GetReverseDirection, release_gil(), py::doc(
    "Get the reverse direction of the encoder.\n"
"\n"
":returns: the reverse direction of the encoder")
  )
  
  
  
    
  .
def
("setReverseDirection", &frc::sim::EncoderSim::SetReverseDirection,
      py::arg("reverseDirection"), release_gil(), py::doc(
    "Set the reverse direction.\n"
"\n"
":param reverseDirection: the new value")
  )
  
  
  
    
  .
def
("registerSamplesToAverageCallback", &frc::sim::EncoderSim::RegisterSamplesToAverageCallback,
      py::arg("callback"), py::arg("initialNotify"), release_gil(), py::doc(
    "Register a callback on the samples-to-average value of this encoder.\n"
"\n"
":param callback:      the callback that will be called whenever the\n"
"                      samples-to-average is changed\n"
":param initialNotify: if true, the callback will be run on the initial value\n"
"\n"
":returns: the CallbackStore object associated with this callback")
  )
  
  
  
    
  .
def
("getSamplesToAverage", &frc::sim::EncoderSim::GetSamplesToAverage, release_gil(), py::doc(
    "Get the samples-to-average value.\n"
"\n"
":returns: the samples-to-average value")
  )
  
  
  
    
  .
def
("setSamplesToAverage", &frc::sim::EncoderSim::SetSamplesToAverage,
      py::arg("samplesToAverage"), release_gil(), py::doc(
    "Set the samples-to-average value.\n"
"\n"
":param samplesToAverage: the new value")
  )
  
  
  
    
  .
def
("registerDistancePerPulseCallback", &frc::sim::EncoderSim::RegisterDistancePerPulseCallback,
      py::arg("callback"), py::arg("initialNotify"), release_gil(), py::doc(
    "Register a callback on the distance per pulse value of this encoder.\n"
"\n"
":param callback:      the callback that will be called whenever the\n"
"                      distance per pulse is changed\n"
":param initialNotify: if true, the callback will be run on the initial value\n"
"\n"
":returns: the CallbackStore object associated with this callback")
  )
  
  
  
    
  .
def
("getDistancePerPulse", &frc::sim::EncoderSim::GetDistancePerPulse, release_gil(), py::doc(
    "Read the distance per pulse of the encoder.\n"
"\n"
":returns: the encoder distance per pulse")
  )
  
  
  
    
  .
def
("setDistancePerPulse", &frc::sim::EncoderSim::SetDistancePerPulse,
      py::arg("distancePerPulse"), release_gil(), py::doc(
    "Change the encoder distance per pulse.\n"
"\n"
":param distancePerPulse: the new distance per pulse")
  )
  
  
  
    
  .
def
("resetData", &frc::sim::EncoderSim::ResetData, release_gil(), py::doc(
    "Resets all simulation data for this encoder.")
  )
  
  
  
    
  .
def
("setDistance", &frc::sim::EncoderSim::SetDistance,
      py::arg("distance"), release_gil(), py::doc(
    "Change the encoder distance.\n"
"\n"
":param distance: the new distance")
  )
  
  
  
    
  .
def
("getDistance", &frc::sim::EncoderSim::GetDistance, release_gil(), py::doc(
    "Read the distance of the encoder.\n"
"\n"
":returns: the encoder distance")
  )
  
  
  
    
  .
def
("setRate", &frc::sim::EncoderSim::SetRate,
      py::arg("rate"), release_gil(), py::doc(
    "Change the rate of the encoder.\n"
"\n"
":param rate: the new rate")
  )
  
  
  
    
  .
def
("getRate", &frc::sim::EncoderSim::GetRate, release_gil(), py::doc(
    "Get the rate of the encoder.\n"
"\n"
":returns: the rate of change")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_EncoderSim_initializer

static std::unique_ptr<rpybuild_EncoderSim_initializer> cls;

void begin_init_EncoderSim(py::module &m) {
  cls = std::make_unique<rpybuild_EncoderSim_initializer>(m);
}

void finish_init_EncoderSim() {
  cls->finish();
  cls.reset();
}