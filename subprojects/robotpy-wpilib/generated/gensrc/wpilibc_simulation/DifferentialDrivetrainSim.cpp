
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/simulation/DifferentialDrivetrainSim.h>


#include <pybind11/eigen.h>

#include <pybind11/stl.h>

#include <units_current_type_caster.h>

#include <units_length_type_caster.h>

#include <units_mass_type_caster.h>

#include <units_moment_of_inertia_type_caster.h>

#include <units_time_type_caster.h>

#include <units_velocity_type_caster.h>

#include <units_voltage_type_caster.h>















#include <type_traits>


  using namespace frc::sim;



struct rpybuild_DifferentialDrivetrainSim_initializer {


  
    using DCMotor = frc::DCMotor;
  
    template <int S, int I, int O> using LinearSystem = frc::LinearSystem<S, I, O>;
  

  












  py::class_<typename frc::sim::DifferentialDrivetrainSim> cls_DifferentialDrivetrainSim;

    

    
    
    py::class_<typename frc::sim::DifferentialDrivetrainSim::State> cls_State;

    

    
    
    
    py::class_<typename frc::sim::DifferentialDrivetrainSim::KitbotGearing> cls_KitbotGearing;

    

    
    
    
    py::class_<typename frc::sim::DifferentialDrivetrainSim::KitbotMotor> cls_KitbotMotor;

    

    
    
    
    py::class_<typename frc::sim::DifferentialDrivetrainSim::KitbotWheelSize> cls_KitbotWheelSize;

    

    
    
    

  py::module &m;

  
  rpybuild_DifferentialDrivetrainSim_initializer(py::module &m) :

  

  

  

  
    cls_DifferentialDrivetrainSim(m, "DifferentialDrivetrainSim"),

  

  
  
    cls_State(cls_DifferentialDrivetrainSim, "State"),

  

  
  
  
    cls_KitbotGearing(cls_DifferentialDrivetrainSim, "KitbotGearing"),

  

  
  
  
    cls_KitbotMotor(cls_DifferentialDrivetrainSim, "KitbotMotor"),

  

  
  
  
    cls_KitbotWheelSize(cls_DifferentialDrivetrainSim, "KitbotWheelSize"),

  

  
  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  

    
    
  

    
    
  

    
    
  

    
    
  }

void finish() {





  {
  
  using State [[maybe_unused]] = typename frc::sim::DifferentialDrivetrainSim::State;
  
  using KitbotGearing [[maybe_unused]] = typename frc::sim::DifferentialDrivetrainSim::KitbotGearing;
  
  using KitbotMotor [[maybe_unused]] = typename frc::sim::DifferentialDrivetrainSim::KitbotMotor;
  
  using KitbotWheelSize [[maybe_unused]] = typename frc::sim::DifferentialDrivetrainSim::KitbotWheelSize;
  
  
  


  

  

  cls_DifferentialDrivetrainSim
  
    
  .def(py::init<LinearSystem<2, 2, 2>, units::meter_t, DCMotor, double, units::meter_t, const std::array<double, 7>&>(),
      py::arg("plant"), py::arg("trackWidth"), py::arg("driveMotor"), py::arg("gearingRatio"), py::arg("wheelRadius"), py::arg("measurementStdDevs") = std::array<double, 7>{}, release_gil()
    , py::keep_alive<1, 7>(), py::doc(
    "Creates a simulated differential drivetrain.\n"
"\n"
":param plant:              The LinearSystem representing the robot's drivetrain. This\n"
"                           system can be created with\n"
"                           LinearSystemId::DrivetrainVelocitySystem() or\n"
"                           LinearSystemId::IdentifyDrivetrainSystem().\n"
":param trackWidth:         The robot's track width.\n"
":param driveMotor:         A DCMotor representing the left side of the drivetrain.\n"
":param gearingRatio:       The gearingRatio ratio of the left side, as output over\n"
"                           input. This must be the same ratio as the ratio used to\n"
"                           identify or create the plant.\n"
":param wheelRadius:        The radius of the wheels on the drivetrain, in meters.\n"
":param measurementStdDevs: Standard deviations for measurements, in the form\n"
"                           [x, y, heading, left velocity, right velocity,\n"
"                           left distance, right distance]ᵀ. Can be omitted\n"
"                           if no noise is desired. Gyro standard deviations\n"
"                           of 0.0001 radians, velocity standard deviations\n"
"                           of 0.05 m/s, and position measurement standard\n"
"                           deviations of 0.005 meters are a reasonable\n"
"                           starting point.")
  )
  
  
  
    
  .def(py::init<frc::DCMotor, double, units::kilogram_square_meter_t, units::kilogram_t, units::meter_t, units::meter_t, const std::array<double, 7>&>(),
      py::arg("driveMotor"), py::arg("gearing"), py::arg("J"), py::arg("mass"), py::arg("wheelRadius"), py::arg("trackWidth"), py::arg("measurementStdDevs") = std::array<double, 7>{}, release_gil()
    , py::keep_alive<1, 8>(), py::doc(
    "Creates a simulated differential drivetrain.\n"
"\n"
":param driveMotor:         A DCMotor representing the left side of the drivetrain.\n"
":param gearing:            The gearing on the drive between motor and wheel, as\n"
"                           output over input. This must be the same ratio as the\n"
"                           ratio used to identify or create the plant.\n"
":param J:                  The moment of inertia of the drivetrain about its\n"
"                           center.\n"
":param mass:               The mass of the drivebase.\n"
":param wheelRadius:        The radius of the wheels on the drivetrain.\n"
":param trackWidth:         The robot's track width, or distance between left and\n"
"                           right wheels.\n"
":param measurementStdDevs: Standard deviations for measurements, in the form\n"
"                           [x, y, heading, left velocity, right velocity,\n"
"                           left distance, right distance]ᵀ. Can be omitted\n"
"                           if no noise is desired. Gyro standard deviations\n"
"                           of 0.0001 radians, velocity standard deviations\n"
"                           of 0.05 m/s, and position measurement standard\n"
"                           deviations of 0.005 meters are a reasonable\n"
"                           starting point.")
  )
  
  
  
    
  .
def
("clampInput", &frc::sim::DifferentialDrivetrainSim::ClampInput,
      py::arg("u"), release_gil(), py::doc(
    "Clamp the input vector such that no element exceeds the battery voltage.\n"
"If any does, the relative magnitudes of the input will be maintained.\n"
"\n"
":param u: The input vector.\n"
"\n"
":returns: The normalized input.")
  )
  
  
  
    
  .
def
("setInputs", &frc::sim::DifferentialDrivetrainSim::SetInputs,
      py::arg("leftVoltage"), py::arg("rightVoltage"), release_gil(), py::doc(
    "Sets the applied voltage to the drivetrain. Note that positive voltage must\n"
"make that side of the drivetrain travel forward (+X).\n"
"\n"
":param leftVoltage:  The left voltage.\n"
":param rightVoltage: The right voltage.")
  )
  
  
  
    
  .
def
("setGearing", &frc::sim::DifferentialDrivetrainSim::SetGearing,
      py::arg("newGearing"), release_gil(), py::doc(
    "Sets the gearing reduction on the drivetrain. This is commonly used for\n"
"shifting drivetrains.\n"
"\n"
":param newGearing: The new gear ratio, as output over input.")
  )
  
  
  
    
  .
def
("update", &frc::sim::DifferentialDrivetrainSim::Update,
      py::arg("dt"), release_gil(), py::doc(
    "Updates the simulation.\n"
"\n"
":param dt: The time that's passed since the last Update(units::second_t)\n"
"           call.")
  )
  
  
  
    
  .
def
("getGearing", &frc::sim::DifferentialDrivetrainSim::GetGearing, release_gil(), py::doc(
    "Returns the current gearing reduction of the drivetrain, as output over\n"
"input.")
  )
  
  
  
    
  .
def
("getHeading", &frc::sim::DifferentialDrivetrainSim::GetHeading, release_gil(), py::doc(
    "Returns the direction the robot is pointing.\n"
"\n"
"Note that this angle is counterclockwise-positive, while most gyros are\n"
"clockwise positive.")
  )
  
  
  
    
  .
def
("getPose", &frc::sim::DifferentialDrivetrainSim::GetPose, release_gil(), py::doc(
    "Returns the current pose.")
  )
  
  
  
    
  .
def
("getRightPosition", &frc::sim::DifferentialDrivetrainSim::GetRightPosition, release_gil(), py::doc(
    "Get the right encoder position in meters.\n"
"\n"
":returns: The encoder position.")
  )
  
  
  
    
  .
def
("getRightVelocity", &frc::sim::DifferentialDrivetrainSim::GetRightVelocity, release_gil(), py::doc(
    "Get the right encoder velocity in meters per second.\n"
"\n"
":returns: The encoder velocity.")
  )
  
  
  
    
  .
def
("getLeftPosition", &frc::sim::DifferentialDrivetrainSim::GetLeftPosition, release_gil(), py::doc(
    "Get the left encoder position in meters.\n"
"\n"
":returns: The encoder position.")
  )
  
  
  
    
  .
def
("getLeftVelocity", &frc::sim::DifferentialDrivetrainSim::GetLeftVelocity, release_gil(), py::doc(
    "Get the left encoder velocity in meters per second.\n"
"\n"
":returns: The encoder velocity.")
  )
  
  
  
    
  .
def
("getRightCurrentDraw", &frc::sim::DifferentialDrivetrainSim::GetRightCurrentDraw, release_gil(), py::doc(
    "Returns the currently drawn current for the right side.")
  )
  
  
  
    
  .
def
("getLeftCurrentDraw", &frc::sim::DifferentialDrivetrainSim::GetLeftCurrentDraw, release_gil(), py::doc(
    "Returns the currently drawn current for the left side.")
  )
  
  
  
    
  .
def
("getCurrentDraw", &frc::sim::DifferentialDrivetrainSim::GetCurrentDraw, release_gil(), py::doc(
    "Returns the currently drawn current.")
  )
  
  
  
    
  .
def
("setState", &frc::sim::DifferentialDrivetrainSim::SetState,
      py::arg("state"), release_gil(), py::doc(
    "Sets the system state.\n"
"\n"
":param state: The state.")
  )
  
  
  
    
  .
def
("setPose", &frc::sim::DifferentialDrivetrainSim::SetPose,
      py::arg("pose"), release_gil(), py::doc(
    "Sets the system pose.\n"
"\n"
":param pose: The pose.")
  )
  
  
  
    
  .
def
("dynamics", &frc::sim::DifferentialDrivetrainSim::Dynamics,
      py::arg("x"), py::arg("u"), release_gil(), py::doc(
    "The differential drive dynamics function.\n"
"\n"
":param x: The state.\n"
":param u: The input.\n"
"\n"
":returns: The state derivative with respect to time.")
  )
  
  
  
    
  .
def_static
("createKitbotSim", static_cast<DifferentialDrivetrainSim(*)(frc::DCMotor, double, units::meter_t, const std::array<double, 7>&)>(
        &frc::sim::DifferentialDrivetrainSim::CreateKitbotSim),
      py::arg("motor"), py::arg("gearing"), py::arg("wheelSize"), py::arg("measurementStdDevs") = std::array<double, 7>{}, release_gil(), py::doc(
    "Create a sim for the standard FRC kitbot.\n"
"\n"
":param motor:              The motors installed in the bot.\n"
":param gearing:            The gearing reduction used.\n"
":param wheelSize:          The wheel size.\n"
":param measurementStdDevs: Standard deviations for measurements, in the form\n"
"                           [x, y, heading, left velocity, right velocity, left distance, right\n"
"                           distance]ᵀ. Can be omitted if no noise is desired. Gyro standard\n"
"                           deviations of 0.0001 radians, velocity standard deviations of 0.05 m/s, and\n"
"                           position measurement standard deviations of 0.005 meters are a reasonable\n"
"                           starting point.")
  )
  
  
  
    
  .
def_static
("createKitbotSim", static_cast<DifferentialDrivetrainSim(*)(frc::DCMotor, double, units::meter_t, units::kilogram_square_meter_t, const std::array<double, 7>&)>(
        &frc::sim::DifferentialDrivetrainSim::CreateKitbotSim),
      py::arg("motor"), py::arg("gearing"), py::arg("wheelSize"), py::arg("J"), py::arg("measurementStdDevs") = std::array<double, 7>{}, release_gil(), py::doc(
    "Create a sim for the standard FRC kitbot.\n"
"\n"
":param motor:              The motors installed in the bot.\n"
":param gearing:            The gearing reduction used.\n"
":param wheelSize:          The wheel size.\n"
":param J:                  The moment of inertia of the drivebase. This can be\n"
"                           calculated using SysId.\n"
":param measurementStdDevs: Standard deviations for measurements, in the form\n"
"                           [x, y, heading, left velocity, right velocity, left distance, right\n"
"                           distance]ᵀ. Can be omitted if no noise is desired. Gyro standard\n"
"                           deviations of 0.0001 radians, velocity standard deviations of 0.05 m/s, and\n"
"                           position measurement standard deviations of 0.005 meters are a reasonable\n"
"                           starting point.")
  )
  
  
  ;

  


  

  

  cls_State
  
    .def(py::init<>(), release_gil())
  
    .def_readonly_static("kX", &frc::sim::DifferentialDrivetrainSim::State::kX)
  
    .def_readonly_static("kY", &frc::sim::DifferentialDrivetrainSim::State::kY)
  
    .def_readonly_static("kHeading", &frc::sim::DifferentialDrivetrainSim::State::kHeading)
  
    .def_readonly_static("kLeftVelocity", &frc::sim::DifferentialDrivetrainSim::State::kLeftVelocity)
  
    .def_readonly_static("kRightVelocity", &frc::sim::DifferentialDrivetrainSim::State::kRightVelocity)
  
    .def_readonly_static("kLeftPosition", &frc::sim::DifferentialDrivetrainSim::State::kLeftPosition)
  
    .def_readonly_static("kRightPosition", &frc::sim::DifferentialDrivetrainSim::State::kRightPosition)
  ;

  


  
  

  cls_KitbotGearing.doc() =
    "Represents a gearing option of the Toughbox mini.\n"
"12.75:1 -- 14:50 and 14:50\n"
"10.71:1 -- 14:50 and 16:48\n"
"8.45:1 -- 14:50 and 19:45\n"
"7.31:1 -- 14:50 and 21:43\n"
"5.95:1 -- 14:50 and 24:40";

  cls_KitbotGearing
  
    .def(py::init<>(), release_gil())
  
    .def_readonly_static("k12p75", &frc::sim::DifferentialDrivetrainSim::KitbotGearing::k12p75, py::doc(
    "Gear ratio of 12.75:1."))
  
    .def_readonly_static("k10p71", &frc::sim::DifferentialDrivetrainSim::KitbotGearing::k10p71, py::doc(
    "Gear ratio of 10.71:1."))
  
    .def_readonly_static("k8p45", &frc::sim::DifferentialDrivetrainSim::KitbotGearing::k8p45, py::doc(
    "Gear ratio of 8.45:1."))
  
    .def_readonly_static("k7p31", &frc::sim::DifferentialDrivetrainSim::KitbotGearing::k7p31, py::doc(
    "Gear ratio of 7.31:1."))
  
    .def_readonly_static("k5p95", &frc::sim::DifferentialDrivetrainSim::KitbotGearing::k5p95, py::doc(
    "Gear ratio of 5.95:1."))
  ;

  


  
  

  cls_KitbotMotor.doc() =
    "Represents common motor layouts of the kit drivetrain.";

  cls_KitbotMotor
  
    .def(py::init<>(), release_gil())
  
    .def_readonly_static("SingleCIMPerSide", &frc::sim::DifferentialDrivetrainSim::KitbotMotor::SingleCIMPerSide, py::doc(
    "One CIM motor per drive side."))
  
    .def_readonly_static("DualCIMPerSide", &frc::sim::DifferentialDrivetrainSim::KitbotMotor::DualCIMPerSide, py::doc(
    "Two CIM motors per drive side."))
  
    .def_readonly_static("SingleMiniCIMPerSide", &frc::sim::DifferentialDrivetrainSim::KitbotMotor::SingleMiniCIMPerSide, py::doc(
    "One Mini CIM motor per drive side."))
  
    .def_readonly_static("DualMiniCIMPerSide", &frc::sim::DifferentialDrivetrainSim::KitbotMotor::DualMiniCIMPerSide, py::doc(
    "Two Mini CIM motors per drive side."))
  
    .def_readonly_static("SingleFalcon500PerSide", &frc::sim::DifferentialDrivetrainSim::KitbotMotor::SingleFalcon500PerSide, py::doc(
    "One Falcon 500 motor per drive side."))
  
    .def_readonly_static("DualFalcon500PerSide", &frc::sim::DifferentialDrivetrainSim::KitbotMotor::DualFalcon500PerSide, py::doc(
    "Two Falcon 500 motors per drive side."))
  
    .def_readonly_static("SingleNEOPerSide", &frc::sim::DifferentialDrivetrainSim::KitbotMotor::SingleNEOPerSide, py::doc(
    "One NEO motor per drive side."))
  
    .def_readonly_static("DualNEOPerSide", &frc::sim::DifferentialDrivetrainSim::KitbotMotor::DualNEOPerSide, py::doc(
    "Two NEO motors per drive side."))
  ;

  


  
  

  cls_KitbotWheelSize.doc() =
    "Represents common wheel sizes of the kit drivetrain.";

  cls_KitbotWheelSize
  
    .def(py::init<>(), release_gil())
  
    .def_readonly_static("kSixInch", &frc::sim::DifferentialDrivetrainSim::KitbotWheelSize::kSixInch, py::doc(
    "Six inch diameter wheels."))
  
    .def_readonly_static("kEightInch", &frc::sim::DifferentialDrivetrainSim::KitbotWheelSize::kEightInch, py::doc(
    "Eight inch diameter wheels."))
  
    .def_readonly_static("kTenInch", &frc::sim::DifferentialDrivetrainSim::KitbotWheelSize::kTenInch, py::doc(
    "Ten inch diameter wheels."))
  ;

  


  
  }







  cls_DifferentialDrivetrainSim
  .def("getLeftPositionFeet", [](DifferentialDrivetrainSim * self) -> units::foot_t {
    return self->GetLeftPosition();
  })
  .def("getLeftPositionInches", [](DifferentialDrivetrainSim * self) -> units::inch_t {
    return self->GetLeftPosition();
  })
  .def("getLeftVelocityFps", [](DifferentialDrivetrainSim * self) -> units::feet_per_second_t {
    return self->GetLeftVelocity();
  })
  .def("getRightPositionFeet", [](DifferentialDrivetrainSim * self) -> units::foot_t {
    return self->GetRightPosition();
  })
  .def("getRightPositionInches", [](DifferentialDrivetrainSim * self) -> units::inch_t {
    return self->GetRightPosition();
  })
  .def("getRightVelocityFps", [](DifferentialDrivetrainSim * self) -> units::feet_per_second_t {
    return self->GetRightVelocity();
  })
;

}

}; // struct rpybuild_DifferentialDrivetrainSim_initializer

static std::unique_ptr<rpybuild_DifferentialDrivetrainSim_initializer> cls;

void begin_init_DifferentialDrivetrainSim(py::module &m) {
  cls = std::make_unique<rpybuild_DifferentialDrivetrainSim_initializer>(m);
}

void finish_init_DifferentialDrivetrainSim() {
  cls->finish();
  cls.reset();
}