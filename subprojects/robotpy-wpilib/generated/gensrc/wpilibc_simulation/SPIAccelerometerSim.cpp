
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/simulation/SPIAccelerometerSim.h>


#include <pybind11/functional.h>















#include <type_traits>


  using namespace frc::sim;



struct rpybuild_SPIAccelerometerSim_initializer {


  

  












  py::class_<typename frc::sim::SPIAccelerometerSim> cls_SPIAccelerometerSim;

    

    
    

  py::module &m;

  
  rpybuild_SPIAccelerometerSim_initializer(py::module &m) :

  

  

  

  
    cls_SPIAccelerometerSim(m, "SPIAccelerometerSim"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  

  cls_SPIAccelerometerSim
  
    
  .def(py::init<int>(),
      py::arg("index"), release_gil(), py::doc(
    "Construct a new simulation object.\n"
"\n"
":param index: the HAL index of the accelerometer")
  )
  
  
  
    
  .
def
("registerActiveCallback", &frc::sim::SPIAccelerometerSim::RegisterActiveCallback,
      py::arg("callback"), py::arg("initialNotify"), release_gil(), py::doc(
    "Register a callback to be run when this accelerometer activates.\n"
"\n"
":param callback:      the callback\n"
":param initialNotify: whether to run the callback with the initial state\n"
"\n"
":returns: the CallbackStore object associated with this callback")
  )
  
  
  
    
  .
def
("getActive", &frc::sim::SPIAccelerometerSim::GetActive, release_gil(), py::doc(
    "Check whether the accelerometer is active.\n"
"\n"
":returns: true if active")
  )
  
  
  
    
  .
def
("setActive", &frc::sim::SPIAccelerometerSim::SetActive,
      py::arg("active"), release_gil(), py::doc(
    "Define whether this accelerometer is active.\n"
"\n"
":param active: the new state")
  )
  
  
  
    
  .
def
("registerRangeCallback", &frc::sim::SPIAccelerometerSim::RegisterRangeCallback,
      py::arg("callback"), py::arg("initialNotify"), release_gil(), py::doc(
    "Register a callback to be run whenever the range changes.\n"
"\n"
":param callback:      the callback\n"
":param initialNotify: whether to call the callback with the initial state\n"
"\n"
":returns: the CallbackStore object associated with this callback")
  )
  
  
  
    
  .
def
("getRange", &frc::sim::SPIAccelerometerSim::GetRange, release_gil(), py::doc(
    "Check the range of this accelerometer.\n"
"\n"
":returns: the accelerometer range")
  )
  
  
  
    
  .
def
("setRange", &frc::sim::SPIAccelerometerSim::SetRange,
      py::arg("range"), release_gil(), py::doc(
    "Change the range of this accelerometer.\n"
"\n"
":param range: the new accelerometer range")
  )
  
  
  
    
  .
def
("registerXCallback", &frc::sim::SPIAccelerometerSim::RegisterXCallback,
      py::arg("callback"), py::arg("initialNotify"), release_gil(), py::doc(
    "Register a callback to be run whenever the X axis value changes.\n"
"\n"
":param callback:      the callback\n"
":param initialNotify: whether to call the callback with the initial state\n"
"\n"
":returns: the CallbackStore object associated with this callback")
  )
  
  
  
    
  .
def
("getX", &frc::sim::SPIAccelerometerSim::GetX, release_gil(), py::doc(
    "Measure the X axis value.\n"
"\n"
":returns: the X axis measurement")
  )
  
  
  
    
  .
def
("setX", &frc::sim::SPIAccelerometerSim::SetX,
      py::arg("x"), release_gil(), py::doc(
    "Change the X axis value of the accelerometer.\n"
"\n"
":param x: the new reading of the X axis")
  )
  
  
  
    
  .
def
("registerYCallback", &frc::sim::SPIAccelerometerSim::RegisterYCallback,
      py::arg("callback"), py::arg("initialNotify"), release_gil(), py::doc(
    "Register a callback to be run whenever the Y axis value changes.\n"
"\n"
":param callback:      the callback\n"
":param initialNotify: whether to call the callback with the initial state\n"
"\n"
":returns: the CallbackStore object associated with this callback")
  )
  
  
  
    
  .
def
("getY", &frc::sim::SPIAccelerometerSim::GetY, release_gil(), py::doc(
    "Measure the Y axis value.\n"
"\n"
":returns: the Y axis measurement")
  )
  
  
  
    
  .
def
("setY", &frc::sim::SPIAccelerometerSim::SetY,
      py::arg("y"), release_gil(), py::doc(
    "Change the Y axis value of the accelerometer.\n"
"\n"
":param y: the new reading of the Y axis")
  )
  
  
  
    
  .
def
("registerZCallback", &frc::sim::SPIAccelerometerSim::RegisterZCallback,
      py::arg("callback"), py::arg("initialNotify"), release_gil(), py::doc(
    "Register a callback to be run whenever the Z axis value changes.\n"
"\n"
":param callback:      the callback\n"
":param initialNotify: whether to call the callback with the initial state\n"
"\n"
":returns: the CallbackStore object associated with this callback")
  )
  
  
  
    
  .
def
("getZ", &frc::sim::SPIAccelerometerSim::GetZ, release_gil(), py::doc(
    "Measure the Z axis value.\n"
"\n"
":returns: the Z axis measurement")
  )
  
  
  
    
  .
def
("setZ", &frc::sim::SPIAccelerometerSim::SetZ,
      py::arg("z"), release_gil(), py::doc(
    "Change the Z axis value of the accelerometer.\n"
"\n"
":param z: the new reading of the Z axis")
  )
  
  
  
    
  .
def
("resetData", &frc::sim::SPIAccelerometerSim::ResetData, release_gil(), py::doc(
    "Reset all simulation data of this object.")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_SPIAccelerometerSim_initializer

static std::unique_ptr<rpybuild_SPIAccelerometerSim_initializer> cls;

void begin_init_SPIAccelerometerSim(py::module &m) {
  cls = std::make_unique<rpybuild_SPIAccelerometerSim_initializer>(m);
}

void finish_init_SPIAccelerometerSim() {
  cls->finish();
  cls.reset();
}