
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/simulation/DriverStationSim.h>


#include <pybind11/functional.h>















#include <type_traits>


  using namespace frc::sim;



struct rpybuild_DriverStationSim_initializer {


  

  












  py::class_<typename frc::sim::DriverStationSim> cls_DriverStationSim;

    

    
    

  py::module &m;

  
  rpybuild_DriverStationSim_initializer(py::module &m) :

  

  

  

  
    cls_DriverStationSim(m, "DriverStationSim"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_DriverStationSim.doc() =
    "Class to control a simulated driver station.";

  cls_DriverStationSim
  
    .def(py::init<>(), release_gil())
  
    
  .
def_static
("registerEnabledCallback", &frc::sim::DriverStationSim::RegisterEnabledCallback,
      py::arg("callback"), py::arg("initialNotify"), release_gil(), py::doc(
    "Register a callback on whether the DS is enabled.\n"
"\n"
":param callback:      the callback that will be called whenever the enabled\n"
"                      state is changed\n"
":param initialNotify: if true, the callback will be run on the initial value\n"
"\n"
":returns: the CallbackStore object associated with this callback")
  )
  
  
  
    
  .
def_static
("getEnabled", &frc::sim::DriverStationSim::GetEnabled, release_gil(), py::doc(
    "Check if the DS is enabled.\n"
"\n"
":returns: true if enabled")
  )
  
  
  
    
  .
def_static
("setEnabled", &frc::sim::DriverStationSim::SetEnabled,
      py::arg("enabled"), release_gil(), py::doc(
    "Change whether the DS is enabled.\n"
"\n"
":param enabled: the new value")
  )
  
  
  
    
  .
def_static
("registerAutonomousCallback", &frc::sim::DriverStationSim::RegisterAutonomousCallback,
      py::arg("callback"), py::arg("initialNotify"), release_gil(), py::doc(
    "Register a callback on whether the DS is in autonomous mode.\n"
"\n"
":param callback:      the callback that will be called on autonomous mode\n"
"                      entrance/exit\n"
":param initialNotify: if true, the callback will be run on the initial value\n"
"\n"
":returns: the CallbackStore object associated with this callback")
  )
  
  
  
    
  .
def_static
("getAutonomous", &frc::sim::DriverStationSim::GetAutonomous, release_gil(), py::doc(
    "Check if the DS is in autonomous.\n"
"\n"
":returns: true if autonomous")
  )
  
  
  
    
  .
def_static
("setAutonomous", &frc::sim::DriverStationSim::SetAutonomous,
      py::arg("autonomous"), release_gil(), py::doc(
    "Change whether the DS is in autonomous.\n"
"\n"
":param autonomous: the new value")
  )
  
  
  
    
  .
def_static
("registerTestCallback", &frc::sim::DriverStationSim::RegisterTestCallback,
      py::arg("callback"), py::arg("initialNotify"), release_gil(), py::doc(
    "Register a callback on whether the DS is in test mode.\n"
"\n"
":param callback:      the callback that will be called whenever the test mode\n"
"                      is entered or left\n"
":param initialNotify: if true, the callback will be run on the initial value\n"
"\n"
":returns: the CallbackStore object associated with this callback")
  )
  
  
  
    
  .
def_static
("getTest", &frc::sim::DriverStationSim::GetTest, release_gil(), py::doc(
    "Check if the DS is in test.\n"
"\n"
":returns: true if test")
  )
  
  
  
    
  .
def_static
("setTest", &frc::sim::DriverStationSim::SetTest,
      py::arg("test"), release_gil(), py::doc(
    "Change whether the DS is in test.\n"
"\n"
":param test: the new value")
  )
  
  
  
    
  .
def_static
("registerEStopCallback", &frc::sim::DriverStationSim::RegisterEStopCallback,
      py::arg("callback"), py::arg("initialNotify"), release_gil(), py::doc(
    "Register a callback on the eStop state.\n"
"\n"
":param callback:      the callback that will be called whenever the eStop state\n"
"                      changes\n"
":param initialNotify: if true, the callback will be run on the initial value\n"
"\n"
":returns: the CallbackStore object associated with this callback")
  )
  
  
  
    
  .
def_static
("getEStop", &frc::sim::DriverStationSim::GetEStop, release_gil(), py::doc(
    "Check if eStop has been activated.\n"
"\n"
":returns: true if eStopped")
  )
  
  
  
    
  .
def_static
("setEStop", &frc::sim::DriverStationSim::SetEStop,
      py::arg("eStop"), release_gil(), py::doc(
    "Set whether eStop is active.\n"
"\n"
":param eStop: true to activate")
  )
  
  
  
    
  .
def_static
("registerFmsAttachedCallback", &frc::sim::DriverStationSim::RegisterFmsAttachedCallback,
      py::arg("callback"), py::arg("initialNotify"), release_gil(), py::doc(
    "Register a callback on whether the FMS is connected.\n"
"\n"
":param callback:      the callback that will be called whenever the FMS\n"
"                      connection changes\n"
":param initialNotify: if true, the callback will be run on the initial value\n"
"\n"
":returns: the CallbackStore object associated with this callback")
  )
  
  
  
    
  .
def_static
("getFmsAttached", &frc::sim::DriverStationSim::GetFmsAttached, release_gil(), py::doc(
    "Check if the FMS is connected.\n"
"\n"
":returns: true if FMS is connected")
  )
  
  
  
    
  .
def_static
("setFmsAttached", &frc::sim::DriverStationSim::SetFmsAttached,
      py::arg("fmsAttached"), release_gil(), py::doc(
    "Change whether the FMS is connected.\n"
"\n"
":param fmsAttached: the new value")
  )
  
  
  
    
  .
def_static
("registerDsAttachedCallback", &frc::sim::DriverStationSim::RegisterDsAttachedCallback,
      py::arg("callback"), py::arg("initialNotify"), release_gil(), py::doc(
    "Register a callback on whether the DS is connected.\n"
"\n"
":param callback:      the callback that will be called whenever the DS\n"
"                      connection changes\n"
":param initialNotify: if true, the callback will be run on the initial value\n"
"\n"
":returns: the CallbackStore object associated with this callback")
  )
  
  
  
    
  .
def_static
("getDsAttached", &frc::sim::DriverStationSim::GetDsAttached, release_gil(), py::doc(
    "Check if the DS is attached.\n"
"\n"
":returns: true if attached")
  )
  
  
  
    
  .
def_static
("setDsAttached", &frc::sim::DriverStationSim::SetDsAttached,
      py::arg("dsAttached"), release_gil(), py::doc(
    "Change whether the DS is attached.\n"
"\n"
":param dsAttached: the new value")
  )
  
  
  
    
  .
def_static
("registerAllianceStationIdCallback", &frc::sim::DriverStationSim::RegisterAllianceStationIdCallback,
      py::arg("callback"), py::arg("initialNotify"), release_gil(), py::doc(
    "Register a callback on the alliance station ID.\n"
"\n"
":param callback:      the callback that will be called whenever the alliance\n"
"                      station changes\n"
":param initialNotify: if true, the callback will be run on the initial value\n"
"\n"
":returns: the CallbackStore object associated with this callback")
  )
  
  
  
    
  .
def_static
("getAllianceStationId", &frc::sim::DriverStationSim::GetAllianceStationId, release_gil(), py::doc(
    "Get the alliance station ID (color + number).\n"
"\n"
":returns: the alliance station color and number")
  )
  
  
  
    
  .
def_static
("setAllianceStationId", &frc::sim::DriverStationSim::SetAllianceStationId,
      py::arg("allianceStationId"), release_gil(), py::doc(
    "Change the alliance station.\n"
"\n"
":param allianceStationId: the new alliance station")
  )
  
  
  
    
  .
def_static
("registerMatchTimeCallback", &frc::sim::DriverStationSim::RegisterMatchTimeCallback,
      py::arg("callback"), py::arg("initialNotify"), release_gil(), py::doc(
    "Register a callback on match time.\n"
"\n"
":param callback:      the callback that will be called whenever match time\n"
"                      changes\n"
":param initialNotify: if true, the callback will be run on the initial value\n"
"\n"
":returns: the CallbackStore object associated with this callback")
  )
  
  
  
    
  .
def_static
("getMatchTime", &frc::sim::DriverStationSim::GetMatchTime, release_gil(), py::doc(
    "Get the current value of the match timer.\n"
"\n"
":returns: the current match time")
  )
  
  
  
    
  .
def_static
("setMatchTime", &frc::sim::DriverStationSim::SetMatchTime,
      py::arg("matchTime"), release_gil(), py::doc(
    "Sets the match timer.\n"
"\n"
":param matchTime: the new match time")
  )
  
  
  
    
  .
def_static
("notifyNewData", &frc::sim::DriverStationSim::NotifyNewData, release_gil(), py::doc(
    "Updates DriverStation data so that new values are visible to the user\n"
"program.")
  )
  
  
  
    
  .
def_static
("setSendError", &frc::sim::DriverStationSim::SetSendError,
      py::arg("shouldSend"), release_gil(), py::doc(
    "Sets suppression of DriverStation::ReportError and ReportWarning messages.\n"
"\n"
":param shouldSend: If false then messages will be suppressed.")
  )
  
  
  
    
  .
def_static
("setSendConsoleLine", &frc::sim::DriverStationSim::SetSendConsoleLine,
      py::arg("shouldSend"), release_gil(), py::doc(
    "Sets suppression of DriverStation::SendConsoleLine messages.\n"
"\n"
":param shouldSend: If false then messages will be suppressed.")
  )
  
  
  
    
  .
def_static
("getJoystickOutputs", &frc::sim::DriverStationSim::GetJoystickOutputs,
      py::arg("stick"), release_gil(), py::doc(
    "Gets the joystick outputs.\n"
"\n"
":param stick: The joystick number\n"
"\n"
":returns: The joystick outputs")
  )
  
  
  
    
  .
def_static
("getJoystickRumble", &frc::sim::DriverStationSim::GetJoystickRumble,
      py::arg("stick"), py::arg("rumbleNum"), release_gil(), py::doc(
    "Gets the joystick rumble.\n"
"\n"
":param stick:     The joystick number\n"
":param rumbleNum: Rumble to get (0=left, 1=right)\n"
"\n"
":returns: The joystick rumble value")
  )
  
  
  
    
  .
def_static
("setJoystickButton", &frc::sim::DriverStationSim::SetJoystickButton,
      py::arg("stick"), py::arg("button"), py::arg("state"), release_gil(), py::doc(
    "Sets the state of one joystick button. %Button indexes begin at 1.\n"
"\n"
":param stick:  The joystick number\n"
":param button: The button index, beginning at 1\n"
":param state:  The state of the joystick button")
  )
  
  
  
    
  .
def_static
("setJoystickAxis", &frc::sim::DriverStationSim::SetJoystickAxis,
      py::arg("stick"), py::arg("axis"), py::arg("value"), release_gil(), py::doc(
    "Gets the value of the axis on a joystick.\n"
"\n"
":param stick: The joystick number\n"
":param axis:  The analog axis number\n"
":param value: The value of the axis on the joystick")
  )
  
  
  
    
  .
def_static
("setJoystickPOV", &frc::sim::DriverStationSim::SetJoystickPOV,
      py::arg("stick"), py::arg("pov"), py::arg("value"), release_gil(), py::doc(
    "Gets the state of a POV on a joystick.\n"
"\n"
":param stick: The joystick number\n"
":param pov:   The POV number\n"
":param value: the angle of the POV in degrees, or -1 for not pressed")
  )
  
  
  
    
  .
def_static
("setJoystickButtons", &frc::sim::DriverStationSim::SetJoystickButtons,
      py::arg("stick"), py::arg("buttons"), release_gil(), py::doc(
    "Sets the state of all the buttons on a joystick.\n"
"\n"
":param stick:   The joystick number\n"
":param buttons: The bitmap state of the buttons on the joystick")
  )
  
  
  
    
  .
def_static
("setJoystickAxisCount", &frc::sim::DriverStationSim::SetJoystickAxisCount,
      py::arg("stick"), py::arg("count"), release_gil(), py::doc(
    "Sets the number of axes for a joystick.\n"
"\n"
":param stick: The joystick number\n"
":param count: The number of axes on the indicated joystick")
  )
  
  
  
    
  .
def_static
("setJoystickPOVCount", &frc::sim::DriverStationSim::SetJoystickPOVCount,
      py::arg("stick"), py::arg("count"), release_gil(), py::doc(
    "Sets the number of POVs for a joystick.\n"
"\n"
":param stick: The joystick number\n"
":param count: The number of POVs on the indicated joystick")
  )
  
  
  
    
  .
def_static
("setJoystickButtonCount", &frc::sim::DriverStationSim::SetJoystickButtonCount,
      py::arg("stick"), py::arg("count"), release_gil(), py::doc(
    "Sets the number of buttons for a joystick.\n"
"\n"
":param stick: The joystick number\n"
":param count: The number of buttons on the indicated joystick")
  )
  
  
  
    
  .
def_static
("setJoystickIsXbox", &frc::sim::DriverStationSim::SetJoystickIsXbox,
      py::arg("stick"), py::arg("isXbox"), release_gil(), py::doc(
    "Sets the value of isXbox for a joystick.\n"
"\n"
":param stick:  The joystick number\n"
":param isXbox: The value of isXbox")
  )
  
  
  
    
  .
def_static
("setJoystickType", &frc::sim::DriverStationSim::SetJoystickType,
      py::arg("stick"), py::arg("type"), release_gil(), py::doc(
    "Sets the value of type for a joystick.\n"
"\n"
":param stick: The joystick number\n"
":param type:  The value of type")
  )
  
  
  
    
  .
def_static
("setJoystickName", &frc::sim::DriverStationSim::SetJoystickName,
      py::arg("stick"), py::arg("name"), release_gil(), py::doc(
    "Sets the name of a joystick.\n"
"\n"
":param stick: The joystick number\n"
":param name:  The value of name")
  )
  
  
  
    
  .
def_static
("setJoystickAxisType", &frc::sim::DriverStationSim::SetJoystickAxisType,
      py::arg("stick"), py::arg("axis"), py::arg("type"), release_gil(), py::doc(
    "Sets the types of Axes for a joystick.\n"
"\n"
":param stick: The joystick number\n"
":param axis:  The target axis\n"
":param type:  The type of axis")
  )
  
  
  
    
  .
def_static
("setGameSpecificMessage", &frc::sim::DriverStationSim::SetGameSpecificMessage,
      py::arg("message"), release_gil(), py::doc(
    "Sets the game specific message.\n"
"\n"
":param message: the game specific message")
  )
  
  
  
    
  .
def_static
("setEventName", &frc::sim::DriverStationSim::SetEventName,
      py::arg("name"), release_gil(), py::doc(
    "Sets the event name.\n"
"\n"
":param name: the event name")
  )
  
  
  
    
  .
def_static
("setMatchType", &frc::sim::DriverStationSim::SetMatchType,
      py::arg("type"), release_gil(), py::doc(
    "Sets the match type.\n"
"\n"
":param type: the match type")
  )
  
  
  
    
  .
def_static
("setMatchNumber", &frc::sim::DriverStationSim::SetMatchNumber,
      py::arg("matchNumber"), release_gil(), py::doc(
    "Sets the match number.\n"
"\n"
":param matchNumber: the match number")
  )
  
  
  
    
  .
def_static
("setReplayNumber", &frc::sim::DriverStationSim::SetReplayNumber,
      py::arg("replayNumber"), release_gil(), py::doc(
    "Sets the replay number.\n"
"\n"
":param replayNumber: the replay number")
  )
  
  
  
    
  .
def_static
("resetData", &frc::sim::DriverStationSim::ResetData, release_gil(), py::doc(
    "Reset all simulation data for the Driver Station.")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_DriverStationSim_initializer

static std::unique_ptr<rpybuild_DriverStationSim_initializer> cls;

void begin_init_DriverStationSim(py::module &m) {
  cls = std::make_unique<rpybuild_DriverStationSim_initializer>(m);
}

void finish_init_DriverStationSim() {
  cls->finish();
  cls.reset();
}