
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/simulation/SimDeviceSim.h>


#include <pybind11/functional.h>

#include <pybind11/stl.h>













#include <pybind11/stl.h>



#include <type_traits>


  using namespace frc::sim;





struct rpybuild_SimDeviceSim_initializer {


  

  












  py::class_<typename frc::sim::SimDeviceSim> cls_SimDeviceSim;

    

    
    

  py::module &m;

  
  rpybuild_SimDeviceSim_initializer(py::module &m) :

  

  

  

  
    cls_SimDeviceSim(m, "SimDeviceSim"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_SimDeviceSim.doc() =
    "Interact with a generic simulated device\n"
"\n"
"Any devices that support simulation but don't have a dedicated sim\n"
"object associated with it can be interacted with via this object.\n"
"You just need to know the name of the associated object.\n"
"\n"
"Here are two ways to find the names of available devices:\n"
"\n"
"* The static function :meth:`.enumerateDevices` can give you a list of\n"
"  all available devices -- note that the device must be created first\n"
"  before this will return any results!\n"
"* When running the WPILib simulation GUI, the names of the 'Other Devices'\n"
"  panel are names of devices that you can interact with via this class.\n"
"\n"
"Once you've created a simulated device, you can use the :meth:`.enumerateValues`\n"
"method to determine what values you can interact with.\n"
"\n"
"\n"
".. note:: WPILib has simulation support for all of its devices. Some\n"
"          vendors may only have limited support for simulation -- read\n"
"          the vendor's documentation or contact them for more information.\n";

  cls_SimDeviceSim
  
    
  .def(py::init<const char*>(),
      py::arg("name"), release_gil(), py::doc(
    "Constructs a SimDeviceSim.\n"
"\n"
":param name: name of the SimDevice")
  )
  
  
  
    
  .def(py::init<const char*, int>(),
      py::arg("name"), py::arg("index"), release_gil(), py::doc(
    "Constructs a SimDeviceSim.\n"
"\n"
":param name:  name of the SimDevice\n"
":param index: device index number to append to name")
  )
  
  
  
    
  .def(py::init<const char*, int, int>(),
      py::arg("name"), py::arg("index"), py::arg("channel"), release_gil(), py::doc(
    "Constructs a SimDeviceSim.\n"
"\n"
":param name:    name of the SimDevice\n"
":param index:   device index number to append to name\n"
":param channel: device channel number to append to name")
  )
  
  
  
    
  .def(py::init<HAL_SimDeviceHandle>(),
      py::arg("handle"), release_gil(), py::doc(
    "Constructs a SimDeviceSim.\n"
"\n"
":param handle: the low level handle for the corresponding SimDevice.")
  )
  
  
  
    
  .
def
("getName", &frc::sim::SimDeviceSim::GetName, release_gil(), py::doc(
    "Get the name of this object.\n"
"\n"
":returns: name")
  )
  
  
  
    
  .
def
("getValue", &frc::sim::SimDeviceSim::GetValue,
      py::arg("name"), release_gil(), py::doc(
    "Provides a readonly mechanism to retrieve all types of device values\n")
  )
  
  
  
    
  .
def
("getInt", &frc::sim::SimDeviceSim::GetInt,
      py::arg("name"), release_gil(), py::doc(
    "Retrieves an object that allows you to interact with simulated values\n"
"represented as an integer.\n")
  )
  
  
  
    
  .
def
("getLong", &frc::sim::SimDeviceSim::GetLong,
      py::arg("name"), release_gil(), py::doc(
    "Retrieves an object that allows you to interact with simulated values\n"
"represented as a long.\n")
  )
  
  
  
    
  .
def
("getDouble", &frc::sim::SimDeviceSim::GetDouble,
      py::arg("name"), release_gil(), py::doc(
    "Retrieves an object that allows you to interact with simulated values\n"
"represented as a double.\n")
  )
  
  
  
    
  .
def
("getEnum", &frc::sim::SimDeviceSim::GetEnum,
      py::arg("name"), release_gil(), py::doc(
    "Get the property object with the given name.\n"
"\n"
":param name: the property name\n"
"\n"
":returns: the property object")
  )
  
  
  
    
  .
def
("getBoolean", &frc::sim::SimDeviceSim::GetBoolean,
      py::arg("name"), release_gil(), py::doc(
    "Retrieves an object that allows you to interact with simulated values\n"
"represented as a boolean.\n")
  )
  
  
  
    
  .
def_static
("getEnumOptions", &frc::sim::SimDeviceSim::GetEnumOptions,
      py::arg("val"), release_gil(), py::doc(
    "Get all options for the given enum.\n"
"\n"
":param val: the enum\n"
"\n"
":returns: names of the different values for that enum")
  )
  
  
  
    
  .
def_static
("resetData", &frc::sim::SimDeviceSim::ResetData, release_gil(), py::doc(
    "Reset all SimDevice data.")
  )
  
  
  ;

  


  }







  cls_SimDeviceSim
  .def("enumerateValues", [](frc::sim::SimDeviceSim * that) {
    std::vector<std::pair<std::string, bool>> values;
    that->EnumerateValues([&values](const char * name, HAL_SimValueHandle handle,
                             HAL_Bool readonly, const struct HAL_Value * value){
      values.push_back(std::pair<std::string, bool>(name, readonly));
    });
    return values;
  }, release_gil(),
  "Returns a list of (name, readonly) tuples of available values for this device")
  .def_static("enumerateDevices", [](const char * prefix) {
    std::vector<std::string> devices;
    frc::sim::SimDeviceSim::EnumerateDevices(prefix, [&devices](const char * name, HAL_SimDeviceHandle handle) {
      devices.push_back(std::string(name));
    });
    return devices;
  }, release_gil(),
  py::arg("prefix")="",
  "Returns a list of available device names\n");


}

}; // struct rpybuild_SimDeviceSim_initializer

static std::unique_ptr<rpybuild_SimDeviceSim_initializer> cls;

void begin_init_SimDeviceSim(py::module &m) {
  cls = std::make_unique<rpybuild_SimDeviceSim_initializer>(m);
}

void finish_init_SimDeviceSim() {
  cls->finish();
  cls.reset();
}