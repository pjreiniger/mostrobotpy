
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/event/BooleanEvent.h>


#include <pybind11/functional.h>

#include <units_time_type_caster.h>















#include <type_traits>


  using namespace frc;



struct rpybuild_BooleanEvent_initializer {


  

  












  py::class_<typename frc::BooleanEvent> cls_BooleanEvent;

    

    
    

  py::module &m;

  
  rpybuild_BooleanEvent_initializer(py::module &m) :

  

  

  

  
    cls_BooleanEvent(m, "BooleanEvent"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_BooleanEvent.doc() =
    "This class provides an easy way to link actions to active high logic signals.\n"
"Each object represents a digital signal to which callback actions can be\n"
"bound using :meth:`.IfHigh`.\n"
"\n"
"BooleanEvents can easily be composed for advanced functionality using\n"
"{@link #operator&&}, {@link #operator||}, and {@link #operator!}.\n"
"\n"
"To get a new BooleanEvent that triggers when this one changes see {@link\n"
"#Falling()} and :meth:`.Rising`.";

  cls_BooleanEvent
  
    
  .def(py::init<EventLoop*, std::function<bool ()>>(),
      py::arg("loop"), py::arg("signal").none(false), release_gil(), py::doc(
    "Creates a new event that is active when the condition is true.\n"
"\n"
":param loop:   the loop that polls this event\n"
":param signal: the digital signal represented by this object.")
  )
  
  
  
    
  .
def
("getAsBoolean", &frc::BooleanEvent::GetAsBoolean, release_gil(), py::doc(
    "Returns the state of this signal (high or low) as of the last loop poll.\n"
"\n"
":returns: true for the high state, false for the low state. If the event was\n"
"          never polled, it returns the state at event construction.")
  )
  
  
  
    
  .
def
("ifHigh", [](BooleanEvent *self, std::function<void()> action) {
  self->IfHigh(std::move(action));
}
,
      py::arg("action").none(false), py::doc(
    "Bind an action to this event.\n"
"\n"
":param action: the action to run if this event is active.")
  )
  
  
  
    
  .
def
("castTo", [](BooleanEvent *self, py::function constructor) -> py::object {
  return constructor(self, (std::function<bool()>)*self);
}
,
      py::arg("ctor").none(false), py::doc(
    "A method to \"downcast\" a BooleanEvent instance to a subclass (for example,\n"
"to a command-based version of this class).\n"
"\n"
":param ctor: a method reference to the constructor of the subclass that\n"
"             accepts the loop as the first parameter and the condition/signal as the\n"
"             second.\n"
"\n"
":returns: an instance of the subclass.")
  )
  
  
  
    
  .
def
("rising", &frc::BooleanEvent::Rising, release_gil(), py::doc(
    "Creates a new event that triggers when this one changes from false to true.\n"
"\n"
":returns: the new event.")
  )
  
  
  
    
  .
def
("falling", &frc::BooleanEvent::Falling, release_gil(), py::doc(
    "Creates a new event that triggers when this one changes from true to false.\n"
"\n"
":returns: the event.")
  )
  
  
  
    
  .
def
("debounce", &frc::BooleanEvent::Debounce,
      py::arg("debounceTime"), py::arg("type") = frc::Debouncer::DebounceType::kRising, release_gil(), py::doc(
    "Creates a new debounced event from this event - it will become active when\n"
"this event has been active for longer than the specified period.\n"
"\n"
":param debounceTime: The debounce period.\n"
":param type:         The debounce type.\n"
"\n"
":returns: The debounced event.")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_BooleanEvent_initializer

static std::unique_ptr<rpybuild_BooleanEvent_initializer> cls;

void begin_init_BooleanEvent(py::module &m) {
  cls = std::make_unique<rpybuild_BooleanEvent_initializer>(m);
}

void finish_init_BooleanEvent() {
  cls->finish();
  cls.reset();
}