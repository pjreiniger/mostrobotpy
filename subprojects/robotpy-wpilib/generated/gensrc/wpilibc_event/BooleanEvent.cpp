
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/event/BooleanEvent.h>


#include <pybind11/functional.h>

#include <units_time_type_caster.h>















#include <type_traits>


  using namespace frc;





struct rpybuild_BooleanEvent_initializer {


  

  












  py::class_<typename frc::BooleanEvent> cls_BooleanEvent;

    

    
    

  py::module &m;

  
  rpybuild_BooleanEvent_initializer(py::module &m) :

  

  

  

  
    cls_BooleanEvent(m, "BooleanEvent"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_BooleanEvent.doc() =
    "This class provides an easy way to link actions to inputs. Each object\n"
"represents a boolean condition to which callback actions can be bound using\n"
":meth:`.IfHigh`.\n"
"\n"
"These events can easily be composed using factories such as {@link\n"
"#operator!},\n"
"{@link #operator||}, {@link #operator&&} etc.\n"
"\n"
"To get an event that activates only when this one changes, see {@link\n"
"#Falling()} and :meth:`.Rising`.";

  cls_BooleanEvent
  
    
  .def(py::init<EventLoop*, std::function<bool ()>>(),
      py::arg("loop"), py::arg("condition").none(false), release_gil(), py::doc(
    "Creates a new event with the given condition determining whether it is\n"
"active.\n"
"\n"
":param loop:      the loop that polls this event\n"
":param condition: returns whether or not the event should be active")
  )
  
  
  
    
  .
def
("getAsBoolean", &frc::BooleanEvent::GetAsBoolean, release_gil(), py::doc(
    "Check whether this event is active or not as of the last loop poll.\n"
"\n"
":returns: true if active, false if not active. If the event was never polled,\n"
"          it returns the state at event construction.")
  )
  
  
  
    
  .
def
("ifHigh", [](BooleanEvent *self, std::function<void()> action) {
  self->IfHigh(std::move(action));
}
,
      py::arg("action").none(false), py::doc(
    "Bind an action to this event.\n"
"\n"
":param action: the action to run if this event is active.")
  )
  
  
  
    
  .
def
("castTo", [](BooleanEvent *self, py::function constructor) -> py::object {
  return constructor(self, (std::function<bool()>)*self);
}
,
      py::arg("ctor").none(false), py::doc(
    "A method to \"downcast\" a BooleanEvent instance to a subclass (for example,\n"
"to a command-based version of this class).\n"
"\n"
":param ctor: a method reference to the constructor of the subclass that\n"
"             accepts the loop as the first parameter and the condition/signal as the\n"
"             second.\n"
"\n"
":returns: an instance of the subclass.")
  )
  
  
  
    
  .
def
("rising", &frc::BooleanEvent::Rising, release_gil(), py::doc(
    "Get a new event that events only when this one newly changes to true.\n"
"\n"
":returns: a new event representing when this one newly changes to true.")
  )
  
  
  
    
  .
def
("falling", &frc::BooleanEvent::Falling, release_gil(), py::doc(
    "Get a new event that triggers only when this one newly changes to false.\n"
"\n"
":returns: a new event representing when this one newly changes to false.")
  )
  
  
  
    
  .
def
("debounce", &frc::BooleanEvent::Debounce,
      py::arg("debounceTime"), py::arg("type") = frc::Debouncer::DebounceType::kRising, release_gil(), py::doc(
    "Creates a new debounced event from this event - it will become active when\n"
"this event has been active for longer than the specified period.\n"
"\n"
":param debounceTime: The debounce period.\n"
":param type:         The debounce type.\n"
"\n"
":returns: The debounced event.")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_BooleanEvent_initializer

static std::unique_ptr<rpybuild_BooleanEvent_initializer> cls;

void begin_init_BooleanEvent(py::module &m) {
  cls = std::make_unique<rpybuild_BooleanEvent_initializer>(m);
}

void finish_init_BooleanEvent() {
  cls->finish();
  cls.reset();
}