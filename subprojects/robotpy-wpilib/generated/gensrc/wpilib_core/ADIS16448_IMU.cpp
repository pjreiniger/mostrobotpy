
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/ADIS16448_IMU.h>


#include <units_acceleration_type_caster.h>

#include <units_angle_type_caster.h>

#include <units_angular_velocity_type_caster.h>

#include <units_magnetic_field_strength_type_caster.h>

#include <units_pressure_type_caster.h>

#include <units_temperature_type_caster.h>







#define RPYGEN_ENABLE_frc__ADIS16448_IMU_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__ADIS16448_IMU.hpp>







#include <networktables/NTSendableBuilder.h>



#include <type_traits>


  using namespace frc;





struct rpybuild_ADIS16448_IMU_initializer {


  

  












  
  using ADIS16448_IMU_Trampoline = rpygen::PyTrampoline_frc__ADIS16448_IMU<typename frc::ADIS16448_IMU, typename rpygen::PyTrampolineCfg_frc__ADIS16448_IMU<>>;
    static_assert(std::is_abstract<ADIS16448_IMU_Trampoline>::value == false, "frc::ADIS16448_IMU " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::ADIS16448_IMU, ADIS16448_IMU_Trampoline, wpi::Sendable> cls_ADIS16448_IMU;

    
    
  py::enum_<frc::ADIS16448_IMU::CalibrationTime> cls_ADIS16448_IMU_enum1;
    
    
  py::enum_<frc::ADIS16448_IMU::IMUAxis> cls_ADIS16448_IMU_enum2;
    

    
    

  py::module &m;

  
  rpybuild_ADIS16448_IMU_initializer(py::module &m) :

  

  

  

  
    cls_ADIS16448_IMU(m, "ADIS16448_IMU"),

  
    cls_ADIS16448_IMU_enum1
  (cls_ADIS16448_IMU, "CalibrationTime"
  ,
    "ADIS16448 calibration times."),
  
    cls_ADIS16448_IMU_enum2
  (cls_ADIS16448_IMU, "IMUAxis"
  ,
    "IMU axes."),
  

  
  
  

    m(m)
  {
    
    

    
    
  
    cls_ADIS16448_IMU_enum1
  
    .value("_32ms", frc::ADIS16448_IMU::CalibrationTime::_32ms,
      "32 ms calibration time.")
  
    .value("_64ms", frc::ADIS16448_IMU::CalibrationTime::_64ms,
      "64 ms calibration time.")
  
    .value("_128ms", frc::ADIS16448_IMU::CalibrationTime::_128ms,
      "128 ms calibration time.")
  
    .value("_256ms", frc::ADIS16448_IMU::CalibrationTime::_256ms,
      "256 ms calibration time.")
  
    .value("_512ms", frc::ADIS16448_IMU::CalibrationTime::_512ms,
      "512 ms calibration time.")
  
    .value("_1s", frc::ADIS16448_IMU::CalibrationTime::_1s,
      "1 s calibration time.")
  
    .value("_2s", frc::ADIS16448_IMU::CalibrationTime::_2s,
      "2 s calibration time.")
  
    .value("_4s", frc::ADIS16448_IMU::CalibrationTime::_4s,
      "4 s calibration time.")
  
    .value("_8s", frc::ADIS16448_IMU::CalibrationTime::_8s,
      "8 s calibration time.")
  
    .value("_16s", frc::ADIS16448_IMU::CalibrationTime::_16s,
      "16 s calibration time.")
  
    .value("_32s", frc::ADIS16448_IMU::CalibrationTime::_32s,
      "32 s calibration time.")
  
    .value("_64s", frc::ADIS16448_IMU::CalibrationTime::_64s,
      "64 s calibration time.")
  ;

  
    cls_ADIS16448_IMU_enum2
  
    .value("kX", frc::ADIS16448_IMU::IMUAxis::kX,
      "The IMU's X axis.")
  
    .value("kY", frc::ADIS16448_IMU::IMUAxis::kY,
      "The IMU's Y axis.")
  
    .value("kZ", frc::ADIS16448_IMU::IMUAxis::kZ,
      "The IMU's Z axis.")
  ;

  

    
    
  }

void finish() {





  {
  
  
  using CalibrationTime [[maybe_unused]] = typename frc::ADIS16448_IMU::CalibrationTime;
  
  using IMUAxis [[maybe_unused]] = typename frc::ADIS16448_IMU::IMUAxis;
  
  


  

  

  cls_ADIS16448_IMU
  
    
  .def(py::init<>(), release_gil(), py::doc(
    "IMU constructor on onboard MXP CS0, Z-up orientation, and complementary\n"
"AHRS computation.")
  )
  
  
  
    
  .def(py::init<IMUAxis, SPI::Port, CalibrationTime>(),
      py::arg("yaw_axis"), py::arg("port"), py::arg("cal_time"), release_gil(), py::doc(
    "IMU constructor on the specified MXP port and orientation.\n"
"\n"
":param yaw_axis: The axis where gravity is present. Valid options are kX,\n"
"                 kY, and kZ\n"
":param port:     The SPI port where the IMU is connected.\n"
":param cal_time: The calibration time that should be used on start-up.")
  )
  
  
  
    
  .
def
("calibrate", &frc::ADIS16448_IMU::Calibrate, release_gil(), py::doc(
    "Initialize the IMU.\n"
"\n"
"Perform gyro offset calibration by collecting data for a number of seconds\n"
"and computing the center value. The center value is subtracted from\n"
"subsequent measurements.\n"
"\n"
"It's important to make sure that the robot is not moving while the\n"
"centering calculations are in progress, this is typically done when the\n"
"robot is first turned on while it's sitting at rest before the match\n"
"starts.\n"
"\n"
"The calibration routine can be triggered by the user during runtime.")
  )
  
  
  
    
  .
def
("configCalTime", &frc::ADIS16448_IMU::ConfigCalTime,
      py::arg("new_cal_time"), release_gil(), py::doc(
    "Configures the calibration time used for the next calibrate.\n"
"\n"
":param new_cal_time: The calibration time that should be used")
  )
  
  
  
    
  .
def
("reset", &frc::ADIS16448_IMU::Reset, release_gil(), py::doc(
    "Reset the gyro.\n"
"\n"
"Resets the gyro accumulations to a heading of zero. This can be used if\n"
"there is significant drift in the gyro and it needs to be recalibrated\n"
"after running.")
  )
  
  
  
    
  .
def
("getAngle", &frc::ADIS16448_IMU::GetAngle, release_gil(), py::doc(
    "Returns the yaw axis angle in degrees (CCW positive).")
  )
  
  
  
    
  .
def
("getRate", &frc::ADIS16448_IMU::GetRate, release_gil(), py::doc(
    "Returns the yaw axis angular rate in degrees per second (CCW positive).")
  )
  
  
  
    
  .
def
("getGyroAngleX", &frc::ADIS16448_IMU::GetGyroAngleX, release_gil(), py::doc(
    "Returns the accumulated gyro angle in the X axis.")
  )
  
  
  
    
  .
def
("getGyroAngleY", &frc::ADIS16448_IMU::GetGyroAngleY, release_gil(), py::doc(
    "Returns the accumulated gyro angle in the Y axis.")
  )
  
  
  
    
  .
def
("getGyroAngleZ", &frc::ADIS16448_IMU::GetGyroAngleZ, release_gil(), py::doc(
    "Returns the accumulated gyro angle in the Z axis.")
  )
  
  
  
    
  .
def
("getGyroRateX", &frc::ADIS16448_IMU::GetGyroRateX, release_gil(), py::doc(
    "Returns the angular rate in the X axis.")
  )
  
  
  
    
  .
def
("getGyroRateY", &frc::ADIS16448_IMU::GetGyroRateY, release_gil(), py::doc(
    "Returns the angular rate in the Y axis.")
  )
  
  
  
    
  .
def
("getGyroRateZ", &frc::ADIS16448_IMU::GetGyroRateZ, release_gil(), py::doc(
    "Returns the angular rate in the Z axis.")
  )
  
  
  
    
  .
def
("getAccelX", &frc::ADIS16448_IMU::GetAccelX, release_gil(), py::doc(
    "Returns the acceleration in the X axis.")
  )
  
  
  
    
  .
def
("getAccelY", &frc::ADIS16448_IMU::GetAccelY, release_gil(), py::doc(
    "Returns the acceleration in the Y axis.")
  )
  
  
  
    
  .
def
("getAccelZ", &frc::ADIS16448_IMU::GetAccelZ, release_gil(), py::doc(
    "Returns the acceleration in the Z axis.")
  )
  
  
  
    
  .
def
("getXComplementaryAngle", &frc::ADIS16448_IMU::GetXComplementaryAngle, release_gil(), py::doc(
    "Returns the complementary angle around the X axis computed from\n"
"accelerometer and gyro rate measurements.")
  )
  
  
  
    
  .
def
("getYComplementaryAngle", &frc::ADIS16448_IMU::GetYComplementaryAngle, release_gil(), py::doc(
    "Returns the complementary angle around the Y axis computed from\n"
"accelerometer and gyro rate measurements.")
  )
  
  
  
    
  .
def
("getXFilteredAccelAngle", &frc::ADIS16448_IMU::GetXFilteredAccelAngle, release_gil(), py::doc(
    "Returns the X-axis filtered acceleration angle.")
  )
  
  
  
    
  .
def
("getYFilteredAccelAngle", &frc::ADIS16448_IMU::GetYFilteredAccelAngle, release_gil(), py::doc(
    "Returns the Y-axis filtered acceleration angle.")
  )
  
  
  
    
  .
def
("getMagneticFieldX", &frc::ADIS16448_IMU::GetMagneticFieldX, release_gil(), py::doc(
    "Returns the magnetic field strength in the X axis.")
  )
  
  
  
    
  .
def
("getMagneticFieldY", &frc::ADIS16448_IMU::GetMagneticFieldY, release_gil(), py::doc(
    "Returns the magnetic field strength in the Y axis.")
  )
  
  
  
    
  .
def
("getMagneticFieldZ", &frc::ADIS16448_IMU::GetMagneticFieldZ, release_gil(), py::doc(
    "Returns the magnetic field strength in the Z axis.")
  )
  
  
  
    
  .
def
("getBarometricPressure", &frc::ADIS16448_IMU::GetBarometricPressure, release_gil(), py::doc(
    "Returns the barometric pressure.")
  )
  
  
  
    
  .
def
("getTemperature", &frc::ADIS16448_IMU::GetTemperature, release_gil(), py::doc(
    "Returns the temperature.")
  )
  
  
  
    
  .
def
("getYawAxis", &frc::ADIS16448_IMU::GetYawAxis, release_gil()
  )
  
  
  
    
  .
def
("setYawAxis", &frc::ADIS16448_IMU::SetYawAxis,
      py::arg("yaw_axis"), release_gil()
  )
  
  
  
    
  .
def
("isConnected", &frc::ADIS16448_IMU::IsConnected, release_gil(), py::doc(
    "Checks the connection status of the IMU.\n"
"\n"
":returns: True if the IMU is connected, false otherwise.")
  )
  
  
  
    
  .
def
("configDecRate", &frc::ADIS16448_IMU::ConfigDecRate,
      py::arg("decimationRate"), release_gil(), py::doc(
    "Configures the decimation rate of the IMU.\n"
"\n"
":param decimationRate: The new decimation value.\n"
"\n"
":returns: 0 if success, 1 if no change, 2 if error.")
  )
  
  
  
    
  .
def
("getPort", &frc::ADIS16448_IMU::GetPort, release_gil(), py::doc(
    "Get the SPI port number.\n"
"\n"
":returns: The SPI port number.")
  )
  
  
  
    
  .
def
("initSendable", &frc::ADIS16448_IMU::InitSendable,
      py::arg("builder"), release_gil()
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_ADIS16448_IMU_initializer

static std::unique_ptr<rpybuild_ADIS16448_IMU_initializer> cls;

void begin_init_ADIS16448_IMU(py::module &m) {
  cls = std::make_unique<rpybuild_ADIS16448_IMU_initializer>(m);
}

void finish_init_ADIS16448_IMU() {
  cls->finish();
  cls.reset();
}