
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/Ultrasonic.h>


#include <units_length_type_caster.h>







#define RPYGEN_ENABLE_frc__Ultrasonic_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__Ultrasonic.hpp>







#include <wpi/sendable/SendableBuilder.h>

#include <frc/DigitalInput.h>

#include <frc/DigitalOutput.h>



#include <type_traits>


  using namespace frc;





struct rpybuild_Ultrasonic_initializer {


  

  












  
  using Ultrasonic_Trampoline = rpygen::PyTrampoline_frc__Ultrasonic<typename frc::Ultrasonic, typename rpygen::PyTrampolineCfg_frc__Ultrasonic<>>;
    static_assert(std::is_abstract<Ultrasonic_Trampoline>::value == false, "frc::Ultrasonic " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::Ultrasonic, Ultrasonic_Trampoline, wpi::Sendable> cls_Ultrasonic;

    

    
    

  py::module &m;

  
  rpybuild_Ultrasonic_initializer(py::module &m) :

  

  

  

  
    cls_Ultrasonic(m, "Ultrasonic"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_Ultrasonic.doc() =
    "Ultrasonic rangefinder class.\n"
"\n"
"The Ultrasonic rangefinder measures absolute distance based on the round-trip\n"
"time of a ping generated by the controller. These sensors use two\n"
"transducers, a speaker and a microphone both tuned to the ultrasonic range. A\n"
"common ultrasonic sensor, the Daventech SRF04 requires a short pulse to be\n"
"generated on a digital channel. This causes the chirp to be emitted. A second\n"
"line becomes high as the ping is transmitted and goes low when the echo is\n"
"received. The time that the line is high determines the round trip distance\n"
"(time of flight).";

  cls_Ultrasonic
  
    
  .def(py::init<int, int>(),
      py::arg("pingChannel"), py::arg("echoChannel"), release_gil(), py::doc(
    "Create an instance of the Ultrasonic Sensor.\n"
"\n"
"This is designed to support the Daventech SRF04 and Vex ultrasonic sensors.\n"
"\n"
":param pingChannel: The digital output channel that sends the pulse to\n"
"                    initiate the sensor sending the ping.\n"
":param echoChannel: The digital input channel that receives the echo. The\n"
"                    length of time that the echo is high represents the\n"
"                    round trip time of the ping, and the distance.")
  )
  
  
  
    
  .def(py::init<std::shared_ptr<DigitalOutput>, std::shared_ptr<DigitalInput>>(),
      py::arg("pingChannel"), py::arg("echoChannel"), release_gil(), py::doc(
    "Create an instance of an Ultrasonic Sensor from a DigitalInput for the echo\n"
"channel and a DigitalOutput for the ping channel.\n"
"\n"
":param pingChannel: The digital output object that starts the sensor doing a\n"
"                    ping. Requires a 10uS pulse to start.\n"
":param echoChannel: The digital input object that times the return pulse to\n"
"                    determine the range.")
  )
  
  
  
    
  .
def
("getEchoChannel", &frc::Ultrasonic::GetEchoChannel, release_gil(), py::doc(
    "Returns the echo channel.\n"
"\n"
":returns: The echo channel.")
  )
  
  
  
    
  .
def
("ping", &frc::Ultrasonic::Ping, release_gil(), py::doc(
    "Single ping to ultrasonic sensor.\n"
"\n"
"Send out a single ping to the ultrasonic sensor. This only works if\n"
"automatic (round robin) mode is disabled. A single ping is sent out, and\n"
"the counter should count the semi-period when it comes in. The counter is\n"
"reset to make the current value invalid.")
  )
  
  
  
    
  .
def
("isRangeValid", &frc::Ultrasonic::IsRangeValid, release_gil(), py::doc(
    "Check if there is a valid range measurement.\n"
"\n"
"The ranges are accumulated in a counter that will increment on each edge of\n"
"the echo (return) signal. If the count is not at least 2, then the range\n"
"has not yet been measured, and is invalid.")
  )
  
  
  
    
  .
def_static
("setAutomaticMode", &frc::Ultrasonic::SetAutomaticMode,
      py::arg("enabling"), release_gil(), py::doc(
    "Turn Automatic mode on/off.\n"
"\n"
"When in Automatic mode, all sensors will fire in round robin, waiting a set\n"
"time between each sensor.\n"
"\n"
":param enabling: Set to true if round robin scheduling should start for all\n"
"                 the ultrasonic sensors. This scheduling method assures that\n"
"                 the sensors are non-interfering because no two sensors fire\n"
"                 at the same time. If another scheduling algorithm is\n"
"                 preferred, it can be implemented by pinging the sensors\n"
"                 manually and waiting for the results to come back.")
  )
  
  
  
    
  .
def
("getRange", &frc::Ultrasonic::GetRange, release_gil(), py::doc(
    "Get the range from the ultrasonic sensor.\n"
"\n"
":returns: Range of the target returned from the ultrasonic sensor. If there\n"
"          is no valid value yet, i.e. at least one measurement hasn't\n"
"          completed, then return 0.")
  )
  
  
  
    
  .
def
("isEnabled", &frc::Ultrasonic::IsEnabled, release_gil()
  )
  
  
  
    
  .
def
("setEnabled", &frc::Ultrasonic::SetEnabled,
      py::arg("enable"), release_gil()
  )
  
  
  
    
  .
def
("initSendable", &frc::Ultrasonic::InitSendable,
      py::arg("builder"), release_gil()
  )
  
  
  ;

  


  }







  cls_Ultrasonic
  .def("getRangeMM", [](const frc::Ultrasonic &self) -> units::millimeter_t {
    return self.GetRange();
  })
  .def("getRangeInches", [](const frc::Ultrasonic &self) -> units::inch_t {
    return self.GetRange();
  })
;


}

}; // struct rpybuild_Ultrasonic_initializer

static std::unique_ptr<rpybuild_Ultrasonic_initializer> cls;

void begin_init_Ultrasonic(py::module &m) {
  cls = std::make_unique<rpybuild_Ultrasonic_initializer>(m);
}

void finish_init_Ultrasonic() {
  cls->finish();
  cls.reset();
}