
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/I2C.h>
















#include <type_traits>


  using namespace frc;



struct rpybuild_I2C_initializer {


  

  












  py::class_<typename frc::I2C> cls_I2C;

    
    
  py::enum_<frc::I2C::Port> cls_I2C_enum1;
    

    
    

  py::module &m;

  
  rpybuild_I2C_initializer(py::module &m) :

  

  

  

  
    cls_I2C(m, "I2C"),

  
    cls_I2C_enum1
  (cls_I2C, "Port"
  ,
    "I2C connection ports."),
  

  
  
  

    m(m)
  {
    
    

    
    
  
    cls_I2C_enum1
  
    .value("kOnboard", frc::I2C::Port::kOnboard,
      "Onboard I2C port.")
  
    .value("kMXP", frc::I2C::Port::kMXP,
      "MXP (roboRIO MXP) I2C port.")
  ;

  

    
    
  }

void finish() {





  {
  
  
  using Port [[maybe_unused]] = typename frc::I2C::Port;
  
  


  

  cls_I2C.doc() =
    "I2C bus interface class.\n"
"\n"
"This class is intended to be used by sensor (and other I2C device) drivers.\n"
"It probably should not be used directly.\n"
"\n"
"The Onboard I2C port is subject to system lockups. See <a\n"
"href=\"https://docs.wpilib.org/en/stable/docs/yearly-overview/known-issues.html#onboard-i2c-causing-system-lockups\">\n"
"WPILib Known Issues</a> page for details.";

  cls_I2C
  
    
  .def(py::init<Port, int>(),
      py::arg("port"), py::arg("deviceAddress"), release_gil(), py::doc(
    "Constructor.\n"
"\n"
":param port:          The I2C port to which the device is connected.\n"
":param deviceAddress: The address of the device on the I2C bus.")
  )
  
  
  
    
  .
def
("getPort", &frc::I2C::GetPort, release_gil(), py::doc(
    "Returns I2C port.\n"
"\n"
":returns: I2C port.")
  )
  
  
  
    
  .
def
("getDeviceAddress", &frc::I2C::GetDeviceAddress, release_gil(), py::doc(
    "Returns I2C device address.\n"
"\n"
":returns: I2C device address.")
  )
  
  
  
    
  .
def
("transaction", [](frc::I2C * __that,const py::buffer& dataToSend, const py::buffer& dataReceived) {
                    int sendSize;
          int receiveSize;
          auto __dataToSend = dataToSend.request(false);
          sendSize = __dataToSend.size * __dataToSend.itemsize;
          auto __dataReceived = dataReceived.request(true);
          receiveSize = __dataReceived.size * __dataReceived.itemsize;
          auto __ret =__that->Transaction((uint8_t*)__dataToSend.ptr, sendSize, (uint8_t*)__dataReceived.ptr, receiveSize);
          return __ret;
        },
      py::arg("dataToSend"), py::arg("dataReceived"), release_gil(), py::doc(
    "Generic transaction.\n"
"\n"
"This is a lower-level interface to the I2C hardware giving you more control\n"
"over each transaction. If you intend to write multiple bytes in the same\n"
"transaction and do not plan to receive anything back, use writeBulk()\n"
"instead. Calling this with a receiveSize of 0 will result in an error.\n"
"\n"
":param dataToSend:   Buffer of data to send as part of the transaction.\n"
":param sendSize:     Number of bytes to send as part of the transaction.\n"
":param dataReceived: Buffer to read data into.\n"
":param receiveSize:  Number of bytes to read from the device.\n"
"\n"
":returns: Transfer Aborted... false for success, true for aborted.")
  )
  
  
  
    
  .
def
("addressOnly", &frc::I2C::AddressOnly, release_gil(), py::doc(
    "Attempt to address a device on the I2C bus.\n"
"\n"
"This allows you to figure out if there is a device on the I2C bus that\n"
"responds to the address specified in the constructor.\n"
"\n"
":returns: Transfer Aborted... false for success, true for aborted.")
  )
  
  
  
    
  .
def
("write", &frc::I2C::Write,
      py::arg("registerAddress"), py::arg("data"), release_gil(), py::doc(
    "Execute a write transaction with the device.\n"
"\n"
"Write a single byte to a register on a device and wait until the\n"
"transaction is complete.\n"
"\n"
":param registerAddress: The address of the register on the device to be\n"
"                        written.\n"
":param data:            The byte to write to the register on the device.\n"
"\n"
":returns: Transfer Aborted... false for success, true for aborted.")
  )
  
  
  
    
  .
def
("writeBulk", [](frc::I2C * __that,const py::buffer& data) {
                    int count;
          auto __data = data.request(false);
          count = __data.size * __data.itemsize;
          auto __ret =__that->WriteBulk((uint8_t*)__data.ptr, count);
          return __ret;
        },
      py::arg("data"), release_gil(), py::doc(
    "Execute a bulk write transaction with the device.\n"
"\n"
"Write multiple bytes to a device and wait until the\n"
"transaction is complete.\n"
"\n"
":param data:  The data to write to the register on the device.\n"
":param count: The number of bytes to be written.\n"
"\n"
":returns: Transfer Aborted... false for success, true for aborted.")
  )
  
  
  
    
  .
def
("read", [](frc::I2C * __that,int registerAddress, const py::buffer& data) {
                    int count;
          auto __data = data.request(true);
          count = __data.size * __data.itemsize;
          auto __ret =__that->Read(std::move(registerAddress), count, (uint8_t*)__data.ptr);
          return __ret;
        },
      py::arg("registerAddress"), py::arg("data"), release_gil(), py::doc(
    "Execute a read transaction with the device.\n"
"\n"
"Read bytes from a device.\n"
"Most I2C devices will auto-increment the register pointer internally\n"
"allowing you to read consecutive registers on a device in a single\n"
"transaction.\n"
"\n"
":param registerAddress: The register to read first in the transaction.\n"
":param count:           The number of bytes to read in the transaction.\n"
":param data:            A pointer to the array of bytes to store the data\n"
"                        read from the device.\n"
"\n"
":returns: Transfer Aborted... false for success, true for aborted.")
  )
  
  
  
    
  .
def
("readOnly", [](frc::I2C * __that,const py::buffer& buffer) {
                    int count;
          auto __buffer = buffer.request(true);
          count = __buffer.size * __buffer.itemsize;
          auto __ret =__that->ReadOnly(count, (uint8_t*)__buffer.ptr);
          return __ret;
        },
      py::arg("buffer"), release_gil(), py::doc(
    "Execute a read only transaction with the device.\n"
"\n"
"Read bytes from a device. This method does not write any data to prompt the\n"
"device.\n"
"\n"
":param buffer: A pointer to the array of bytes to store the data read from\n"
"               the device.\n"
":param count:  The number of bytes to read in the transaction.\n"
"\n"
":returns: Transfer Aborted... false for success, true for aborted.")
  )
  
  
  
    
  .
def
("verifySensor", [](frc::I2C * __that,int registerAddress, const py::buffer& expected) {
                    int count;
          auto __expected = expected.request(false);
          count = __expected.size * __expected.itemsize;
          auto __ret =__that->VerifySensor(std::move(registerAddress), count, (const uint8_t*)__expected.ptr);
          return __ret;
        },
      py::arg("registerAddress"), py::arg("expected"), release_gil(), py::doc(
    "Verify that a device's registers contain expected values.\n"
"\n"
"Most devices will have a set of registers that contain a known value that\n"
"can be used to identify them.  This allows an I2C device driver to easily\n"
"verify that the device contains the expected value.\n"
"\n"
"@pre The device must support and be configured to use register\n"
"auto-increment.\n"
"\n"
":param registerAddress: The base register to start reading from the device.\n"
":param count:           The size of the field to be verified.\n"
":param expected:        A buffer containing the values expected from the\n"
"                        device.")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_I2C_initializer

static std::unique_ptr<rpybuild_I2C_initializer> cls;

void begin_init_I2C(py::module &m) {
  cls = std::make_unique<rpybuild_I2C_initializer>(m);
}

void finish_init_I2C() {
  cls->finish();
  cls.reset();
}