
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/AnalogTrigger.h>








#define RPYGEN_ENABLE_frc__AnalogTrigger_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__AnalogTrigger.hpp>







#include <wpi/sendable/SendableBuilder.h>

#include <frc/AnalogInput.h>

#include <frc/DutyCycle.h>



#include <type_traits>


  using namespace frc;



struct rpybuild_AnalogTrigger_initializer {


  

  












  
  using AnalogTrigger_Trampoline = rpygen::PyTrampoline_frc__AnalogTrigger<typename frc::AnalogTrigger, typename rpygen::PyTrampolineCfg_frc__AnalogTrigger<>>;
    static_assert(std::is_abstract<AnalogTrigger_Trampoline>::value == false, "frc::AnalogTrigger " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::AnalogTrigger, AnalogTrigger_Trampoline, wpi::Sendable> cls_AnalogTrigger;

    

    
    

  py::module &m;

  
  rpybuild_AnalogTrigger_initializer(py::module &m) :

  

  

  

  
    cls_AnalogTrigger(m, "AnalogTrigger"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  

  cls_AnalogTrigger
  
    
  .def(py::init<int>(),
      py::arg("channel"), release_gil(), py::doc(
    "Constructor for an analog trigger given a channel number.\n"
"\n"
":param channel: The channel number on the roboRIO to represent. 0-3 are\n"
"                on-board 4-7 are on the MXP port.")
  )
  
  
  
    
  .def(py::init<std::shared_ptr<AnalogInput>>(),
      py::arg("input"), release_gil(), py::doc(
    "Construct an analog trigger using an existing analog input.\n"
"\n"
"This should be used in the case of sharing an analog channel between the\n"
"trigger and an analog input object.\n"
"\n"
":param input: A shared_ptr to the existing AnalogInput object")
  )
  
  
  
    
  .def(py::init<std::shared_ptr<DutyCycle>>(),
      py::arg("dutyCycle"), release_gil(), py::doc(
    "Construct an analog trigger using an existing duty cycle input.\n"
"\n"
":param dutyCycle: A shared_ptr to the existing DutyCycle object")
  )
  
  
  
    
  .
def
("setLimitsVoltage", &frc::AnalogTrigger::SetLimitsVoltage,
      py::arg("lower"), py::arg("upper"), release_gil(), py::doc(
    "Set the upper and lower limits of the analog trigger.\n"
"\n"
"The limits are given as floating point voltage values.\n"
"\n"
":param lower: The lower limit of the trigger in Volts.\n"
":param upper: The upper limit of the trigger in Volts.")
  )
  
  
  
    
  .
def
("setLimitsDutyCycle", &frc::AnalogTrigger::SetLimitsDutyCycle,
      py::arg("lower"), py::arg("upper"), release_gil(), py::doc(
    "Set the upper and lower duty cycle limits of the analog trigger.\n"
"\n"
"The limits are given as floating point values between 0 and 1.\n"
"\n"
":param lower: The lower limit of the trigger in percentage.\n"
":param upper: The upper limit of the trigger in percentage.")
  )
  
  
  
    
  .
def
("setLimitsRaw", &frc::AnalogTrigger::SetLimitsRaw,
      py::arg("lower"), py::arg("upper"), release_gil(), py::doc(
    "Set the upper and lower limits of the analog trigger.\n"
"\n"
"The limits are given in ADC codes.  If oversampling is used, the units must\n"
"be scaled appropriately.\n"
"\n"
":param lower: The lower limit of the trigger in ADC codes (12-bit values).\n"
":param upper: The upper limit of the trigger in ADC codes (12-bit values).")
  )
  
  
  
    
  .
def
("setAveraged", &frc::AnalogTrigger::SetAveraged,
      py::arg("useAveragedValue"), release_gil(), py::doc(
    "Configure the analog trigger to use the averaged vs. raw values.\n"
"\n"
"If the value is true, then the averaged value is selected for the analog\n"
"trigger, otherwise the immediate value is used.\n"
"\n"
":param useAveragedValue: If true, use the Averaged value, otherwise use the\n"
"                         instantaneous reading")
  )
  
  
  
    
  .
def
("setFiltered", &frc::AnalogTrigger::SetFiltered,
      py::arg("useFilteredValue"), release_gil(), py::doc(
    "Configure the analog trigger to use a filtered value.\n"
"\n"
"The analog trigger will operate with a 3 point average rejection filter.\n"
"This is designed to help with 360 degree pot applications for the period\n"
"where the pot crosses through zero.\n"
"\n"
":param useFilteredValue: If true, use the 3 point rejection filter,\n"
"                         otherwise use the unfiltered value")
  )
  
  
  
    
  .
def
("getIndex", &frc::AnalogTrigger::GetIndex, release_gil(), py::doc(
    "Return the index of the analog trigger.\n"
"\n"
"This is the FPGA index of this analog trigger instance.\n"
"\n"
":returns: The index of the analog trigger.")
  )
  
  
  
    
  .
def
("getInWindow", &frc::AnalogTrigger::GetInWindow, release_gil(), py::doc(
    "Return the InWindow output of the analog trigger.\n"
"\n"
"True if the analog input is between the upper and lower limits.\n"
"\n"
":returns: True if the analog input is between the upper and lower limits.")
  )
  
  
  
    
  .
def
("getTriggerState", &frc::AnalogTrigger::GetTriggerState, release_gil(), py::doc(
    "Return the TriggerState output of the analog trigger.\n"
"\n"
"True if above upper limit.\n"
"False if below lower limit.\n"
"If in Hysteresis, maintain previous state.\n"
"\n"
":returns: True if above upper limit. False if below lower limit. If in\n"
"          Hysteresis, maintain previous state.")
  )
  
  
  
    
  .
def
("createOutput", &frc::AnalogTrigger::CreateOutput,
      py::arg("type"), release_gil(), py::doc(
    "Creates an AnalogTriggerOutput object.\n"
"\n"
":param type: An enum of the type of output object to create.\n"
"\n"
":returns: A pointer to a new AnalogTriggerOutput object.")
  )
  
  
  
    
  .
def
("initSendable", &frc::AnalogTrigger::InitSendable,
      py::arg("builder"), release_gil()
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_AnalogTrigger_initializer

static std::unique_ptr<rpybuild_AnalogTrigger_initializer> cls;

void begin_init_AnalogTrigger(py::module &m) {
  cls = std::make_unique<rpybuild_AnalogTrigger_initializer>(m);
}

void finish_init_AnalogTrigger() {
  cls->finish();
  cls.reset();
}