
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/CAN.h>
















#include <type_traits>


  using namespace frc;





struct rpybuild_CAN_initializer {


  

  


  

  












  py::class_<typename frc::CANData> cls_CANData;

    

    
    
  py::class_<typename frc::CAN> cls_CAN;

    

    
    

  py::module &m;

  
  rpybuild_CAN_initializer(py::module &m) :

  

  

  

  
    cls_CANData(m, "CANData"),

  

  
  
  
    cls_CAN(m, "CAN"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  

  cls_CANData
  
    .def(py::init<>(), release_gil())
  
    .def_property_readonly("data", [](frc::CANData& inst) {
        return py::memoryview::from_buffer(
          &inst.data, sizeof(uint8_t),
          py::format_descriptor<uint8_t>::value,
          {8}, {sizeof(uint8_t)},
          false
        );
    }, py::doc(
    "Contents of the CAN packet."))
  
    .def_readwrite("length", &frc::CANData::length, py::doc(
    "Length of packet in bytes."))
  
    .def_readwrite("timestamp", &frc::CANData::timestamp, py::doc(
    "CAN frame timestamp in milliseconds."))
  ;

  


  }

  {
  
  
  
    static constexpr auto kTeamManufacturer [[maybe_unused]] = frc::CAN::kTeamManufacturer;
  
    static constexpr auto kTeamDeviceType [[maybe_unused]] = frc::CAN::kTeamDeviceType;
  


  

  cls_CAN.doc() =
    "High level class for interfacing with CAN devices conforming to\n"
"the standard CAN spec.\n"
"\n"
"No packets that can be sent gets blocked by the RoboRIO, so all methods\n"
"work identically in all robot modes.\n"
"\n"
"All methods are thread save, however the buffer objects passed in\n"
"by the user need to not be modified for the duration of their calls.";

  cls_CAN
  
    
  .def(py::init<int>(),
      py::arg("deviceId"), release_gil(), py::doc(
    "Create a new CAN communication interface with the specific device ID.\n"
"This uses the team manufacturer and device types.\n"
"The device ID is 6 bits (0-63)\n"
"\n"
":param deviceId: The device id")
  )
  
  
  
    
  .def(py::init<int, int, int>(),
      py::arg("deviceId"), py::arg("deviceManufacturer"), py::arg("deviceType"), release_gil(), py::doc(
    "Create a new CAN communication interface with a specific device ID,\n"
"manufacturer and device type. The device ID is 6 bits, the\n"
"manufacturer is 8 bits, and the device type is 5 bits.\n"
"\n"
":param deviceId:           The device ID\n"
":param deviceManufacturer: The device manufacturer\n"
":param deviceType:         The device type")
  )
  
  
  
    
  .
def
("writePacket", [](frc::CAN * __that,const py::buffer& data, int apiId) {
                    int length;
          auto __data = data.request(false);
          length = __data.size * __data.itemsize;
          __that->WritePacket((const uint8_t*)__data.ptr, length, std::move(apiId));
          
        },
      py::arg("data"), py::arg("apiId"), release_gil(), py::doc(
    "Write a packet to the CAN device with a specific ID. This ID is 10 bits.\n"
"\n"
":param data:   The data to write (8 bytes max)\n"
":param length: The data length to write\n"
":param apiId:  The API ID to write.")
  )
  
  
  
    
  .
def
("writePacketRepeating", [](frc::CAN * __that,const py::buffer& data, int apiId, int repeatMs) {
                    int length;
          auto __data = data.request(false);
          length = __data.size * __data.itemsize;
          __that->WritePacketRepeating((const uint8_t*)__data.ptr, length, std::move(apiId), std::move(repeatMs));
          
        },
      py::arg("data"), py::arg("apiId"), py::arg("repeatMs"), release_gil(), py::doc(
    "Write a repeating packet to the CAN device with a specific ID. This ID is\n"
"10 bits. The RoboRIO will automatically repeat the packet at the specified\n"
"interval\n"
"\n"
":param data:     The data to write (8 bytes max)\n"
":param length:   The data length to write\n"
":param apiId:    The API ID to write.\n"
":param repeatMs: The period to repeat the packet at.")
  )
  
  
  
    
  .
def
("writeRTRFrame", &frc::CAN::WriteRTRFrame,
      py::arg("length"), py::arg("apiId"), release_gil(), py::doc(
    "Write an RTR frame to the CAN device with a specific ID. This ID is 10\n"
"bits. The length by spec must match what is returned by the responding\n"
"device\n"
"\n"
":param length: The length to request (0 to 8)\n"
":param apiId:  The API ID to write.")
  )
  
  
  
    
  .
def
("writePacketNoError", [](frc::CAN * __that,const py::buffer& data, int apiId) {
                    int length;
          auto __data = data.request(false);
          length = __data.size * __data.itemsize;
          auto __ret =__that->WritePacketNoError((const uint8_t*)__data.ptr, length, std::move(apiId));
          return __ret;
        },
      py::arg("data"), py::arg("apiId"), release_gil(), py::doc(
    "Write a packet to the CAN device with a specific ID. This ID is 10 bits.\n"
"\n"
":param data:   The data to write (8 bytes max)\n"
":param length: The data length to write\n"
":param apiId:  The API ID to write.")
  )
  
  
  
    
  .
def
("writePacketRepeatingNoError", [](frc::CAN * __that,const py::buffer& data, int apiId, int repeatMs) {
                    int length;
          auto __data = data.request(false);
          length = __data.size * __data.itemsize;
          auto __ret =__that->WritePacketRepeatingNoError((const uint8_t*)__data.ptr, length, std::move(apiId), std::move(repeatMs));
          return __ret;
        },
      py::arg("data"), py::arg("apiId"), py::arg("repeatMs"), release_gil(), py::doc(
    "Write a repeating packet to the CAN device with a specific ID. This ID is\n"
"10 bits. The RoboRIO will automatically repeat the packet at the specified\n"
"interval\n"
"\n"
":param data:     The data to write (8 bytes max)\n"
":param length:   The data length to write\n"
":param apiId:    The API ID to write.\n"
":param repeatMs: The period to repeat the packet at.")
  )
  
  
  
    
  .
def
("writeRTRFrameNoError", &frc::CAN::WriteRTRFrameNoError,
      py::arg("length"), py::arg("apiId"), release_gil(), py::doc(
    "Write an RTR frame to the CAN device with a specific ID. This ID is 10\n"
"bits. The length by spec must match what is returned by the responding\n"
"device\n"
"\n"
":param length: The length to request (0 to 8)\n"
":param apiId:  The API ID to write.")
  )
  
  
  
    
  .
def
("stopPacketRepeating", &frc::CAN::StopPacketRepeating,
      py::arg("apiId"), release_gil(), py::doc(
    "Stop a repeating packet with a specific ID. This ID is 10 bits.\n"
"\n"
":param apiId: The API ID to stop repeating")
  )
  
  
  
    
  .
def
("readPacketNew", &frc::CAN::ReadPacketNew,
      py::arg("apiId"), py::arg("data"), release_gil(), py::doc(
    "Read a new CAN packet. This will only return properly once per packet\n"
"received. Multiple calls without receiving another packet will return\n"
"false.\n"
"\n"
":param apiId: The API ID to read.\n"
":param data:  Storage for the received data.\n"
"\n"
":returns: True if the data is valid, otherwise false.")
  )
  
  
  
    
  .
def
("readPacketLatest", &frc::CAN::ReadPacketLatest,
      py::arg("apiId"), py::arg("data"), release_gil(), py::doc(
    "Read a CAN packet. The will continuously return the last packet received,\n"
"without accounting for packet age.\n"
"\n"
":param apiId: The API ID to read.\n"
":param data:  Storage for the received data.\n"
"\n"
":returns: True if the data is valid, otherwise false.")
  )
  
  
  
    
  .
def
("readPacketTimeout", &frc::CAN::ReadPacketTimeout,
      py::arg("apiId"), py::arg("timeoutMs"), py::arg("data"), release_gil(), py::doc(
    "Read a CAN packet. The will return the last packet received until the\n"
"packet is older then the requested timeout. Then it will return false.\n"
"\n"
":param apiId:     The API ID to read.\n"
":param timeoutMs: The timeout time for the packet\n"
":param data:      Storage for the received data.\n"
"\n"
":returns: True if the data is valid, otherwise false.")
  )
  
  
  
    
  .
def_static
("getTimestampBaseTime", &frc::CAN::GetTimestampBaseTime, release_gil(), py::doc(
    "Reads the current value of the millisecond-resolution timer that CANData\n"
"timestamps are based on\n"
"\n"
":returns: Current value of timer used as a base time for CANData timestamps\n"
"          in milliseconds")
  )
  
  
  
    .def_readonly_static("kTeamManufacturer", &frc::CAN::kTeamManufacturer, py::doc(
    "Team manufacturer."))
  
    .def_readonly_static("kTeamDeviceType", &frc::CAN::kTeamDeviceType, py::doc(
    "Team device type."))
  ;

  


  }






}

}; // struct rpybuild_CAN_initializer

static std::unique_ptr<rpybuild_CAN_initializer> cls;

void begin_init_CAN(py::module &m) {
  cls = std::make_unique<rpybuild_CAN_initializer>(m);
}

void finish_init_CAN() {
  cls->finish();
  cls.reset();
}