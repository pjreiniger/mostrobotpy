
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/PneumaticsBase.h>


#include <units_current_type_caster.h>

#include <units_pressure_type_caster.h>

#include <units_time_type_caster.h>

#include <units_voltage_type_caster.h>







#define RPYGEN_ENABLE_frc__PneumaticsBase_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__PneumaticsBase.hpp>







#include <wpi/sendable/SendableBuilder.h>

#include <frc/Compressor.h>

#include <frc/Solenoid.h>

#include <frc/DoubleSolenoid.h>



#include <type_traits>


  using namespace frc;





struct rpybuild_PneumaticsBase_initializer {


  

  












  
  using PneumaticsBase_Trampoline = rpygen::PyTrampoline_frc__PneumaticsBase<typename frc::PneumaticsBase, typename rpygen::PyTrampolineCfg_frc__PneumaticsBase<>>;
    static_assert(std::is_abstract<PneumaticsBase_Trampoline>::value == false, "frc::PneumaticsBase " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::PneumaticsBase, PneumaticsBase_Trampoline> cls_PneumaticsBase;

    

    
    

  py::module &m;

  
  rpybuild_PneumaticsBase_initializer(py::module &m) :

  

  

  

  
    cls_PneumaticsBase(m, "PneumaticsBase"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_PneumaticsBase.doc() =
    "Base class for pneumatics devices.";

  cls_PneumaticsBase
  
    .def(py::init<>(), release_gil())
  
    
  .
def
("getCompressor", &frc::PneumaticsBase::GetCompressor, release_gil(), py::doc(
    "Returns whether the compressor is active or not.\n"
"\n"
":returns: True if the compressor is on - otherwise false.")
  )
  
  
  
    
  .
def
("getPressureSwitch", &frc::PneumaticsBase::GetPressureSwitch, release_gil(), py::doc(
    "Returns the state of the pressure switch.\n"
"\n"
":returns: True if pressure switch indicates that the system is full,\n"
"          otherwise false.")
  )
  
  
  
    
  .
def
("getCompressorCurrent", &frc::PneumaticsBase::GetCompressorCurrent, release_gil(), py::doc(
    "Returns the current drawn by the compressor.\n"
"\n"
":returns: The current drawn by the compressor.")
  )
  
  
  
    
  .
def
("disableCompressor", &frc::PneumaticsBase::DisableCompressor, release_gil(), py::doc(
    "Disables the compressor.")
  )
  
  
  
    
  .
def
("enableCompressorDigital", &frc::PneumaticsBase::EnableCompressorDigital, release_gil(), py::doc(
    "Enables the compressor in digital mode using the digital pressure switch.\n"
"The compressor will turn on when the pressure switch indicates that the\n"
"system is not full, and will turn off when the pressure switch indicates\n"
"that the system is full.")
  )
  
  
  
    
  .
def
("enableCompressorAnalog", &frc::PneumaticsBase::EnableCompressorAnalog,
      py::arg("minPressure"), py::arg("maxPressure"), release_gil(), py::doc(
    "If supported by the device, enables the compressor in analog mode. This\n"
"mode uses an analog pressure sensor connected to analog channel 0 to cycle\n"
"the compressor. The compressor will turn on when the pressure drops below\n"
"``minPressure`` and will turn off when the pressure reaches {@code\n"
"maxPressure}. This mode is only supported by the REV PH with the REV Analog\n"
"Pressure Sensor connected to analog channel 0.\n"
"\n"
"On CTRE PCM, this will enable digital control.\n"
"\n"
":param minPressure: The minimum pressure. The compressor will turn on\n"
"                    when the pressure drops below this value.\n"
":param maxPressure: The maximum pressure. The compressor will turn\n"
"                    off when the pressure reaches this value.")
  )
  
  
  
    
  .
def
("enableCompressorHybrid", &frc::PneumaticsBase::EnableCompressorHybrid,
      py::arg("minPressure"), py::arg("maxPressure"), release_gil(), py::doc(
    "If supported by the device, enables the compressor in hybrid mode. This\n"
"mode uses both a digital pressure switch and an analog pressure sensor\n"
"connected to analog channel 0 to cycle the compressor. This mode is only\n"
"supported by the REV PH with the REV Analog Pressure Sensor connected to\n"
"analog channel 0.\n"
"\n"
"The compressor will turn on when \\a both:\n"
"\n"
"- The digital pressure switch indicates the system is not full AND\n"
"- The analog pressure sensor indicates that the pressure in the system\n"
"is below the specified minimum pressure.\n"
"\n"
"The compressor will turn off when \\a either:\n"
"\n"
"- The digital pressure switch is disconnected or indicates that the system\n"
"is full OR\n"
"- The pressure detected by the analog sensor is greater than the specified\n"
"maximum pressure.\n"
"\n"
"On CTRE PCM, this will enable digital control.\n"
"\n"
":param minPressure: The minimum pressure. The compressor will turn on\n"
"                    when the pressure drops below this value and the pressure switch indicates\n"
"                    that the system is not full.\n"
":param maxPressure: The maximum pressure. The compressor will turn\n"
"                    off when the pressure reaches this value or the pressure switch is\n"
"                    disconnected or indicates that the system is full.")
  )
  
  
  
    
  .
def
("getCompressorConfigType", &frc::PneumaticsBase::GetCompressorConfigType, release_gil(), py::doc(
    "Returns the active compressor configuration.\n"
"\n"
":returns: The active compressor configuration.")
  )
  
  
  
    
  .
def
("setSolenoids", &frc::PneumaticsBase::SetSolenoids,
      py::arg("mask"), py::arg("values"), release_gil(), py::doc(
    "Sets solenoids on a pneumatics module.\n"
"\n"
":param mask:   bitmask to set\n"
":param values: solenoid values")
  )
  
  
  
    
  .
def
("getSolenoids", &frc::PneumaticsBase::GetSolenoids, release_gil(), py::doc(
    "Gets a bitmask of solenoid values.\n"
"\n"
":returns: solenoid values")
  )
  
  
  
    
  .
def
("getModuleNumber", &frc::PneumaticsBase::GetModuleNumber, release_gil(), py::doc(
    "Get module number for this module.\n"
"\n"
":returns: module number")
  )
  
  
  
    
  .
def
("getSolenoidDisabledList", &frc::PneumaticsBase::GetSolenoidDisabledList, release_gil(), py::doc(
    "Get a bitmask of disabled solenoids.\n"
"\n"
":returns: bitmask of disabled solenoids")
  )
  
  
  
    
  .
def
("fireOneShot", &frc::PneumaticsBase::FireOneShot,
      py::arg("index"), release_gil(), py::doc(
    "Fire a single solenoid shot.\n"
"\n"
":param index: solenoid index")
  )
  
  
  
    
  .
def
("setOneShotDuration", &frc::PneumaticsBase::SetOneShotDuration,
      py::arg("index"), py::arg("duration"), release_gil(), py::doc(
    "Set the duration for a single solenoid shot.\n"
"\n"
":param index:    solenoid index\n"
":param duration: shot duration")
  )
  
  
  
    
  .
def
("checkSolenoidChannel", &frc::PneumaticsBase::CheckSolenoidChannel,
      py::arg("channel"), release_gil(), py::doc(
    "Check if a solenoid channel is valid.\n"
"\n"
":param channel: Channel to check\n"
"\n"
":returns: True if channel exists")
  )
  
  
  
    
  .
def
("checkAndReserveSolenoids", &frc::PneumaticsBase::CheckAndReserveSolenoids,
      py::arg("mask"), release_gil(), py::doc(
    "Check to see if the masked solenoids can be reserved, and if not reserve\n"
"them.\n"
"\n"
":param mask: The bitmask of solenoids to reserve\n"
"\n"
":returns: 0 if successful; mask of solenoids that couldn't be allocated\n"
"          otherwise")
  )
  
  
  
    
  .
def
("unreserveSolenoids", &frc::PneumaticsBase::UnreserveSolenoids,
      py::arg("mask"), release_gil(), py::doc(
    "Unreserve the masked solenoids.\n"
"\n"
":param mask: The bitmask of solenoids to unreserve")
  )
  
  
  
    
  .
def
("reserveCompressor", &frc::PneumaticsBase::ReserveCompressor, release_gil(), py::doc(
    "Reserve the compressor.\n"
"\n"
":returns: true if successful; false if compressor already reserved")
  )
  
  
  
    
  .
def
("unreserveCompressor", &frc::PneumaticsBase::UnreserveCompressor, release_gil(), py::doc(
    "Unreserve the compressor.")
  )
  
  
  
    
  .
def
("getAnalogVoltage", &frc::PneumaticsBase::GetAnalogVoltage,
      py::arg("channel"), release_gil(), py::doc(
    "If supported by the device, returns the raw voltage of the specified analog\n"
"input channel.\n"
"\n"
"This function is only supported by the REV PH. On CTRE PCM, this will\n"
"return 0.\n"
"\n"
":param channel: The analog input channel to read voltage from.\n"
"\n"
":returns: The voltage of the specified analog input channel.")
  )
  
  
  
    
  .
def
("getPressure", &frc::PneumaticsBase::GetPressure,
      py::arg("channel"), release_gil(), py::doc(
    "If supported by the device, returns the pressure read by an analog\n"
"pressure sensor on the specified analog input channel.\n"
"\n"
"This function is only supported by the REV PH. On CTRE PCM, this will\n"
"return 0.\n"
"\n"
":param channel: The analog input channel to read pressure from.\n"
"\n"
":returns: The pressure read by an analog pressure sensor on the\n"
"          specified analog input channel.")
  )
  
  
  
    
  .
def
("makeSolenoid", &frc::PneumaticsBase::MakeSolenoid,
      py::arg("channel"), release_gil(), py::doc(
    "Create a solenoid object for the specified channel.\n"
"\n"
":param channel: solenoid channel\n"
"\n"
":returns: Solenoid object")
  )
  
  
  
    
  .
def
("makeDoubleSolenoid", &frc::PneumaticsBase::MakeDoubleSolenoid,
      py::arg("forwardChannel"), py::arg("reverseChannel"), release_gil(), py::doc(
    "Create a double solenoid object for the specified channels.\n"
"\n"
":param forwardChannel: solenoid channel for forward\n"
":param reverseChannel: solenoid channel for reverse\n"
"\n"
":returns: DoubleSolenoid object")
  )
  
  
  
    
  .
def
("makeCompressor", &frc::PneumaticsBase::MakeCompressor, release_gil(), py::doc(
    "Create a compressor object.\n"
"\n"
":returns: Compressor object")
  )
  
  
  
    
  .
def_static
("getForType", &frc::PneumaticsBase::GetForType,
      py::arg("module"), py::arg("moduleType"), release_gil(), py::doc(
    "For internal use to get a module for a specific type.\n"
"\n"
":param module:     module number\n"
":param moduleType: module type\n"
"\n"
":returns: module")
  )
  
  
  
    
  .
def_static
("getDefaultForType", &frc::PneumaticsBase::GetDefaultForType,
      py::arg("moduleType"), release_gil(), py::doc(
    "For internal use to get the default for a specific type.\n"
"\n"
":param moduleType: module type\n"
"\n"
":returns: module default")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_PneumaticsBase_initializer

static std::unique_ptr<rpybuild_PneumaticsBase_initializer> cls;

void begin_init_PneumaticsBase(py::module &m) {
  cls = std::make_unique<rpybuild_PneumaticsBase_initializer>(m);
}

void finish_init_PneumaticsBase() {
  cls->finish();
  cls.reset();
}