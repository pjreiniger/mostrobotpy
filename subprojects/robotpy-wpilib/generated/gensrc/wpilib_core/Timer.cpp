
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/Timer.h>


#include <units_time_type_caster.h>







#define RPYGEN_ENABLE_frc__Timer_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__Timer.hpp>









#include <type_traits>


  using namespace frc;



struct rpybuild_Timer_initializer {


  

  












  
  using Timer_Trampoline = rpygen::PyTrampoline_frc__Timer<typename frc::Timer, typename rpygen::PyTrampolineCfg_frc__Timer<>>;
    static_assert(std::is_abstract<Timer_Trampoline>::value == false, "frc::Timer " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::Timer, Timer_Trampoline> cls_Timer;

    

    
    

  py::module &m;

  
  rpybuild_Timer_initializer(py::module &m) :

  

  

  

  
    cls_Timer(m, "Timer"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_Timer.doc() =
    "A timer class.\n"
"\n"
"Note that if the user calls frc::sim::RestartTiming(), they should also reset\n"
"the timer so Get() won't return a negative duration.";

  cls_Timer
  
    
  .def(py::init<>(), release_gil(), py::doc(
    "Create a new timer object.\n"
"\n"
"Create a new timer object and reset the time to zero. The timer is\n"
"initially not running and must be started.")
  )
  
  
  
    
  .
def
("get", &frc::Timer::Get, release_gil(), py::doc(
    "Get the current time from the timer. If the clock is running it is derived\n"
"from the current system clock the start time stored in the timer class. If\n"
"the clock is not running, then return the time when it was last stopped.\n"
"\n"
":returns: Current time value for this timer in seconds")
  )
  
  
  
    
  .
def
("reset", &frc::Timer::Reset, release_gil(), py::doc(
    "Reset the timer by setting the time to 0.\n"
"\n"
"Make the timer startTime the current time so new requests will be relative\n"
"to now.")
  )
  
  
  
    
  .
def
("start", &frc::Timer::Start, release_gil(), py::doc(
    "Start the timer running.\n"
"\n"
"Just set the running flag to true indicating that all time requests should\n"
"be relative to the system clock. Note that this method is a no-op if the\n"
"timer is already running.")
  )
  
  
  
    
  .
def
("restart", &frc::Timer::Restart, release_gil(), py::doc(
    "Restart the timer by stopping the timer, if it is not already stopped,\n"
"resetting the accumulated time, then starting the timer again. If you\n"
"want an event to periodically reoccur at some time interval from the\n"
"start time, consider using AdvanceIfElapsed() instead.")
  )
  
  
  
    
  .
def
("stop", &frc::Timer::Stop, release_gil(), py::doc(
    "Stop the timer.\n"
"\n"
"This computes the time as of now and clears the running flag, causing all\n"
"subsequent time requests to be read from the accumulated time rather than\n"
"looking at the system clock.")
  )
  
  
  
    
  .
def
("hasElapsed", &frc::Timer::HasElapsed,
      py::arg("period"), release_gil(), py::doc(
    "Check if the period specified has passed.\n"
"\n"
":param period: The period to check.\n"
"\n"
":returns: True if the period has passed.")
  )
  
  
  
    
  .
def
("advanceIfElapsed", &frc::Timer::AdvanceIfElapsed,
      py::arg("period"), release_gil(), py::doc(
    "Check if the period specified has passed and if it has, advance the start\n"
"time by that period. This is useful to decide if it's time to do periodic\n"
"work without drifting later by the time it took to get around to checking.\n"
"\n"
":param period: The period to check for.\n"
"\n"
":returns: True if the period has passed.")
  )
  
  
  
    
  .
def_static
("getFPGATimestamp", &frc::Timer::GetFPGATimestamp, release_gil(), py::doc(
    "Return the FPGA system clock time in seconds.\n"
"\n"
"Return the time from the FPGA hardware clock in seconds since the FPGA\n"
"started. Rolls over after 71 minutes.\n"
"\n"
":returns: Robot running time in seconds.")
  )
  
  
  
    
  .
def_static
("getMatchTime", &frc::Timer::GetMatchTime, release_gil(), py::doc(
    "Return the approximate match time.\n"
"\n"
"The FMS does not send an official match time to the robots, but does send\n"
"an approximate match time. The value will count down the time remaining in\n"
"the current period (auto or teleop).\n"
"\n"
"Warning: This is not an official time (so it cannot be used to dispute ref\n"
"calls or guarantee that a function will trigger before the match ends).\n"
"\n"
"The Practice Match function of the DS approximates the behavior seen on the\n"
"field.\n"
"\n"
":returns: Time remaining in current match period (auto or teleop)")
  )
  
  
  ;

  


  }



m
  .
def
("wait", &frc::Wait,
      py::arg("seconds"), release_gil(), py::doc(
    "Pause the task for a specified time.\n"
"\n"
"Pause the execution of the program for a specified period of time given in\n"
"seconds. Motors will continue to run at their last assigned values, and\n"
"sensors will continue to update. Only the task containing the wait will pause\n"
"until the wait time is expired.\n"
"\n"
":param seconds: Length of time to pause, in seconds.")
  )
  
  ;
m
  .
def
("getTime", &frc::GetTime, release_gil(), py::doc(
    "Gives real-time clock system time with nanosecond resolution\n"
"\n"
":returns: The time, just in case you want the robot to start autonomous at 8pm\n"
"          on Saturday.")
  )
  
  ;



}

}; // struct rpybuild_Timer_initializer

static std::unique_ptr<rpybuild_Timer_initializer> cls;

void begin_init_Timer(py::module &m) {
  cls = std::make_unique<rpybuild_Timer_initializer>(m);
}

void finish_init_Timer() {
  cls->finish();
  cls.reset();
}