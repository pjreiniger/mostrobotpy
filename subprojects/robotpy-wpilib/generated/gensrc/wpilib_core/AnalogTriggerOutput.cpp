
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/AnalogTriggerOutput.h>








#define RPYGEN_ENABLE_frc__AnalogTriggerOutput_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__AnalogTriggerOutput.hpp>







#include <wpi/sendable/SendableBuilder.h>

#include <frc/AnalogInput.h>

#include <frc/DutyCycle.h>

#include <frc/AnalogTrigger.h>



#include <type_traits>


  using namespace frc;





struct rpybuild_AnalogTriggerOutput_initializer {


  

  












  
  using AnalogTriggerOutput_Trampoline = rpygen::PyTrampoline_frc__AnalogTriggerOutput<typename frc::AnalogTriggerOutput, typename rpygen::PyTrampolineCfg_frc__AnalogTriggerOutput<>>;
    static_assert(std::is_abstract<AnalogTriggerOutput_Trampoline>::value == false, "frc::AnalogTriggerOutput " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::AnalogTriggerOutput, AnalogTriggerOutput_Trampoline, frc::DigitalSource, wpi::Sendable> cls_AnalogTriggerOutput;

    

    
    

  py::module &m;

  
  rpybuild_AnalogTriggerOutput_initializer(py::module &m) :

  

  

  

  
    cls_AnalogTriggerOutput(m, "AnalogTriggerOutput"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_AnalogTriggerOutput.doc() =
    "Class to represent a specific output from an analog trigger.\n"
"\n"
"This class is used to get the current output value and also as a\n"
"DigitalSource to provide routing of an output to digital subsystems on the\n"
"FPGA such as Counter, Encoder, and Interrupt.\n"
"\n"
"The TriggerState output indicates the primary output value of the trigger.\n"
"If the analog signal is less than the lower limit, the output is false. If\n"
"the analog value is greater than the upper limit, then the output is true.\n"
"If the analog value is in between, then the trigger output state maintains\n"
"its most recent value.\n"
"\n"
"The InWindow output indicates whether or not the analog signal is inside the\n"
"range defined by the limits.\n"
"\n"
"The RisingPulse and FallingPulse outputs detect an instantaneous transition\n"
"from above the upper limit to below the lower limit, and vice versa. These\n"
"pulses represent a rollover condition of a sensor and can be routed to an up\n"
"/ down counter or to interrupts. Because the outputs generate a pulse, they\n"
"cannot be read directly. To help ensure that a rollover condition is not\n"
"missed, there is an average rejection filter available that operates on the\n"
"upper 8 bits of a 12 bit number and selects the nearest outlyer of 3 samples.\n"
"This will reject a sample that is (due to averaging or sampling) errantly\n"
"between the two limits. This filter will fail if more than one sample in a\n"
"row is errantly in between the two limits. You may see this problem if\n"
"attempting to use this feature with a mechanical rollover sensor, such as a\n"
"360 degree no-stop potentiometer without signal conditioning, because the\n"
"rollover transition is not sharp / clean enough. Using the averaging engine\n"
"may help with this, but rotational speeds of the sensor will then be limited.";

  cls_AnalogTriggerOutput
  
    
  .
def
("get", &frc::AnalogTriggerOutput::Get, release_gil(), py::doc(
    "Get the state of the analog trigger output.\n"
"\n"
":returns: The state of the analog trigger output.")
  )
  
  
  
    
  .
def
("getPortHandleForRouting", &frc::AnalogTriggerOutput::GetPortHandleForRouting, release_gil(), py::doc(
    "\n"
"\n"
":returns: The HAL Handle to the specified source.")
  )
  
  
  
    
  .
def
("getAnalogTriggerTypeForRouting", &frc::AnalogTriggerOutput::GetAnalogTriggerTypeForRouting, release_gil(), py::doc(
    "\n"
"\n"
":returns: The type of analog trigger output to be used.")
  )
  
  
  
    
  .
def
("isAnalogTrigger", &frc::AnalogTriggerOutput::IsAnalogTrigger, release_gil(), py::doc(
    "Is source an AnalogTrigger")
  )
  
  
  
    
  .
def
("getChannel", &frc::AnalogTriggerOutput::GetChannel, release_gil(), py::doc(
    "\n"
"\n"
":returns: The channel of the source.")
  )
  
  
  
    
  .
def
("initSendable", &frc::AnalogTriggerOutput::InitSendable,
      py::arg("builder"), release_gil()
  )
  
  
  
    
  .def(py::init_alias<const AnalogTrigger&, AnalogTriggerType>(),
      py::arg("trigger"), py::arg("outputType"), release_gil()
    , py::keep_alive<1, 2>(), py::doc(
    "Create an object that represents one of the four outputs from an analog\n"
"trigger.\n"
"\n"
"Because this class derives from DigitalSource, it can be passed into\n"
"routing functions for Counter, Encoder, etc.\n"
"\n"
":param trigger:    A pointer to the trigger for which this is an output.\n"
":param outputType: An enum that specifies the output on the trigger to\n"
"                   represent.")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_AnalogTriggerOutput_initializer

static std::unique_ptr<rpybuild_AnalogTriggerOutput_initializer> cls;

void begin_init_AnalogTriggerOutput(py::module &m) {
  cls = std::make_unique<rpybuild_AnalogTriggerOutput_initializer>(m);
}

void finish_init_AnalogTriggerOutput() {
  cls->finish();
  cls.reset();
}