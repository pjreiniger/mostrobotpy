
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/MotorSafety.h>


#include <units_time_type_caster.h>







#define RPYGEN_ENABLE_frc__MotorSafety_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__MotorSafety.hpp>







#include <wpi/SmallString.h>



#include <type_traits>


  using namespace frc;





struct rpybuild_MotorSafety_initializer {


  

  












  
  using MotorSafety_Trampoline = rpygen::PyTrampoline_frc__MotorSafety<typename frc::MotorSafety, typename rpygen::PyTrampolineCfg_frc__MotorSafety<>>;
    static_assert(std::is_abstract<MotorSafety_Trampoline>::value == false, "frc::MotorSafety " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::MotorSafety, MotorSafety_Trampoline> cls_MotorSafety;

    

    
    

  py::module &m;

  
  rpybuild_MotorSafety_initializer(py::module &m) :

  

  

  

  
    cls_MotorSafety(m, "MotorSafety"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_MotorSafety.doc() =
    "The Motor Safety feature acts as a watchdog timer for an individual motor. It\n"
"operates by maintaining a timer that tracks how long it has been since the\n"
"feed() method has been called for that actuator. Code in the Driver Station\n"
"class initiates a comparison of these timers to the timeout values for any\n"
"actuator with safety enabled every 5 received packets (100ms nominal).\n"
"\n"
"The subclass should call Feed() whenever the motor value is updated.";

  cls_MotorSafety
  
    
  .def(py::init<>(), release_gil()
  )
  
  
  
    
  .
def
("feed", &frc::MotorSafety::Feed, release_gil(), py::doc(
    "Feed the motor safety object.\n"
"\n"
"Resets the timer on this object that is used to do the timeouts.")
  )
  
  
  
    
  .
def
("setExpiration", &frc::MotorSafety::SetExpiration,
      py::arg("expirationTime"), release_gil(), py::doc(
    "Set the expiration time for the corresponding motor safety object.\n"
"\n"
":param expirationTime: The timeout value.")
  )
  
  
  
    
  .
def
("getExpiration", &frc::MotorSafety::GetExpiration, release_gil(), py::doc(
    "Retrieve the timeout value for the corresponding motor safety object.\n"
"\n"
":returns: the timeout value.")
  )
  
  
  
    
  .
def
("isAlive", &frc::MotorSafety::IsAlive, release_gil(), py::doc(
    "Determine if the motor is still operating or has timed out.\n"
"\n"
":returns: true if the motor is still operating normally and hasn't timed out.")
  )
  
  
  
    
  .
def
("setSafetyEnabled", &frc::MotorSafety::SetSafetyEnabled,
      py::arg("enabled"), release_gil(), py::doc(
    "Enable/disable motor safety for this device.\n"
"\n"
"Turn on and off the motor safety option for this PWM object.\n"
"\n"
":param enabled: True if motor safety is enforced for this object.")
  )
  
  
  
    
  .
def
("isSafetyEnabled", &frc::MotorSafety::IsSafetyEnabled, release_gil(), py::doc(
    "Return the state of the motor safety enabled flag.\n"
"\n"
"Return if the motor safety is currently enabled for this device.\n"
"\n"
":returns: True if motor safety is enforced for this device.")
  )
  
  
  
    
  .
def
("check", &frc::MotorSafety::Check, release_gil(), py::doc(
    "Check if this motor has exceeded its timeout.\n"
"\n"
"This method is called periodically to determine if this motor has exceeded\n"
"its timeout value. If it has, the stop method is called, and the motor is\n"
"shut down until its value is updated again.")
  )
  
  
  
    
  .
def_static
("checkMotors", &frc::MotorSafety::CheckMotors, release_gil(), py::doc(
    "Check the motors to see if any have timed out.\n"
"\n"
"This static method is called periodically to poll all the motors and stop\n"
"any that have timed out.")
  )
  
  
  
    
  .
def
("stopMotor", &frc::MotorSafety::StopMotor, release_gil(), py::doc(
    "Called to stop the motor when the timeout expires.")
  )
  
  
  
    
  .
def
("getDescription", &frc::MotorSafety::GetDescription, release_gil(), py::doc(
    "Returns a description to print when an error occurs.\n"
"\n"
":returns: Description to print when an error occurs.")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_MotorSafety_initializer

static std::unique_ptr<rpybuild_MotorSafety_initializer> cls;

void begin_init_MotorSafety(py::module &m) {
  cls = std::make_unique<rpybuild_MotorSafety_initializer>(m);
}

void finish_init_MotorSafety() {
  cls->finish();
  cls.reset();
}