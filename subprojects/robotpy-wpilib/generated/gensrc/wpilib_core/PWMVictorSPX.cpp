
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/motorcontrol/PWMVictorSPX.h>








#define RPYGEN_ENABLE_frc__PWMVictorSPX_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__PWMVictorSPX.hpp>







#include <wpi/sendable/SendableBuilder.h>



#include <type_traits>


  using namespace frc;





struct rpybuild_PWMVictorSPX_initializer {


  

  












  
  using PWMVictorSPX_Trampoline = rpygen::PyTrampoline_frc__PWMVictorSPX<typename frc::PWMVictorSPX, typename rpygen::PyTrampolineCfg_frc__PWMVictorSPX<>>;
    static_assert(std::is_abstract<PWMVictorSPX_Trampoline>::value == false, "frc::PWMVictorSPX " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::PWMVictorSPX, PWMVictorSPX_Trampoline, frc::PWMMotorController> cls_PWMVictorSPX;

    

    
    

  py::module &m;

  
  rpybuild_PWMVictorSPX_initializer(py::module &m) :

  

  

  

  
    cls_PWMVictorSPX(m, "PWMVictorSPX"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_PWMVictorSPX.doc() =
    "Cross the Road Electronics (CTRE) %Victor SPX Motor %Controller with PWM\n"
"control.\n"
"\n"
"Note that the %Victor SPX uses the following bounds for PWM values. These\n"
"values should work reasonably well for most controllers, but if users\n"
"experience issues such as asymmetric behavior around the deadband or\n"
"inability to saturate the controller in either direction, calibration is\n"
"recommended. The calibration procedure can be found in the %Victor SPX User\n"
"Manual available from Cross The Road Electronics.\n"
"\n"
"- 2.004ms = full \"forward\"\n"
"- 1.520ms = the \"high end\" of the deadband range\n"
"- 1.500ms = center of the deadband range (off)\n"
"- 1.480ms = the \"low end\" of the deadband range\n"
"- 0.997ms = full \"reverse\"";

  cls_PWMVictorSPX
  
    
  .def(py::init<int>(),
      py::arg("channel"), release_gil(), py::doc(
    "Construct a %Victor SPX connected via PWM.\n"
"\n"
":param channel: The PWM channel that the %Victor SPX is attached to. 0-9\n"
"                are on-board, 10-19 are on the MXP port")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_PWMVictorSPX_initializer

static std::unique_ptr<rpybuild_PWMVictorSPX_initializer> cls;

void begin_init_PWMVictorSPX(py::module &m) {
  cls = std::make_unique<rpybuild_PWMVictorSPX_initializer>(m);
}

void finish_init_PWMVictorSPX() {
  cls->finish();
  cls.reset();
}