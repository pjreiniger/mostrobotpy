
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/motorcontrol/PWMVenom.h>








#define RPYGEN_ENABLE_frc__PWMVenom_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__PWMVenom.hpp>







#include <wpi/sendable/SendableBuilder.h>



#include <type_traits>


  using namespace frc;





struct rpybuild_PWMVenom_initializer {


  

  












  
  using PWMVenom_Trampoline = rpygen::PyTrampoline_frc__PWMVenom<typename frc::PWMVenom, typename rpygen::PyTrampolineCfg_frc__PWMVenom<>>;
    static_assert(std::is_abstract<PWMVenom_Trampoline>::value == false, "frc::PWMVenom " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::PWMVenom, PWMVenom_Trampoline, frc::PWMMotorController> cls_PWMVenom;

    

    
    

  py::module &m;

  
  rpybuild_PWMVenom_initializer(py::module &m) :

  

  

  

  
    cls_PWMVenom(m, "PWMVenom"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_PWMVenom.doc() =
    "Playing with Fusion Venom Smart Motor with PWM control.\n"
"\n"
"Note that the Venom uses the following bounds for PWM values. These\n"
"values should work reasonably well for most controllers, but if users\n"
"experience issues such as asymmetric behavior around the deadband or\n"
"inability to saturate the controller in either direction, calibration is\n"
"recommended.\n"
"\n"
"- 2.004ms = full \"forward\"\n"
"- 1.520ms = the \"high end\" of the deadband range\n"
"- 1.500ms = center of the deadband range (off)\n"
"- 1.480ms = the \"low end\" of the deadband range\n"
"- 0.997ms = full \"reverse\"";

  cls_PWMVenom
  
    
  .def(py::init<int>(),
      py::arg("channel"), release_gil(), py::doc(
    "Construct a Venom connected via PWM.\n"
"\n"
":param channel: The PWM channel that the Venom is attached to. 0-9 are\n"
"                on-board, 10-19 are on the MXP port")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_PWMVenom_initializer

static std::unique_ptr<rpybuild_PWMVenom_initializer> cls;

void begin_init_PWMVenom(py::module &m) {
  cls = std::make_unique<rpybuild_PWMVenom_initializer>(m);
}

void finish_init_PWMVenom() {
  cls->finish();
  cls.reset();
}