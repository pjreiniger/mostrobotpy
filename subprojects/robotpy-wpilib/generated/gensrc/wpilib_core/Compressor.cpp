
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/Compressor.h>


#include <units_current_type_caster.h>

#include <units_pressure_type_caster.h>

#include <units_voltage_type_caster.h>







#define RPYGEN_ENABLE_frc__Compressor_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__Compressor.hpp>







#include <wpi/sendable/SendableBuilder.h>

#include <frc/Compressor.h>

#include <frc/Solenoid.h>

#include <frc/DoubleSolenoid.h>



#include <type_traits>


  using namespace frc;



struct rpybuild_Compressor_initializer {


  

  












  
  using Compressor_Trampoline = rpygen::PyTrampoline_frc__Compressor<typename frc::Compressor, typename rpygen::PyTrampolineCfg_frc__Compressor<>>;
    static_assert(std::is_abstract<Compressor_Trampoline>::value == false, "frc::Compressor " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::Compressor, Compressor_Trampoline, wpi::Sendable> cls_Compressor;

    

    
    

  py::module &m;

  
  rpybuild_Compressor_initializer(py::module &m) :

  

  

  

  
    cls_Compressor(m, "Compressor"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_Compressor.doc() =
    "Class for operating a compressor connected to a pneumatics module.\n"
"\n"
"The module will automatically run in closed loop mode by default whenever a\n"
"Solenoid object is created. For most cases, a Compressor object does not need\n"
"to be instantiated or used in a robot program. This class is only required in\n"
"cases where the robot program needs a more detailed status of the compressor\n"
"or to enable/disable closed loop control.\n"
"\n"
"Note: you cannot operate the compressor directly from this class as doing so\n"
"would circumvent the safety provided by using the pressure switch and closed\n"
"loop control. You can only turn off closed loop control, thereby stopping\n"
"the compressor from operating.";

  cls_Compressor
  
    
  .def(py::init<int, PneumaticsModuleType>(),
      py::arg("module"), py::arg("moduleType"), release_gil(), py::doc(
    "Constructs a compressor for a specified module and type.\n"
"\n"
":param module:     The module ID to use.\n"
":param moduleType: The module type to use.")
  )
  
  
  
    
  .def(py::init<PneumaticsModuleType>(),
      py::arg("moduleType"), release_gil(), py::doc(
    "Constructs a compressor for a default module and specified type.\n"
"\n"
":param moduleType: The module type to use.")
  )
  
  
  
    
  .
def
("isEnabled", &frc::Compressor::IsEnabled, release_gil(), py::doc(
    "Returns whether the compressor is active or not.\n"
"\n"
":returns: true if the compressor is on - otherwise false.")
  )
  
  
  
    
  .
def
("getPressureSwitchValue", &frc::Compressor::GetPressureSwitchValue, release_gil(), py::doc(
    "Returns the state of the pressure switch.\n"
"\n"
":returns: True if pressure switch indicates that the system is not full,\n"
"          otherwise false.")
  )
  
  
  
    
  .
def
("getCurrent", &frc::Compressor::GetCurrent, release_gil(), py::doc(
    "Get the current drawn by the compressor.\n"
"\n"
":returns: Current drawn by the compressor.")
  )
  
  
  
    
  .
def
("getAnalogVoltage", &frc::Compressor::GetAnalogVoltage, release_gil(), py::doc(
    "If supported by the device, returns the analog input voltage (on channel\n"
"0).\n"
"\n"
"This function is only supported by the REV PH. On CTRE PCM, this will\n"
"return 0.\n"
"\n"
":returns: The analog input voltage, in volts.")
  )
  
  
  
    
  .
def
("getPressure", &frc::Compressor::GetPressure, release_gil(), py::doc(
    "If supported by the device, returns the pressure read by the analog\n"
"pressure sensor (on channel 0).\n"
"\n"
"This function is only supported by the REV PH with the REV Analog Pressure\n"
"Sensor. On CTRE PCM, this will return 0.\n"
"\n"
":returns: The pressure read by the analog pressure sensor.")
  )
  
  
  
    
  .
def
("disable", &frc::Compressor::Disable, release_gil(), py::doc(
    "Disable the compressor.")
  )
  
  
  
    
  .
def
("enableDigital", &frc::Compressor::EnableDigital, release_gil(), py::doc(
    "Enables the compressor in digital mode using the digital pressure switch.\n"
"The compressor will turn on when the pressure switch indicates that the\n"
"system is not full, and will turn off when the pressure switch indicates\n"
"that the system is full.")
  )
  
  
  
    
  .
def
("enableAnalog", &frc::Compressor::EnableAnalog,
      py::arg("minPressure"), py::arg("maxPressure"), release_gil(), py::doc(
    "If supported by the device, enables the compressor in analog mode. This\n"
"mode uses an analog pressure sensor connected to analog channel 0 to cycle\n"
"the compressor. The compressor will turn on when the pressure drops below\n"
"``minPressure`` and will turn off when the pressure reaches {@code\n"
"maxPressure}. This mode is only supported by the REV PH with the REV Analog\n"
"Pressure Sensor connected to analog channel 0.\n"
"\n"
"On CTRE PCM, this will enable digital control.\n"
"\n"
":param minPressure: The minimum pressure. The compressor will turn on when\n"
"                    the pressure drops below this value.\n"
":param maxPressure: The maximum pressure. The compressor will turn off when\n"
"                    the pressure reaches this value.")
  )
  
  
  
    
  .
def
("enableHybrid", &frc::Compressor::EnableHybrid,
      py::arg("minPressure"), py::arg("maxPressure"), release_gil(), py::doc(
    "If supported by the device, enables the compressor in hybrid mode. This\n"
"mode uses both a digital pressure switch and an analog pressure sensor\n"
"connected to analog channel 0 to cycle the compressor. This mode is only\n"
"supported by the REV PH with the REV Analog Pressure Sensor connected to\n"
"analog channel 0.\n"
"\n"
"The compressor will turn on when \\a both:\n"
"\n"
"- The digital pressure switch indicates the system is not full AND\n"
"- The analog pressure sensor indicates that the pressure in the system\n"
"is below the specified minimum pressure.\n"
"\n"
"The compressor will turn off when \\a either:\n"
"\n"
"- The digital pressure switch is disconnected or indicates that the system\n"
"is full OR\n"
"- The pressure detected by the analog sensor is greater than the specified\n"
"maximum pressure.\n"
"\n"
"On CTRE PCM, this will enable digital control.\n"
"\n"
":param minPressure: The minimum pressure. The compressor will turn on\n"
"                    when the pressure drops below this value and the pressure switch indicates\n"
"                    that the system is not full.\n"
":param maxPressure: The maximum pressure. The compressor will turn\n"
"                    off when the pressure reaches this value or the pressure switch is\n"
"                    disconnected or indicates that the system is full.")
  )
  
  
  
    
  .
def
("getConfigType", &frc::Compressor::GetConfigType, release_gil(), py::doc(
    "Returns the active compressor configuration.\n"
"\n"
":returns: The active compressor configuration.")
  )
  
  
  
    
  .
def
("initSendable", &frc::Compressor::InitSendable,
      py::arg("builder"), release_gil()
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_Compressor_initializer

static std::unique_ptr<rpybuild_Compressor_initializer> cls;

void begin_init_Compressor(py::module &m) {
  cls = std::make_unique<rpybuild_Compressor_initializer>(m);
}

void finish_init_Compressor() {
  cls->finish();
  cls.reset();
}