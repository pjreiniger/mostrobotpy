
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/motorcontrol/PWMSparkFlex.h>








#define RPYGEN_ENABLE_frc__PWMSparkFlex_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__PWMSparkFlex.hpp>









#include <type_traits>


  using namespace frc;





struct rpybuild_PWMSparkFlex_initializer {


  

  












  
  using PWMSparkFlex_Trampoline = rpygen::PyTrampoline_frc__PWMSparkFlex<typename frc::PWMSparkFlex, typename rpygen::PyTrampolineCfg_frc__PWMSparkFlex<>>;
    static_assert(std::is_abstract<PWMSparkFlex_Trampoline>::value == false, "frc::PWMSparkFlex " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::PWMSparkFlex, PWMSparkFlex_Trampoline, frc::PWMMotorController> cls_PWMSparkFlex;

    

    
    

  py::module &m;

  
  rpybuild_PWMSparkFlex_initializer(py::module &m) :

  

  

  

  
    cls_PWMSparkFlex(m, "PWMSparkFlex"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_PWMSparkFlex.doc() =
    "REV Robotics SPARK Flex Motor %Controller.\n"
"\n"
"Note that the SPARK Flex uses the following bounds for PWM values. These\n"
"values should work reasonably well for most controllers, but if users\n"
"experience issues such as asymmetric behavior around the deadband or\n"
"inability to saturate the controller in either direction, calibration is\n"
"recommended. The calibration procedure can be found in the SPARK Flex User\n"
"Manual available from REV Robotics.\n"
"\n"
"- 2.003ms = full \"forward\"\n"
"- 1.550ms = the \"high end\" of the deadband range\n"
"- 1.500ms = center of the deadband range (off)\n"
"- 1.460ms = the \"low end\" of the deadband range\n"
"- 0.999ms = full \"reverse\"";

  cls_PWMSparkFlex
  
    
  .def(py::init<int>(),
      py::arg("channel"), release_gil(), py::doc(
    "Constructor for a SPARK Flex.\n"
"\n"
":param channel: The PWM channel that the SPARK Flex is attached to. 0-9 are\n"
"                on-board, 10-19 are on the MXP port")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_PWMSparkFlex_initializer

static std::unique_ptr<rpybuild_PWMSparkFlex_initializer> cls;

void begin_init_PWMSparkFlex(py::module &m) {
  cls = std::make_unique<rpybuild_PWMSparkFlex_initializer>(m);
}

void finish_init_PWMSparkFlex() {
  cls->finish();
  cls.reset();
}