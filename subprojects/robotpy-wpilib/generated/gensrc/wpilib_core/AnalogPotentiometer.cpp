
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/AnalogPotentiometer.h>








#define RPYGEN_ENABLE_frc__AnalogPotentiometer_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__AnalogPotentiometer.hpp>







#include <wpi/sendable/SendableBuilder.h>



#include <type_traits>


  using namespace frc;



struct rpybuild_AnalogPotentiometer_initializer {


  

  












  
  using AnalogPotentiometer_Trampoline = rpygen::PyTrampoline_frc__AnalogPotentiometer<typename frc::AnalogPotentiometer, typename rpygen::PyTrampolineCfg_frc__AnalogPotentiometer<>>;
    static_assert(std::is_abstract<AnalogPotentiometer_Trampoline>::value == false, "frc::AnalogPotentiometer " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::AnalogPotentiometer, AnalogPotentiometer_Trampoline, wpi::Sendable> cls_AnalogPotentiometer;

    

    
    

  py::module &m;

  
  rpybuild_AnalogPotentiometer_initializer(py::module &m) :

  

  

  

  
    cls_AnalogPotentiometer(m, "AnalogPotentiometer"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_AnalogPotentiometer.doc() =
    "Class for reading analog potentiometers. Analog potentiometers read in an\n"
"analog voltage that corresponds to a position. The position is in whichever\n"
"units you choose, by way of the scaling and offset constants passed to the\n"
"constructor.";

  cls_AnalogPotentiometer
  
    
  .def(py::init<int, double, double>(),
      py::arg("channel"), py::arg("fullRange") = 1.0, py::arg("offset") = 0.0, release_gil(), py::doc(
    "Construct an Analog Potentiometer object from a channel number.\n"
"\n"
"Use the fullRange and offset values so that the output produces meaningful\n"
"values. I.E: you have a 270 degree potentiometer and you want the output to\n"
"be degrees with the halfway point as 0 degrees. The fullRange value is\n"
"270.0 degrees and the offset is -135.0 since the halfway point after\n"
"scaling is 135 degrees.\n"
"\n"
"This will calculate the result from the fullRange times the fraction of the\n"
"supply voltage, plus the offset.\n"
"\n"
":param channel:   The Analog Input channel number on the roboRIO the\n"
"                  potentiometer is plugged into. 0-3 are on-board and 4-7\n"
"                  are on the MXP port.\n"
":param fullRange: The value (in desired units) representing the full\n"
"                  0-5V range of the input.\n"
":param offset:    The value (in desired units) representing the\n"
"                  angular output at 0V.")
  )
  
  
  
    
  .def(py::init<std::shared_ptr<AnalogInput>, double, double>(),
      py::arg("input"), py::arg("fullRange") = 1.0, py::arg("offset") = 0.0, release_gil(), py::doc(
    "Construct an Analog Potentiometer object from an existing Analog Input\n"
"pointer.\n"
"\n"
"Use the fullRange and offset values so that the output produces meaningful\n"
"values. I.E: you have a 270 degree potentiometer and you want the output to\n"
"be degrees with the halfway point as 0 degrees. The fullRange value is\n"
"270.0 degrees and the offset is -135.0 since the halfway point after\n"
"scaling is 135 degrees.\n"
"\n"
"This will calculate the result from the fullRange times the fraction of the\n"
"supply voltage, plus the offset.\n"
"\n"
":param input:     The existing Analog Input pointer\n"
":param fullRange: The value (in desired units) representing the full\n"
"                  0-5V range of the input.\n"
":param offset:    The value (in desired units) representing the\n"
"                  angular output at 0V.")
  )
  
  
  
    
  .
def
("get", &frc::AnalogPotentiometer::Get, release_gil(), py::doc(
    "Get the current reading of the potentiometer.\n"
"\n"
":returns: The current position of the potentiometer (in the units used for\n"
"          fullRange and offset).")
  )
  
  
  
    
  .
def
("initSendable", &frc::AnalogPotentiometer::InitSendable,
      py::arg("builder"), release_gil()
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_AnalogPotentiometer_initializer

static std::unique_ptr<rpybuild_AnalogPotentiometer_initializer> cls;

void begin_init_AnalogPotentiometer(py::module &m) {
  cls = std::make_unique<rpybuild_AnalogPotentiometer_initializer>(m);
}

void finish_init_AnalogPotentiometer() {
  cls->finish();
  cls.reset();
}