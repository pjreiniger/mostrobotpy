
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/DigitalInput.h>








#define RPYGEN_ENABLE_frc__DigitalInput_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__DigitalInput.hpp>







#include <wpi/sendable/SendableBuilder.h>

#include <frc/DigitalGlitchFilter.h>



#include <type_traits>


  using namespace frc;





struct rpybuild_DigitalInput_initializer {


  

  












  
  using DigitalInput_Trampoline = rpygen::PyTrampoline_frc__DigitalInput<typename frc::DigitalInput, typename rpygen::PyTrampolineCfg_frc__DigitalInput<>>;
    static_assert(std::is_abstract<DigitalInput_Trampoline>::value == false, "frc::DigitalInput " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::DigitalInput, DigitalInput_Trampoline, frc::DigitalSource, wpi::Sendable> cls_DigitalInput;

    

    
    

  py::module &m;

  
  rpybuild_DigitalInput_initializer(py::module &m) :

  

  

  

  
    cls_DigitalInput(m, "DigitalInput"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_DigitalInput.doc() =
    "Class to read a digital input.\n"
"\n"
"This class will read digital inputs and return the current value on the\n"
"channel. Other devices such as encoders, gear tooth sensors, etc. that are\n"
"implemented elsewhere will automatically allocate digital inputs and outputs\n"
"as required. This class is only for devices like switches etc. that aren't\n"
"implemented anywhere else.";

  cls_DigitalInput
  
    
  .def(py::init<int>(),
      py::arg("channel"), release_gil(), py::doc(
    "Create an instance of a Digital Input class.\n"
"\n"
"Creates a digital input given a channel.\n"
"\n"
":param channel: The DIO channel 0-9 are on-board, 10-25 are on the MXP port")
  )
  
  
  
    
  .
def
("get", &frc::DigitalInput::Get, release_gil(), py::doc(
    "Get the value from a digital input channel.\n"
"\n"
"Retrieve the value of a single digital input channel from the FPGA.")
  )
  
  
  
    
  .
def
("getPortHandleForRouting", &frc::DigitalInput::GetPortHandleForRouting, release_gil(), py::doc(
    "\n"
"\n"
":returns: The HAL Handle to the specified source.")
  )
  
  
  
    
  .
def
("getAnalogTriggerTypeForRouting", &frc::DigitalInput::GetAnalogTriggerTypeForRouting, release_gil(), py::doc(
    "\n"
"\n"
":returns: The type of analog trigger output to be used. 0 for Digitals")
  )
  
  
  
    
  .
def
("isAnalogTrigger", &frc::DigitalInput::IsAnalogTrigger, release_gil(), py::doc(
    "Is source an AnalogTrigger")
  )
  
  
  
    
  .
def
("getChannel", &frc::DigitalInput::GetChannel, release_gil(), py::doc(
    "\n"
"\n"
":returns: The GPIO channel number that this object represents.")
  )
  
  
  
    
  .
def
("setSimDevice", &frc::DigitalInput::SetSimDevice,
      py::arg("device"), release_gil(), py::doc(
    "Indicates this input is used by a simulated device.\n"
"\n"
":param device: simulated device handle")
  )
  
  
  
    
  .
def
("initSendable", &frc::DigitalInput::InitSendable,
      py::arg("builder"), release_gil()
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_DigitalInput_initializer

static std::unique_ptr<rpybuild_DigitalInput_initializer> cls;

void begin_init_DigitalInput(py::module &m) {
  cls = std::make_unique<rpybuild_DigitalInput_initializer>(m);
}

void finish_init_DigitalInput() {
  cls->finish();
  cls.reset();
}