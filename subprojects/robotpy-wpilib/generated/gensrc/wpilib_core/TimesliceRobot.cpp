
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/TimesliceRobot.h>


#include <pybind11/functional.h>

#include <units_time_type_caster.h>







#define RPYGEN_ENABLE_frc__TimesliceRobot_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__TimesliceRobot.hpp>









#include <type_traits>


  using namespace frc;





struct rpybuild_TimesliceRobot_initializer {


  

  












  
  using TimesliceRobot_Trampoline = rpygen::PyTrampoline_frc__TimesliceRobot<typename frc::TimesliceRobot, typename rpygen::PyTrampolineCfg_frc__TimesliceRobot<>>;
    static_assert(std::is_abstract<TimesliceRobot_Trampoline>::value == false, "frc::TimesliceRobot " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::TimesliceRobot, TimesliceRobot_Trampoline, frc::TimedRobot> cls_TimesliceRobot;

    

    
    

  py::module &m;

  
  rpybuild_TimesliceRobot_initializer(py::module &m) :

  

  

  

  
    cls_TimesliceRobot(m, "TimesliceRobot"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_TimesliceRobot.doc() =
    "TimesliceRobot extends the TimedRobot robot program framework to provide\n"
"timeslice scheduling of periodic functions.\n"
"\n"
"The TimesliceRobot class is intended to be subclassed by a user creating a\n"
"robot program.\n"
"\n"
"This class schedules robot operations serially in a timeslice format.\n"
"TimedRobot's periodic functions are the first in the timeslice table with 0\n"
"ms offset and 20 ms period. You can schedule additional controller periodic\n"
"functions at a shorter period (5 ms by default). You give each one a\n"
"timeslice duration, then they're run sequentially. The main benefit of this\n"
"approach is consistent starting times for each controller periodic, which can\n"
"make odometry and estimators more accurate and controller outputs change more\n"
"consistently.\n"
"\n"
"Here's an example of measured subsystem durations and their timeslice\n"
"allocations:\n"
"\n"
"<table>\n"
"<tr>\n"
"<td>**Subsystem**</td>\n"
"<td>**Duration (ms)**</td>\n"
"<td>**Allocation (ms)**</td>\n"
"</tr>\n"
"<tr>\n"
"<td>**Total**</td>\n"
"<td>5.0</td>\n"
"<td>5.0</td>\n"
"</tr>\n"
"<tr>\n"
"<td>TimedRobot</td>\n"
"<td>?</td>\n"
"<td>2.0</td>\n"
"</tr>\n"
"<tr>\n"
"<td>Drivetrain</td>\n"
"<td>1.32</td>\n"
"<td>1.5</td>\n"
"</tr>\n"
"<tr>\n"
"<td>Flywheel</td>\n"
"<td>0.6</td>\n"
"<td>0.7</td>\n"
"</tr>\n"
"<tr>\n"
"<td>Turret</td>\n"
"<td>0.6</td>\n"
"<td>0.8</td>\n"
"</tr>\n"
"<tr>\n"
"<td>**Free**</td>\n"
"<td>0.0</td>\n"
"<td>N/A</td>\n"
"</tr>\n"
"</table>\n"
"\n"
"Since TimedRobot periodic functions only run every 20ms, that leaves a 2 ms\n"
"empty spot in the allocation table for three of the four 5 ms cycles\n"
"comprising 20 ms. That's OK because the OS needs time to do other things.\n"
"\n"
"If the robot periodic functions and the controller periodic functions have a\n"
"lot of scheduling jitter that cause them to occasionally overlap with later\n"
"timeslices, consider giving the main robot thread a real-time priority using\n"
"frc::SetCurrentThreadPriority(). An RT priority of 15 is a reasonable choice.\n"
"\n"
"If you do enable RT though, :emphasis:`make sure your periodic functions do not\n"
"block`. If they do, the operating system will lock up, and you'll have to\n"
"boot the roboRIO into safe mode and delete the robot program to recover.";

  cls_TimesliceRobot
  
    
  .def(py::init<units::second_t, units::second_t>(),
      py::arg("robotPeriodicAllocation"), py::arg("controllerPeriod"), release_gil(), py::doc(
    "Constructor for TimesliceRobot.\n"
"\n"
":param robotPeriodicAllocation: The allocation to give the TimesliceRobot\n"
"                                periodic functions.\n"
":param controllerPeriod:        The controller period. The sum of all scheduler\n"
"                                allocations should be less than or equal to this\n"
"                                value.")
  )
  
  
  
    
  .
def
("schedule", &frc::TimesliceRobot::Schedule,
      py::arg("func").none(false), py::arg("allocation"), release_gil(), py::doc(
    "Schedule a periodic function with the constructor's controller period and\n"
"the given allocation. The function's runtime allocation will be placed\n"
"after the end of the previous one's.\n"
"\n"
"If a call to this function makes the allocations exceed the controller\n"
"period, an exception will be thrown since that means the TimesliceRobot\n"
"periodic functions and the given function will have conflicting\n"
"timeslices.\n"
"\n"
":param func:       Function to schedule.\n"
":param allocation: The function's runtime allocation out of the controller\n"
"                   period.")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_TimesliceRobot_initializer

static std::unique_ptr<rpybuild_TimesliceRobot_initializer> cls;

void begin_init_TimesliceRobot(py::module &m) {
  cls = std::make_unique<rpybuild_TimesliceRobot_initializer>(m);
}

void finish_init_TimesliceRobot() {
  cls->finish();
  cls.reset();
}