
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/DutyCycle.h>


#include <units_time_type_caster.h>







#define RPYGEN_ENABLE_frc__DutyCycle_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__DutyCycle.hpp>







#include <wpi/sendable/SendableBuilder.h>

#include <frc/AnalogTrigger.h>

#include <frc/DigitalSource.h>

#include <frc/DMA.h>

#include <frc/DMASample.h>



#include <type_traits>


  using namespace frc;



struct rpybuild_DutyCycle_initializer {


  

  












  
  using DutyCycle_Trampoline = rpygen::PyTrampoline_frc__DutyCycle<typename frc::DutyCycle, typename rpygen::PyTrampolineCfg_frc__DutyCycle<>>;
    static_assert(std::is_abstract<DutyCycle_Trampoline>::value == false, "frc::DutyCycle " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::DutyCycle, DutyCycle_Trampoline, wpi::Sendable> cls_DutyCycle;

    

    
    

  py::module &m;

  
  rpybuild_DutyCycle_initializer(py::module &m) :

  

  

  

  
    cls_DutyCycle(m, "DutyCycle"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_DutyCycle.doc() =
    "Class to read a duty cycle PWM input.\n"
"\n"
"PWM input signals are specified with a frequency and a ratio of high to\n"
"low in that frequency. There are 8 of these in the roboRIO, and they can be\n"
"attached to any DigitalSource.\n"
"\n"
"These can be combined as the input of an AnalogTrigger to a Counter in\n"
"order to implement rollover checking.";

  cls_DutyCycle
  
    
  .def(py::init<std::shared_ptr<DigitalSource>>(),
      py::arg("source"), release_gil(), py::doc(
    "Constructs a DutyCycle input from a DigitalSource input.\n"
"\n"
"This class does not own the inputted source.\n"
"\n"
":param source: The DigitalSource to use.")
  )
  
  
  
    
  .
def
("getFrequency", &frc::DutyCycle::GetFrequency, release_gil(), py::doc(
    "Get the frequency of the duty cycle signal.\n"
"\n"
":returns: frequency in Hertz")
  )
  
  
  
    
  .
def
("getOutput", &frc::DutyCycle::GetOutput, release_gil(), py::doc(
    "Get the output ratio of the duty cycle signal.\n"
"\n"
"0 means always low, 1 means always high.\n"
"\n"
":returns: output ratio between 0 and 1")
  )
  
  
  
    
  .
def
("getHighTime", &frc::DutyCycle::GetHighTime, release_gil(), py::doc(
    "Get the raw high time of the duty cycle signal.\n"
"\n"
":returns: high time of last pulse")
  )
  
  
  
    
  .
def
("getFPGAIndex", &frc::DutyCycle::GetFPGAIndex, release_gil(), py::doc(
    "Get the FPGA index for the DutyCycle.\n"
"\n"
":returns: the FPGA index")
  )
  
  
  
    
  .
def
("getSourceChannel", &frc::DutyCycle::GetSourceChannel, release_gil(), py::doc(
    "Get the channel of the source.\n"
"\n"
":returns: the source channel")
  )
  
  
  
    
  .
def
("_initSendable", static_cast<void(frc::DutyCycle::*)(wpi::SendableBuilder&)>(&DutyCycle_Trampoline::InitSendable),
      py::arg("builder"), release_gil()
  )
  
  
  ;

  


  }







  cls_DutyCycle
  .def("__repr__", [](const DutyCycle &self) {
    return py::str("<DutyCycle {}>").format(self.GetSourceChannel());
  });


}

}; // struct rpybuild_DutyCycle_initializer

static std::unique_ptr<rpybuild_DutyCycle_initializer> cls;

void begin_init_DutyCycle(py::module &m) {
  cls = std::make_unique<rpybuild_DutyCycle_initializer>(m);
}

void finish_init_DutyCycle() {
  cls->finish();
  cls.reset();
}