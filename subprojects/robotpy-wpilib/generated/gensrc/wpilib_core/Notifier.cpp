
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <rpy/Notifier.h>


#include <pybind11/functional.h>

#include <units_time_type_caster.h>







#define RPYGEN_ENABLE_frc__PyNotifier_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__PyNotifier.hpp>









#include <type_traits>


  using namespace frc;





struct rpybuild_Notifier_initializer {


  

  












  
  using PyNotifier_Trampoline = rpygen::PyTrampoline_frc__PyNotifier<typename frc::PyNotifier, typename rpygen::PyTrampolineCfg_frc__PyNotifier<>>;
    static_assert(std::is_abstract<PyNotifier_Trampoline>::value == false, "frc::PyNotifier " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::PyNotifier, PyNotifier_Trampoline> cls_PyNotifier;

    

    
    

  py::module &m;

  
  rpybuild_Notifier_initializer(py::module &m) :

  

  

  

  
    cls_PyNotifier(m, "Notifier"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  

  cls_PyNotifier
  
    
  .def(py::init<std::function<void ()>>(),
      py::arg("handler").none(false), release_gil(), py::doc(
    "Create a Notifier for timer event notification.\n"
"\n"
":param handler: The handler is called at the notification time which is set\n"
"                using StartSingle or StartPeriodic.")
  )
  
  
  
    
  .
def
("setName", &frc::PyNotifier::SetName,
      py::arg("name"), release_gil(), py::doc(
    "Sets the name of the notifier.  Used for debugging purposes only.\n"
"\n"
":param name: Name")
  )
  
  
  
    
  .
def
("setHandler", &frc::PyNotifier::SetHandler,
      py::arg("handler").none(false), release_gil(), py::doc(
    "Change the handler function.\n"
"\n"
":param handler: Handler")
  )
  
  
  
    
  .
def
("startSingle", &frc::PyNotifier::StartSingle,
      py::arg("delay"), release_gil(), py::doc(
    "Register for single event notification.\n"
"\n"
"A timer event is queued for a single event after the specified delay.\n"
"\n"
":param delay: Amount of time to wait before the handler is called.")
  )
  
  
  
    
  .
def
("startPeriodic", &frc::PyNotifier::StartPeriodic,
      py::arg("period"), release_gil(), py::doc(
    "Register for periodic event notification.\n"
"\n"
"A timer event is queued for periodic event notification. Each time the\n"
"interrupt occurs, the event will be immediately requeued for the same time\n"
"interval.\n"
"\n"
":param period: Period to call the handler starting one period\n"
"               after the call to this method.")
  )
  
  
  
    
  .
def
("stop", &frc::PyNotifier::Stop, release_gil(), py::doc(
    "Stop timer events from occurring.\n"
"\n"
"Stop any repeating timer events from occurring. This will also remove any\n"
"single notification events from the queue.\n"
"\n"
"If a timer-based call to the registered handler is in progress, this\n"
"function will block until the handler call is complete.")
  )
  
  
  
    
  .
def_static
("setHALThreadPriority", &frc::PyNotifier::SetHALThreadPriority,
      py::arg("realTime"), py::arg("priority"), release_gil(), py::doc(
    "Sets the HAL notifier thread priority.\n"
"\n"
"The HAL notifier thread is responsible for managing the FPGA's notifier\n"
"interrupt and waking up user's Notifiers when it's their time to run.\n"
"Giving the HAL notifier thread real-time priority helps ensure the user's\n"
"real-time Notifiers, if any, are notified to run in a timely manner.\n"
"\n"
":param realTime: Set to true to set a real-time priority, false for standard\n"
"                 priority.\n"
":param priority: Priority to set the thread to. For real-time, this is 1-99\n"
"                 with 99 being highest. For non-real-time, this is forced to\n"
"                 0. See \"man 7 sched\" for more details.\n"
"\n"
":returns: True on success.")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_Notifier_initializer

static std::unique_ptr<rpybuild_Notifier_initializer> cls;

void begin_init_Notifier(py::module &m) {
  cls = std::make_unique<rpybuild_Notifier_initializer>(m);
}

void finish_init_Notifier() {
  cls->finish();
  cls.reset();
}