
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/RobotBase.h>








#define RPYGEN_ENABLE_frc__RobotBase_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__RobotBase.hpp>







#include <frc/DriverStation.h>

#include <rpy/ControlWord.h>



#include <type_traits>


  using namespace frc;

  using namespace frc::impl;





struct rpybuild_RobotBase_initializer {


  

  












  
  using RobotBase_Trampoline = rpygen::PyTrampoline_frc__RobotBase<typename frc::RobotBase, typename rpygen::PyTrampolineCfg_frc__RobotBase<>>;
    static_assert(std::is_abstract<RobotBase_Trampoline>::value == false, "frc::RobotBase " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::RobotBase, RobotBase_Trampoline> cls_RobotBase;

    

    
    

  py::module &m;

  
  rpybuild_RobotBase_initializer(py::module &m) :

  

  

  

  
    cls_RobotBase(m, "RobotBase"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_RobotBase.doc() =
    "Implement a Robot Program framework. The RobotBase class is intended to be\n"
"subclassed to create a robot program. The user must implement\n"
"StartCompetition() which will be called once and is not expected to exit. The\n"
"user must also implement EndCompetition(), which signals to the code in\n"
"StartCompetition() that it should exit.\n"
"\n"
"It is not recommended to subclass this class directly - instead subclass\n"
"IterativeRobotBase or TimedRobot.";

  cls_RobotBase
  
    
  .
def
("isEnabled", &frc::RobotBase::IsEnabled, release_gil(), py::doc(
    "Determine if the Robot is currently enabled.\n"
"\n"
":returns: True if the Robot is currently enabled by the Driver Station.")
  )
  
  
  
    
  .
def
("isDisabled", &frc::RobotBase::IsDisabled, release_gil(), py::doc(
    "Determine if the Robot is currently disabled.\n"
"\n"
":returns: True if the Robot is currently disabled by the Driver Station.")
  )
  
  
  
    
  .
def
("isAutonomous", &frc::RobotBase::IsAutonomous, release_gil(), py::doc(
    "Determine if the robot is currently in Autonomous mode.\n"
"\n"
":returns: True if the robot is currently operating Autonomously as determined\n"
"          by the Driver Station.")
  )
  
  
  
    
  .
def
("isAutonomousEnabled", &frc::RobotBase::IsAutonomousEnabled, release_gil(), py::doc(
    "Determine if the robot is currently in Autonomous mode and enabled.\n"
"\n"
":returns: True if the robot us currently operating Autonomously while enabled\n"
"          as determined by the Driver Station.")
  )
  
  
  
    
  .
def
("isTeleop", &frc::RobotBase::IsTeleop, release_gil(), py::doc(
    "Determine if the robot is currently in Operator Control mode.\n"
"\n"
":returns: True if the robot is currently operating in Tele-Op mode as\n"
"          determined by the Driver Station.")
  )
  
  
  
    
  .
def
("isTeleopEnabled", &frc::RobotBase::IsTeleopEnabled, release_gil(), py::doc(
    "Determine if the robot is current in Operator Control mode and enabled.\n"
"\n"
":returns: True if the robot is currently operating in Tele-Op mode while\n"
"          enabled as determined by the Driver Station.")
  )
  
  
  
    
  .
def
("isTest", &frc::RobotBase::IsTest, release_gil(), py::doc(
    "Determine if the robot is currently in Test mode.\n"
"\n"
":returns: True if the robot is currently running in Test mode as determined\n"
"          by the Driver Station.")
  )
  
  
  
    
  .
def
("isTestEnabled", &frc::RobotBase::IsTestEnabled, release_gil(), py::doc(
    "Determine if the robot is current in Test mode and enabled.\n"
"\n"
":returns: True if the robot is currently operating in Test mode while\n"
"          enabled as determined by the Driver Station.")
  )
  
  
  
    
  .
def
("startCompetition", &frc::RobotBase::StartCompetition, release_gil(), py::doc(
    "Start the main robot code. This function will be called once and should not\n"
"exit until signalled by EndCompetition()")
  )
  
  
  
    
  .
def
("endCompetition", &frc::RobotBase::EndCompetition, release_gil(), py::doc(
    "Ends the main loop in StartCompetition().")
  )
  
  
  
    
  .
def_static
("getRuntimeType", &frc::RobotBase::GetRuntimeType, release_gil(), py::doc(
    "Get the current runtime type.\n"
"\n"
":returns: Current runtime type.")
  )
  
  
  
    
  .
def_static
("isReal", &frc::RobotBase::IsReal, release_gil(), py::doc(
    "Get if the robot is real.\n"
"\n"
":returns: If the robot is running in the real world.")
  )
  
  
  
    
  .
def_static
("isSimulation", &frc::RobotBase::IsSimulation, release_gil(), py::doc(
    "Get if the robot is a simulation.\n"
"\n"
":returns: If the robot is running in simulation.")
  )
  
  
  
    
  .def(py::init<>(), release_gil(), py::doc(
    "Constructor for a generic robot program.\n"
"\n"
"User code can be placed in the constructor that runs before the\n"
"Autonomous or Operator Control period starts. The constructor will run to\n"
"completion before Autonomous is entered.\n"
"\n"
"This must be used to ensure that the communications code starts. In the\n"
"future it would be nice to put this code into it's own task that loads on\n"
"boot so ensure that it runs.")
  )
  
  
  .def_static("main",
  [](py::object robot_cls) -> py::object {
    auto start = py::module::import("wpilib._impl.start");
    auto starter = start.attr("RobotStarter")();
    return starter.attr("run")(robot_cls);
  },
  py::arg("robot_cls"), py::doc("Starting point for the application"))
.def(
  "getControlState",
  [](RobotBase *self) -> std::tuple<bool, bool, bool> {
    py::gil_scoped_release release;
    return rpy::GetControlState();
  },
  py::doc("More efficient way to determine what state the robot is in.\n"
          "\n"
          ":returns: booleans representing enabled, isautonomous, istest\n"
          "\n"
          ".. versionadded:: 2019.2.1\n"
          "\n"
          ".. note:: This function only exists in RobotPy\n"));

auto logger = py::module::import("logging").attr("getLogger")("robot");
cls_RobotBase.attr("logger") = logger;
;

  


  }






}

}; // struct rpybuild_RobotBase_initializer

static std::unique_ptr<rpybuild_RobotBase_initializer> cls;

void begin_init_RobotBase(py::module &m) {
  cls = std::make_unique<rpybuild_RobotBase_initializer>(m);
}

void finish_init_RobotBase() {
  cls->finish();
  cls.reset();
}