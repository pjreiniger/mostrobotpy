
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/Watchdog.h>


#include <pybind11/functional.h>

#include <units_time_type_caster.h>















#include <type_traits>


  using namespace frc;



struct rpybuild_Watchdog_initializer {


  

  












  py::class_<typename frc::Watchdog> cls_Watchdog;

    

    
    

  py::module &m;

  
  rpybuild_Watchdog_initializer(py::module &m) :

  

  

  

  
    cls_Watchdog(m, "Watchdog"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_Watchdog.doc() =
    "A class that's a wrapper around a watchdog timer.\n"
"\n"
"When the timer expires, a message is printed to the console and an optional\n"
"user-provided callback is invoked.\n"
"\n"
"The watchdog is initialized disabled, so the user needs to call Enable()\n"
"before use.";

  cls_Watchdog
  
    
  .def(py::init<units::second_t, std::function<void ()>>(),
      py::arg("timeout"), py::arg("callback").none(false), release_gil(), py::doc(
    "Watchdog constructor.\n"
"\n"
":param timeout:  The watchdog's timeout in seconds with microsecond\n"
"                 resolution.\n"
":param callback: This function is called when the timeout expires.")
  )
  
  
  
    
  .
def
("getTime", &frc::Watchdog::GetTime, release_gil(), py::doc(
    "Returns the time since the watchdog was last fed.")
  )
  
  
  
    
  .
def
("setTimeout", &frc::Watchdog::SetTimeout,
      py::arg("timeout"), release_gil(), py::doc(
    "Sets the watchdog's timeout.\n"
"\n"
":param timeout: The watchdog's timeout in seconds with microsecond\n"
"                resolution.")
  )
  
  
  
    
  .
def
("getTimeout", &frc::Watchdog::GetTimeout, release_gil(), py::doc(
    "Returns the watchdog's timeout.")
  )
  
  
  
    
  .
def
("isExpired", &frc::Watchdog::IsExpired, release_gil(), py::doc(
    "Returns true if the watchdog timer has expired.")
  )
  
  
  
    
  .
def
("addEpoch", &frc::Watchdog::AddEpoch,
      py::arg("epochName"), release_gil(), py::doc(
    "Adds time since last epoch to the list printed by PrintEpochs().\n"
"\n"
"Epochs are a way to partition the time elapsed so that when overruns occur,\n"
"one can determine which parts of an operation consumed the most time.\n"
"\n"
":param epochName: The name to associate with the epoch.")
  )
  
  
  
    
  .
def
("printEpochs", &frc::Watchdog::PrintEpochs, release_gil(), py::doc(
    "Prints list of epochs added so far and their times.")
  )
  
  
  
    
  .
def
("reset", &frc::Watchdog::Reset, release_gil(), py::doc(
    "Resets the watchdog timer.\n"
"\n"
"This also enables the timer if it was previously disabled.")
  )
  
  
  
    
  .
def
("enable", &frc::Watchdog::Enable, release_gil(), py::doc(
    "Enables the watchdog timer.")
  )
  
  
  
    
  .
def
("disable", &frc::Watchdog::Disable, release_gil(), py::doc(
    "Disables the watchdog timer.")
  )
  
  
  
    
  .
def
("suppressTimeoutMessage", &frc::Watchdog::SuppressTimeoutMessage,
      py::arg("suppress"), release_gil(), py::doc(
    "Enable or disable suppression of the generic timeout message.\n"
"\n"
"This may be desirable if the user-provided callback already prints a more\n"
"specific message.\n"
"\n"
":param suppress: Whether to suppress generic timeout message.")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_Watchdog_initializer

static std::unique_ptr<rpybuild_Watchdog_initializer> cls;

void begin_init_Watchdog(py::module &m) {
  cls = std::make_unique<rpybuild_Watchdog_initializer>(m);
}

void finish_init_Watchdog() {
  cls->finish();
  cls.reset();
}