
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/Alert.h>
















#include <type_traits>


  using namespace frc;



struct rpybuild_Alert_initializer {


  

  












  py::class_<typename frc::Alert> cls_Alert;

    
    
  py::enum_<frc::Alert::AlertType> cls_Alert_enum1;
    

    
    

  py::module &m;

  
  rpybuild_Alert_initializer(py::module &m) :

  

  

  

  
    cls_Alert(m, "Alert"),

  
    cls_Alert_enum1
  (cls_Alert, "AlertType"
  ,
    "Represents an alert's level of urgency."),
  

  
  
  

    m(m)
  {
    
    

    
    
  
    cls_Alert_enum1
  
    .value("kError", frc::Alert::AlertType::kError,
      "High priority alert - displayed first on the dashboard with a red \"X\"\n"
"symbol. Use this type for problems which will seriously affect the\n"
"robot's functionality and thus require immediate attention.")
  
    .value("kWarning", frc::Alert::AlertType::kWarning,
      "Medium priority alert - displayed second on the dashboard with a yellow\n"
"\"!\" symbol. Use this type for problems which could affect the robot's\n"
"functionality but do not necessarily require immediate attention.")
  
    .value("kInfo", frc::Alert::AlertType::kInfo,
      "Low priority alert - displayed last on the dashboard with a green \"i\"\n"
"symbol. Use this type for problems which are unlikely to affect the\n"
"robot's functionality, or any other alerts which do not fall under the\n"
"other categories.")
  ;

  

    
    
  }

void finish() {





  {
  
  
  using AlertType [[maybe_unused]] = typename frc::Alert::AlertType;
  
  


  

  cls_Alert.doc() =
    "Persistent alert to be sent via NetworkTables. Alerts are tagged with a type\n"
"of kError, kWarning, or kInfo to denote urgency. See Alert::AlertType for\n"
"suggested usage of each type. Alerts can be displayed on supported\n"
"dashboards, and are shown in a priority order based on type and recency of\n"
"activation.\n"
"\n"
"Alerts should be created once and stored persistently, then updated to\n"
"\"active\" or \"inactive\" as necessary. Set(bool) can be safely called\n"
"periodically.\n"
"\n"
"This API is new for 2025, but is likely to change in future seasons to\n"
"facilitate deeper integration with the robot control system.\n"
"\n"
"::\n"
"\n"
"  class Robot {\n"
"    frc::Alert alert{\"Something went wrong\", frc::Alert::AlertType::kWarning};\n"
"  }\n"
"  \n"
"  Robot::periodic() {\n"
"    alert.Set(...);\n"
"  }";

  cls_Alert
  
    
  .def(py::init<std::string_view, AlertType>(),
      py::arg("text"), py::arg("type"), release_gil(), py::doc(
    "Creates a new alert in the default group - \"Alerts\". If this is the first\n"
"to be instantiated, the appropriate entries will be added to NetworkTables.\n"
"\n"
":param text: Text to be displayed when the alert is active.\n"
":param type: Alert urgency level.")
  )
  
  
  
    
  .def(py::init<std::string_view, std::string_view, AlertType>(),
      py::arg("group"), py::arg("text"), py::arg("type"), release_gil(), py::doc(
    "Creates a new alert. If this is the first to be instantiated in its group,\n"
"the appropriate entries will be added to NetworkTables.\n"
"\n"
":param group: Group identifier, used as the entry name in NetworkTables.\n"
":param text:  Text to be displayed when the alert is active.\n"
":param type:  Alert urgency level.")
  )
  
  
  
    
  .
def
("set", &frc::Alert::Set,
      py::arg("active"), release_gil(), py::doc(
    "Sets whether the alert should currently be displayed. This method can be\n"
"safely called periodically.\n"
"\n"
":param active: Whether to display the alert.")
  )
  
  
  
    
  .
def
("setText", &frc::Alert::SetText,
      py::arg("text"), release_gil(), py::doc(
    "Updates current alert text. Use this method to dynamically change the\n"
"displayed alert, such as including more details about the detected problem.\n"
"\n"
":param text: Text to be displayed when the alert is active.")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_Alert_initializer

static std::unique_ptr<rpybuild_Alert_initializer> cls;

void begin_init_Alert(py::module &m) {
  cls = std::make_unique<rpybuild_Alert_initializer>(m);
}

void finish_init_Alert() {
  cls->finish();
  cls.reset();
}