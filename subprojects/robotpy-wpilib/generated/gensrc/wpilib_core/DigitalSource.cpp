
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/DigitalSource.h>








#define RPYGEN_ENABLE_frc__DigitalSource_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__DigitalSource.hpp>









#include <type_traits>


  using namespace frc;





struct rpybuild_DigitalSource_initializer {


  

  












  
  using DigitalSource_Trampoline = rpygen::PyTrampoline_frc__DigitalSource<typename frc::DigitalSource, typename rpygen::PyTrampolineCfg_frc__DigitalSource<>>;
    static_assert(std::is_abstract<DigitalSource_Trampoline>::value == false, "frc::DigitalSource " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::DigitalSource, DigitalSource_Trampoline> cls_DigitalSource;

    

    
    

  py::module &m;

  
  rpybuild_DigitalSource_initializer(py::module &m) :

  

  

  

  
    cls_DigitalSource(m, "DigitalSource"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_DigitalSource.doc() =
    "DigitalSource Interface.\n"
"\n"
"The DigitalSource represents all the possible inputs for a counter or a\n"
"quadrature encoder. The source may be either a digital input or an analog\n"
"input. If the caller just provides a channel, then a digital input will be\n"
"constructed and freed when finished for the source. The source can either be\n"
"a digital input or analog trigger but not both.";

  cls_DigitalSource
  
    
  .def(py::init<>(), release_gil()
  )
  
  
  
    
  .
def
("getPortHandleForRouting", &frc::DigitalSource::GetPortHandleForRouting, release_gil()
  )
  
  
  
    
  .
def
("getAnalogTriggerTypeForRouting", &frc::DigitalSource::GetAnalogTriggerTypeForRouting, release_gil()
  )
  
  
  
    
  .
def
("isAnalogTrigger", &frc::DigitalSource::IsAnalogTrigger, release_gil()
  )
  
  
  
    
  .
def
("getChannel", &frc::DigitalSource::GetChannel, release_gil()
  )
  
  
  ;

  


  }







  cls_DigitalSource
  .def("__repr__", [](py::handle self) {
    py::object type_name = self.get_type().attr("__qualname__");
    int channel = self.cast<DigitalSource&>().GetChannel();
    return py::str("<{} {}>").format(type_name, channel);
  });


}

}; // struct rpybuild_DigitalSource_initializer

static std::unique_ptr<rpybuild_DigitalSource_initializer> cls;

void begin_init_DigitalSource(py::module &m) {
  cls = std::make_unique<rpybuild_DigitalSource_initializer>(m);
}

void finish_init_DigitalSource() {
  cls->finish();
  cls.reset();
}