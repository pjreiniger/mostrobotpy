
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/smartdashboard/SmartDashboard.h>


#include <pybind11/functional.h>

#include <pybind11/stl.h>

#include <wpi_span_type_caster.h>













#include <src/rpy/SmartDashboardData.h>

#include <frc/Errors.h>

#include <wpi/sendable/SendableRegistry.h>



#include <type_traits>


  using namespace wpi;

  using namespace frc;



struct rpybuild_SmartDashboard_initializer {


  

  












  py::class_<typename frc::SmartDashboard> cls_SmartDashboard;

    

    
    

  py::module &m;

  
  rpybuild_SmartDashboard_initializer(py::module &m) :

  

  

  

  
    cls_SmartDashboard(m, "SmartDashboard"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  

  cls_SmartDashboard
  
    
  .
def_static
("init", &frc::SmartDashboard::init, release_gil()
  )
  
  
  
    
  .
def_static
("containsKey", &frc::SmartDashboard::ContainsKey,
      py::arg("key"), release_gil(), py::doc(
    "Determines whether the given key is in this table.\n"
"\n"
":param key: the key to search for\n"
"\n"
":returns: true if the table as a value assigned to the given key")
  )
  
  
  
    
  .
def_static
("getKeys", &frc::SmartDashboard::GetKeys,
      py::arg("types") = 0, release_gil(), py::doc(
    "\n"
"\n"
":param types: bitmask of types; 0 is treated as a \"don't care\".\n"
"\n"
":returns: keys currently in the table")
  )
  
  
  
    
  .
def_static
("setPersistent", &frc::SmartDashboard::SetPersistent,
      py::arg("key"), release_gil(), py::doc(
    "Makes a key's value persistent through program restarts.\n"
"\n"
":param key: the key to make persistent")
  )
  
  
  
    
  .
def_static
("clearPersistent", &frc::SmartDashboard::ClearPersistent,
      py::arg("key"), release_gil(), py::doc(
    "Stop making a key's value persistent through program restarts.\n"
"The key cannot be null.\n"
"\n"
":param key: the key name")
  )
  
  
  
    
  .
def_static
("isPersistent", &frc::SmartDashboard::IsPersistent,
      py::arg("key"), release_gil(), py::doc(
    "Returns whether the value is persistent through program restarts.\n"
"The key cannot be null.\n"
"\n"
":param key: the key name")
  )
  
  
  
    
  .
def_static
("getEntry", &frc::SmartDashboard::GetEntry,
      py::arg("key"), release_gil(), py::doc(
    "Returns an NT Entry mapping to the specified key\n"
"\n"
"This is useful if an entry is used often, or is read and then modified.\n"
"\n"
":param key: the key\n"
"\n"
":returns: the entry for the key")
  )
  
  
  
    
  .
def_static
("putData", [](py::str &key, std::shared_ptr<wpi::Sendable> data) {
  if (!data) {
    throw FRC_MakeError(err::NullParameter, "{}", "value");
  }

  // convert key to a raw string so that we can create a StringRef
  Py_ssize_t raw_size;
  const char *raw_str = PyUnicode_AsUTF8AndSize(key.ptr(), &raw_size);
  if (raw_str == NULL) {
    throw py::error_already_set();
  }

  std::string_view keyRef(raw_str, raw_size);
  frc::SmartDashboard::PutData(keyRef, data.get());

  // this comes after the PutData to ensure that the original object doesn't die
  // while PutData is called
  rpy::addSmartDashboardData(key, data);
}
,
      py::arg("key"), py::arg("data"), py::doc(
    "Maps the specified key to the specified value in this table.\n"
"\n"
"The value can be retrieved by calling the get method with a key that is\n"
"equal to the original key.\n"
"\n"
"In order for the value to appear in the dashboard, it must be registered\n"
"with SendableRegistry.  WPILib components do this automatically.\n"
"\n"
":param key:  the key\n"
":param data: the value")
  )
  
  
  
    
  .
def_static
("putData", [](std::shared_ptr<wpi::Sendable> value) {
  frc::SmartDashboard::PutData(value.get());
  // this comes after the PutData to ensure that the original object doesn't die
  // while PutData is called
  auto name = wpi::SendableRegistry::GetName(value.get());
  if (!name.empty()) {
    py::str key(name);
    rpy::addSmartDashboardData(key, value);
  }
}
,
      py::arg("value"), py::doc(
    "Maps the specified key (where the key is the name of the Sendable)\n"
"to the specified value in this table.\n"
"\n"
"The value can be retrieved by calling the get method with a key that is\n"
"equal to the original key.\n"
"\n"
"In order for the value to appear in the dashboard, it must be registered\n"
"with SendableRegistry.  WPILib components do this automatically.\n"
"\n"
":param value: the value")
  )
  
  
  
    
  .
def_static
("getData", &frc::SmartDashboard::GetData,
      py::arg("keyName"), release_gil(), py::doc(
    "Returns the value at the specified key.\n"
"\n"
":param keyName: the key\n"
"\n"
":returns: the value")
  )
  
  
  
    
  .
def_static
("putBoolean", &frc::SmartDashboard::PutBoolean,
      py::arg("keyName"), py::arg("value"), release_gil(), py::doc(
    "Maps the specified key to the specified value in this table.\n"
"\n"
"The value can be retrieved by calling the get method with a key that is\n"
"equal to the original key.\n"
"\n"
":param keyName: the key\n"
":param value:   the value\n"
"\n"
":returns: False if the table key already exists with a different type")
  )
  
  
  
    
  .
def_static
("setDefaultBoolean", &frc::SmartDashboard::SetDefaultBoolean,
      py::arg("key"), py::arg("defaultValue"), release_gil(), py::doc(
    "Gets the current value in the table, setting it if it does not exist.\n"
"\n"
":param key:          the key\n"
":param defaultValue: the default value to set if key doesn't exist.\n"
"\n"
":returns: False if the table key exists with a different type")
  )
  
  
  
    
  .
def_static
("getBoolean", [](std::string_view key, py::object defaultValue) -> py::object {
    nt::Value value;
    {
      py::gil_scoped_release release;
      auto entry = frc::SmartDashboard::GetEntry(key);
      value = nt::GetEntryValue(entry.GetHandle());
    }
    if (!value || value.type() != NT_BOOLEAN) return defaultValue;
    return py::cast(value.GetBoolean());
}
,
      py::arg("keyName"), py::arg("defaultValue"), py::doc(
    "Returns the value at the specified key.\n"
"\n"
"If the key is not found, returns the default value.\n"
"\n"
":param keyName:      the key\n"
":param defaultValue: the default value to set if key doesn't exist\n"
"\n"
":returns: the value")
  )
  
  
  
    
  .
def_static
("putNumber", &frc::SmartDashboard::PutNumber,
      py::arg("keyName"), py::arg("value"), release_gil(), py::doc(
    "Maps the specified key to the specified value in this table.\n"
"\n"
"The value can be retrieved by calling the get method with a key that is\n"
"equal to the original key.\n"
"\n"
":param keyName: the key\n"
":param value:   the value\n"
"\n"
":returns: False if the table key already exists with a different type")
  )
  
  
  
    
  .
def_static
("setDefaultNumber", &frc::SmartDashboard::SetDefaultNumber,
      py::arg("key"), py::arg("defaultValue"), release_gil(), py::doc(
    "Gets the current value in the table, setting it if it does not exist.\n"
"\n"
":param key:          The key.\n"
":param defaultValue: The default value to set if key doesn't exist.\n"
"\n"
":returns: False if the table key exists with a different type")
  )
  
  
  
    
  .
def_static
("getNumber", [](std::string_view key, py::object defaultValue) -> py::object {
    nt::Value value;
    {
      py::gil_scoped_release release;
      auto entry = frc::SmartDashboard::GetEntry(key);
      value = nt::GetEntryValue(entry.GetHandle());
    }
    if (!value || value.type() != NT_DOUBLE) return defaultValue;
    return py::cast(value.GetDouble());
}
,
      py::arg("keyName"), py::arg("defaultValue"), py::doc(
    "Returns the value at the specified key.\n"
"\n"
"If the key is not found, returns the default value.\n"
"\n"
":param keyName:      the key\n"
":param defaultValue: the default value to set if the key doesn't exist\n"
"\n"
":returns: the value")
  )
  
  
  
    
  .
def_static
("putString", &frc::SmartDashboard::PutString,
      py::arg("keyName"), py::arg("value"), release_gil(), py::doc(
    "Maps the specified key to the specified value in this table.\n"
"\n"
"The value can be retrieved by calling the get method with a key that is\n"
"equal to the original key.\n"
"\n"
":param keyName: the key\n"
":param value:   the value\n"
"\n"
":returns: False if the table key already exists with a different type")
  )
  
  
  
    
  .
def_static
("setDefaultString", &frc::SmartDashboard::SetDefaultString,
      py::arg("key"), py::arg("defaultValue"), release_gil(), py::doc(
    "Gets the current value in the table, setting it if it does not exist.\n"
"\n"
":param key:          the key\n"
":param defaultValue: the default value to set if key doesn't exist.\n"
"\n"
":returns: False if the table key exists with a different type")
  )
  
  
  
    
  .
def_static
("getString", [](std::string_view key, py::object defaultValue) -> py::object {
    nt::Value value;
    {
      py::gil_scoped_release release;
      auto entry = frc::SmartDashboard::GetEntry(key);
      value = nt::GetEntryValue(entry.GetHandle());
    }
    if (!value || value.type() != NT_STRING) return defaultValue;
    return py::cast(value.GetString());
}
,
      py::arg("keyName"), py::arg("defaultValue"), py::doc(
    "Returns the value at the specified key.\n"
"\n"
"If the key is not found, returns the default value.\n"
"\n"
":param keyName:      the key\n"
":param defaultValue: the default value to set if the key doesn't exist\n"
"\n"
":returns: the value")
  )
  
  
  
    
  .
def_static
("putBooleanArray", &frc::SmartDashboard::PutBooleanArray,
      py::arg("key"), py::arg("value"), release_gil(), py::doc(
    "Put a boolean array in the table.\n"
"\n"
":param key:   the key to be assigned to\n"
":param value: the value that will be assigned\n"
"\n"
":returns: False if the table key already exists with a different type\n"
"          \n"
"          .. note:: The array must be of int's rather than of bool's because\n"
"             std::vector<bool> is special-cased in C++. 0 is false, any\n"
"             non-zero value is true.")
  )
  
  
  
    
  .
def_static
("setDefaultBooleanArray", &frc::SmartDashboard::SetDefaultBooleanArray,
      py::arg("key"), py::arg("defaultValue"), release_gil(), py::doc(
    "Gets the current value in the table, setting it if it does not exist.\n"
"\n"
":param key:          the key\n"
":param defaultValue: the default value to set if key doesn't exist.\n"
"\n"
":returns: False if the table key exists with a different type")
  )
  
  
  
    
  .
def_static
("getBooleanArray", [](std::string_view key, py::object defaultValue) -> py::object {
  nt::Value value;
  {
    py::gil_scoped_release release;
    auto entry = frc::SmartDashboard::GetEntry(key);
    value = nt::GetEntryValue(entry.GetHandle());
  }
  if (!value || value.type() != NT_BOOLEAN_ARRAY) return defaultValue;
  // ntcore will return bit vector by default. Convert to List[bool]
  auto v = value.value();
  py::list l(v.data.arr_boolean.size);
  for (size_t i = 0; i < v.data.arr_boolean.size; i++) {
    auto b = py::bool_(v.data.arr_boolean.arr[i]);
      PyList_SET_ITEM(l.ptr(), i, b.release().ptr());
  }
  return l;
}
,
      py::arg("key"), py::arg("defaultValue"), py::doc(
    "Returns the boolean array the key maps to.\n"
"\n"
"If the key does not exist or is of different type, it will return the\n"
"default value.\n"
"\n"
":param key:          The key to look up.\n"
":param defaultValue: The value to be returned if no value is found.\n"
"\n"
":returns: the value associated with the given key or the given default value\n"
"          if there is no value associated with the key\n"
"          \n"
"          .. note:: This makes a copy of the array. If the overhead of this is a concern,\n"
"             use GetValue() instead.\n"
"          \n"
"          .. note:: The returned array is std::vector<int> instead of std::vector<bool>\n"
"             because std::vector<bool> is special-cased in C++. 0 is false, any\n"
"             non-zero value is true.")
  )
  
  
  
    
  .
def_static
("putNumberArray", &frc::SmartDashboard::PutNumberArray,
      py::arg("key"), py::arg("value"), release_gil(), py::doc(
    "Put a number array in the table.\n"
"\n"
":param key:   The key to be assigned to.\n"
":param value: The value that will be assigned.\n"
"\n"
":returns: False if the table key already exists with a different type")
  )
  
  
  
    
  .
def_static
("setDefaultNumberArray", &frc::SmartDashboard::SetDefaultNumberArray,
      py::arg("key"), py::arg("defaultValue"), release_gil(), py::doc(
    "Gets the current value in the table, setting it if it does not exist.\n"
"\n"
":param key:          The key.\n"
":param defaultValue: The default value to set if key doesn't exist.\n"
"\n"
":returns: False if the table key exists with a different type")
  )
  
  
  
    
  .
def_static
("getNumberArray", [](std::string_view key, py::object defaultValue) -> py::object {
    nt::Value value;
    {
      py::gil_scoped_release release;
      auto entry = frc::SmartDashboard::GetEntry(key);
      value = nt::GetEntryValue(entry.GetHandle());
    }
    if (!value || value.type() != NT_DOUBLE_ARRAY) return defaultValue;
    return py::cast(value.GetDoubleArray());
}
,
      py::arg("key"), py::arg("defaultValue"), py::doc(
    "Returns the number array the key maps to.\n"
"\n"
"If the key does not exist or is of different type, it will return the\n"
"default value.\n"
"\n"
":param key:          The key to look up.\n"
":param defaultValue: The value to be returned if no value is found.\n"
"\n"
":returns: the value associated with the given key or the given default value\n"
"          if there is no value associated with the key\n"
"          \n"
"          .. note:: This makes a copy of the array. If the overhead of this is a concern,\n"
"             use GetValue() instead.")
  )
  
  
  
    
  .
def_static
("putStringArray", &frc::SmartDashboard::PutStringArray,
      py::arg("key"), py::arg("value"), release_gil(), py::doc(
    "Put a string array in the table.\n"
"\n"
":param key:   The key to be assigned to.\n"
":param value: The value that will be assigned.\n"
"\n"
":returns: False if the table key already exists with a different type")
  )
  
  
  
    
  .
def_static
("setDefaultStringArray", &frc::SmartDashboard::SetDefaultStringArray,
      py::arg("key"), py::arg("defaultValue"), release_gil(), py::doc(
    "Gets the current value in the table, setting it if it does not exist.\n"
"\n"
":param key:          The key.\n"
":param defaultValue: The default value to set if key doesn't exist.\n"
"\n"
":returns: False if the table key exists with a different type")
  )
  
  
  
    
  .
def_static
("getStringArray", [](std::string_view key, py::object defaultValue) -> py::object {
    nt::Value value;
    {
      py::gil_scoped_release release;
      auto entry = frc::SmartDashboard::GetEntry(key);
      value = nt::GetEntryValue(entry.GetHandle());
    }
    if (!value || value.type() != NT_STRING_ARRAY) return defaultValue;
    return py::cast(value.GetStringArray());
}
,
      py::arg("key"), py::arg("defaultValue"), py::doc(
    "Returns the string array the key maps to.\n"
"\n"
"If the key does not exist or is of different type, it will return the\n"
"default value.\n"
"\n"
":param key:          The key to look up.\n"
":param defaultValue: The value to be returned if no value is found.\n"
"\n"
":returns: the value associated with the given key or the given default value\n"
"          if there is no value associated with the key\n"
"          \n"
"          .. note:: This makes a copy of the array. If the overhead of this is a concern,\n"
"             use GetValue() instead.")
  )
  
  
  
    
  .
def_static
("putRaw", &frc::SmartDashboard::PutRaw,
      py::arg("key"), py::arg("value"), release_gil(), py::doc(
    "Put a raw value (byte array) in the table.\n"
"\n"
":param key:   The key to be assigned to.\n"
":param value: The value that will be assigned.\n"
"\n"
":returns: False if the table key already exists with a different type")
  )
  
  
  
    
  .
def_static
("setDefaultRaw", &frc::SmartDashboard::SetDefaultRaw,
      py::arg("key"), py::arg("defaultValue"), release_gil(), py::doc(
    "Gets the current value in the table, setting it if it does not exist.\n"
"\n"
":param key:          The key.\n"
":param defaultValue: The default value to set if key doesn't exist.\n"
"\n"
":returns: False if the table key exists with a different type")
  )
  
  
  
    
  .
def_static
("getRaw", [](std::string_view key, py::object defaultValue) -> py::object {
    nt::Value value;
    {
      py::gil_scoped_release release;
      auto entry = frc::SmartDashboard::GetEntry(key);
      value = nt::GetEntryValue(entry.GetHandle());
    }
    if (!value || value.type() != NT_STRING) return defaultValue;
    return py::cast(value.GetString());
}
,
      py::arg("key"), py::arg("defaultValue"), py::doc(
    "Returns the raw value (byte array) the key maps to.\n"
"\n"
"If the key does not exist or is of different type, it will return the\n"
"default value.\n"
"\n"
":param key:          The key to look up.\n"
":param defaultValue: The value to be returned if no value is found.\n"
"\n"
":returns: the value associated with the given key or the given default value\n"
"          if there is no value associated with the key\n"
"          \n"
"          .. note:: This makes a copy of the raw contents. If the overhead of this is a\n"
"             concern, use GetValue() instead.")
  )
  
  
  
    
  .
def_static
("putValue", &frc::SmartDashboard::PutValue,
      py::arg("keyName"), py::arg("value"), release_gil(), py::doc(
    "Maps the specified key to the specified complex value (such as an array) in\n"
"this table.\n"
"\n"
"The value can be retrieved by calling the RetrieveValue method with a key\n"
"that is equal to the original key.\n"
"\n"
":param keyName: the key\n"
":param value:   the value\n"
"\n"
":returns: False if the table key already exists with a different type")
  )
  
  
  
    
  .
def_static
("setDefaultValue", &frc::SmartDashboard::SetDefaultValue,
      py::arg("key"), py::arg("defaultValue"), release_gil(), py::doc(
    "Gets the current value in the table, setting it if it does not exist.\n"
"\n"
":param key:          the key\n"
":param defaultValue: The default value to set if key doesn't exist.\n"
"\n"
":returns: False if the table key exists with a different type")
  )
  
  
  
    
  .
def_static
("getValue", &frc::SmartDashboard::GetValue,
      py::arg("keyName"), release_gil(), py::doc(
    "Retrieves the complex value (such as an array) in this table into the\n"
"complex data object.\n"
"\n"
":param keyName: the key")
  )
  
  
  
    
  .
def_static
("postListenerTask", &frc::SmartDashboard::PostListenerTask,
      py::arg("task").none(false), release_gil(), py::doc(
    "Posts a task from a listener to the ListenerExecutor, so that it can be run\n"
"synchronously from the main loop on the next call to updateValues().\n"
"\n"
":param task: The task to run synchronously from the main thread.")
  )
  
  
  
    
  .
def_static
("updateValues", &frc::SmartDashboard::UpdateValues, release_gil(), py::doc(
    "Puts all sendable data to the dashboard.")
  )
  
  
  ;

  


  }







  // ensure that the smart dashboard data is released when python shuts down
static int unused; // the capsule needs something to reference
py::capsule cleanup(&unused, [](void *) {
    rpy::destroySmartDashboardData();
});
m.add_object("_sd_cleanup", cleanup);
m.def("_clearSmartDashboardData", &rpy::clearSmartDashboardData);

}

}; // struct rpybuild_SmartDashboard_initializer

static std::unique_ptr<rpybuild_SmartDashboard_initializer> cls;

void begin_init_SmartDashboard(py::module &m) {
  cls = std::make_unique<rpybuild_SmartDashboard_initializer>(m);
}

void finish_init_SmartDashboard() {
  cls->finish();
  cls.reset();
}