
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/SynchronousInterrupt.h>


#include <units_time_type_caster.h>













#include <frc/DigitalSource.h>



#include <type_traits>


  using namespace frc;





struct rpybuild_SynchronousInterrupt_initializer {


  

  












  py::class_<typename frc::SynchronousInterrupt> cls_SynchronousInterrupt;

    
    
  py::enum_<frc::SynchronousInterrupt::WaitResult> cls_SynchronousInterrupt_enum1;
    

    
    

  py::module &m;

  
  rpybuild_SynchronousInterrupt_initializer(py::module &m) :

  

  

  

  
    cls_SynchronousInterrupt(m, "SynchronousInterrupt"),

  
    cls_SynchronousInterrupt_enum1
  (cls_SynchronousInterrupt, "WaitResult"
  ,
    "Event trigger combinations for a synchronous interrupt."),
  

  
  
  

    m(m)
  {
    
    

    
    
  
    cls_SynchronousInterrupt_enum1
  
    .value("kTimeout", frc::SynchronousInterrupt::WaitResult::kTimeout,
      "Timeout event.")
  
    .value("kRisingEdge", frc::SynchronousInterrupt::WaitResult::kRisingEdge,
      "Rising edge event.")
  
    .value("kFallingEdge", frc::SynchronousInterrupt::WaitResult::kFallingEdge,
      "Falling edge event.")
  
    .value("kBoth", frc::SynchronousInterrupt::WaitResult::kBoth,
      "Both rising and falling edge events.")
  ;

  

    
    
  }

void finish() {





  {
  
  
  using WaitResult [[maybe_unused]] = typename frc::SynchronousInterrupt::WaitResult;
  
  


  

  cls_SynchronousInterrupt.doc() =
    "Class for handling synchronous (blocking) interrupts.\n"
"\n"
"By default, interrupts will occur on rising edge.\n"
"\n"
"Asynchronous interrupts are handled by the AsynchronousInterrupt class.";

  cls_SynchronousInterrupt
  
    
  .def(py::init<DigitalSource&>(),
      py::arg("source"), release_gil()
    , py::keep_alive<1, 2>(), py::doc(
    "Construct a Synchronous Interrupt from a Digital Source.\n"
"\n"
":param source: the DigitalSource the interrupts are triggered from")
  )
  
  
  
    
  .def(py::init<DigitalSource*>(),
      py::arg("source"), release_gil(), py::doc(
    "Construct a Synchronous Interrupt from a Digital Source.\n"
"\n"
":param source: the DigitalSource the interrupts are triggered from")
  )
  
  
  
    
  .def(py::init<std::shared_ptr<DigitalSource>>(),
      py::arg("source"), release_gil(), py::doc(
    "Construct a Synchronous Interrupt from a Digital Source.\n"
"\n"
":param source: the DigitalSource the interrupts are triggered from")
  )
  
  
  
    
  .
def
("waitForInterrupt", &frc::SynchronousInterrupt::WaitForInterrupt,
      py::arg("timeout"), py::arg("ignorePrevious") = true, release_gil(), py::doc(
    "Wait for an interrupt to occur.\n"
"\n"
"Both rising and falling edge can be returned if both a rising and\n"
"falling happened between calls, and ignorePrevious is false.\n"
"\n"
":param timeout:        The timeout to wait for. 0s or less will return immediately.\n"
":param ignorePrevious: True to ignore any previous interrupts, false to\n"
"                       return interrupt value if an interrupt has occurred since last call.\n"
"\n"
":returns: The edge(s) that were triggered, or timeout.")
  )
  
  
  
    
  .
def
("setInterruptEdges", &frc::SynchronousInterrupt::SetInterruptEdges,
      py::arg("risingEdge"), py::arg("fallingEdge"), release_gil(), py::doc(
    "Set which edges cause an interrupt to occur.\n"
"\n"
":param risingEdge:  true to trigger on rising edge, false otherwise.\n"
":param fallingEdge: true to trigger on falling edge, false otherwise")
  )
  
  
  
    
  .
def
("getRisingTimestamp", &frc::SynchronousInterrupt::GetRisingTimestamp, release_gil(), py::doc(
    "Get the timestamp (relative to FPGA Time) of the last rising edge.\n"
"\n"
":returns: the timestamp in seconds relative to getFPGATime")
  )
  
  
  
    
  .
def
("getFallingTimestamp", &frc::SynchronousInterrupt::GetFallingTimestamp, release_gil(), py::doc(
    "Get the timestamp of the last falling edge.\n"
"\n"
"This function does not require the interrupt to be enabled to work.\n"
"\n"
"This only works if falling edge was configured using setInterruptEdges.\n"
"\n"
":returns: the timestamp in seconds relative to getFPGATime")
  )
  
  
  
    
  .
def
("wakeupWaitingInterrupt", &frc::SynchronousInterrupt::WakeupWaitingInterrupt, release_gil(), py::doc(
    "Wake up an existing wait call. Can be called from any thread.")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_SynchronousInterrupt_initializer

static std::unique_ptr<rpybuild_SynchronousInterrupt_initializer> cls;

void begin_init_SynchronousInterrupt(py::module &m) {
  cls = std::make_unique<rpybuild_SynchronousInterrupt_initializer>(m);
}

void finish_init_SynchronousInterrupt() {
  cls->finish();
  cls.reset();
}