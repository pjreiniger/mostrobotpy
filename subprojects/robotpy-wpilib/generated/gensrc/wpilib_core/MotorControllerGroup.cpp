
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <rpy/MotorControllerGroup.h>


#include <pybind11/stl.h>

#include <units_voltage_type_caster.h>







#define RPYGEN_ENABLE_frc__PyMotorControllerGroup_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__PyMotorControllerGroup.hpp>







#include <wpi/sendable/SendableBuilder.h>

#include <pybind11/stl.h>



#include <type_traits>


  using namespace frc;





struct rpybuild_MotorControllerGroup_initializer {


  

  












  
  using PyMotorControllerGroup_Trampoline = rpygen::PyTrampoline_frc__PyMotorControllerGroup<typename frc::PyMotorControllerGroup, typename rpygen::PyTrampolineCfg_frc__PyMotorControllerGroup<>>;
    static_assert(std::is_abstract<PyMotorControllerGroup_Trampoline>::value == false, "frc::PyMotorControllerGroup " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::PyMotorControllerGroup, PyMotorControllerGroup_Trampoline, wpi::Sendable, frc::MotorController> cls_PyMotorControllerGroup;

    

    
    

  py::module &m;

  
  rpybuild_MotorControllerGroup_initializer(py::module &m) :

  

  

  

  
    cls_PyMotorControllerGroup(m, "MotorControllerGroup"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  

  cls_PyMotorControllerGroup
  
    
  .def(py::init([](py::args args) {
  if (args.size() < 1) {
    throw py::type_error("requires 1+ arguments");
  }
  std::vector<std::shared_ptr<MotorController>> v;
  v.reserve(args.size());
  int i = 1;
  for (auto &arg: args) {
    try {
      auto mc = arg.cast<std::shared_ptr<MotorController>>();
      if (!mc) throw py::cast_error();
      v.push_back(mc);
    } catch (py::cast_error &e) {
      throw py::type_error(py::str("Argument {} must be a MotorController (got '{}')").format(i, py::repr(arg)));
    }
    i++;
  }
  return std::make_shared<PyMotorControllerGroup>(std::move(v));
}
)
  )
  
  
  
    
  .
def
("set", &frc::PyMotorControllerGroup::Set,
      py::arg("speed"), release_gil()
  )
  
  
  
    
  .
def
("setVoltage", &frc::PyMotorControllerGroup::SetVoltage,
      py::arg("output"), release_gil()
  )
  
  
  
    
  .
def
("get", &frc::PyMotorControllerGroup::Get, release_gil()
  )
  
  
  
    
  .
def
("setInverted", &frc::PyMotorControllerGroup::SetInverted,
      py::arg("isInverted"), release_gil()
  )
  
  
  
    
  .
def
("getInverted", &frc::PyMotorControllerGroup::GetInverted, release_gil()
  )
  
  
  
    
  .
def
("disable", &frc::PyMotorControllerGroup::Disable, release_gil()
  )
  
  
  
    
  .
def
("stopMotor", &frc::PyMotorControllerGroup::StopMotor, release_gil()
  )
  
  
  
    
  .
def
("initSendable", &frc::PyMotorControllerGroup::InitSendable,
      py::arg("builder"), release_gil()
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_MotorControllerGroup_initializer

static std::unique_ptr<rpybuild_MotorControllerGroup_initializer> cls;

void begin_init_MotorControllerGroup(py::module &m) {
  cls = std::make_unique<rpybuild_MotorControllerGroup_initializer>(m);
}

void finish_init_MotorControllerGroup() {
  cls->finish();
  cls.reset();
}