
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/BuiltInAccelerometer.h>








#define RPYGEN_ENABLE_frc__BuiltInAccelerometer_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__BuiltInAccelerometer.hpp>







#include <wpi/sendable/SendableBuilder.h>



#include <type_traits>


  using namespace frc;



struct rpybuild_BuiltInAccelerometer_initializer {


  

  static constexpr auto kRange_8G = frc::BuiltInAccelerometer::Range::kRange_8G;
  












  
  using BuiltInAccelerometer_Trampoline = rpygen::PyTrampoline_frc__BuiltInAccelerometer<typename frc::BuiltInAccelerometer, typename rpygen::PyTrampolineCfg_frc__BuiltInAccelerometer<>>;
    static_assert(std::is_abstract<BuiltInAccelerometer_Trampoline>::value == false, "frc::BuiltInAccelerometer " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::BuiltInAccelerometer, BuiltInAccelerometer_Trampoline, wpi::Sendable> cls_BuiltInAccelerometer;

    
    
  py::enum_<frc::BuiltInAccelerometer::Range> cls_BuiltInAccelerometer_enum1;
    

    
    

  py::module &m;

  
  rpybuild_BuiltInAccelerometer_initializer(py::module &m) :

  

  

  

  
    cls_BuiltInAccelerometer(m, "BuiltInAccelerometer"),

  
    cls_BuiltInAccelerometer_enum1
  (cls_BuiltInAccelerometer, "Range"
  ,
    "Accelerometer range."),
  

  
  
  

    m(m)
  {
    
    

    
    
  
    cls_BuiltInAccelerometer_enum1
  
    .value("kRange_2G", frc::BuiltInAccelerometer::Range::kRange_2G,
      "2 Gs max.")
  
    .value("kRange_4G", frc::BuiltInAccelerometer::Range::kRange_4G,
      "4 Gs max.")
  
    .value("kRange_8G", frc::BuiltInAccelerometer::Range::kRange_8G,
      "8 Gs max.")
  ;

  

    
    
  }

void finish() {





  {
  
  
  using Range [[maybe_unused]] = typename frc::BuiltInAccelerometer::Range;
  
  


  

  cls_BuiltInAccelerometer.doc() =
    "Built-in accelerometer.\n"
"\n"
"This class allows access to the roboRIO's internal accelerometer.";

  cls_BuiltInAccelerometer
  
    
  .def(py::init<Range>(),
      py::arg("range") = kRange_8G, release_gil(), py::doc(
    "Constructor.\n"
"\n"
":param range: The range the accelerometer will measure")
  )
  
  
  
    
  .
def
("setRange", &frc::BuiltInAccelerometer::SetRange,
      py::arg("range"), release_gil(), py::doc(
    "Set the measuring range of the accelerometer.\n"
"\n"
":param range: The maximum acceleration, positive or negative, that the\n"
"              accelerometer will measure.")
  )
  
  
  
    
  .
def
("getX", &frc::BuiltInAccelerometer::GetX, release_gil(), py::doc(
    "\n"
"\n"
":returns: The acceleration of the roboRIO along the X axis in g-forces")
  )
  
  
  
    
  .
def
("getY", &frc::BuiltInAccelerometer::GetY, release_gil(), py::doc(
    "\n"
"\n"
":returns: The acceleration of the roboRIO along the Y axis in g-forces")
  )
  
  
  
    
  .
def
("getZ", &frc::BuiltInAccelerometer::GetZ, release_gil(), py::doc(
    "\n"
"\n"
":returns: The acceleration of the roboRIO along the Z axis in g-forces")
  )
  
  
  
    
  .
def
("initSendable", &frc::BuiltInAccelerometer::InitSendable,
      py::arg("builder"), release_gil()
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_BuiltInAccelerometer_initializer

static std::unique_ptr<rpybuild_BuiltInAccelerometer_initializer> cls;

void begin_init_BuiltInAccelerometer(py::module &m) {
  cls = std::make_unique<rpybuild_BuiltInAccelerometer_initializer>(m);
}

void finish_init_BuiltInAccelerometer() {
  cls->finish();
  cls.reset();
}