
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/Servo.h>








#define RPYGEN_ENABLE_frc__Servo_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__Servo.hpp>







#include <wpi/sendable/SendableBuilder.h>



#include <type_traits>


  using namespace frc;





struct rpybuild_Servo_initializer {


  

  












  
  using Servo_Trampoline = rpygen::PyTrampoline_frc__Servo<typename frc::Servo, typename rpygen::PyTrampolineCfg_frc__Servo<>>;
    static_assert(std::is_abstract<Servo_Trampoline>::value == false, "frc::Servo " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::Servo, Servo_Trampoline, frc::PWM> cls_Servo;

    

    
    

  py::module &m;

  
  rpybuild_Servo_initializer(py::module &m) :

  

  

  

  
    cls_Servo(m, "Servo"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_Servo.doc() =
    "Standard hobby style servo.\n"
"\n"
"The range parameters default to the appropriate values for the Hitec HS-322HD\n"
"servo provided in the FIRST Kit of Parts in 2008.";

  cls_Servo
  
    
  .def(py::init<int>(),
      py::arg("channel"), release_gil(), py::doc(
    "Constructor.\n"
"\n"
"By default, 2.4 ms is used as the max PWM value and 0.6 ms is used as the\n"
"min PWM value.\n"
"\n"
":param channel: The PWM channel to which the servo is attached. 0-9 are\n"
"                on-board, 10-19 are on the MXP port")
  )
  
  
  
    
  .
def
("set", &frc::Servo::Set,
      py::arg("value"), release_gil(), py::doc(
    "Set the servo position.\n"
"\n"
"Servo values range from 0.0 to 1.0 corresponding to the range of full left\n"
"to full right.\n"
"\n"
":param value: Position from 0.0 to 1.0.")
  )
  
  
  
    
  .
def
("setOffline", &frc::Servo::SetOffline, release_gil(), py::doc(
    "Set the servo to offline.\n"
"\n"
"Set the servo raw value to 0 (undriven)")
  )
  
  
  
    
  .
def
("get", &frc::Servo::Get, release_gil(), py::doc(
    "Get the servo position.\n"
"\n"
"Servo values range from 0.0 to 1.0 corresponding to the range of full left\n"
"to full right. This returns the commanded position, not the position that\n"
"the servo is actually at, as the servo does not report its own position.\n"
"\n"
":returns: Position from 0.0 to 1.0.")
  )
  
  
  
    
  .
def
("setAngle", &frc::Servo::SetAngle,
      py::arg("angle"), release_gil(), py::doc(
    "Set the servo angle.\n"
"\n"
"The angles are based on the HS-322HD Servo, and have a range of 0 to 180\n"
"degrees.\n"
"\n"
"Servo angles that are out of the supported range of the servo simply\n"
"\"saturate\" in that direction. In other words, if the servo has a range of\n"
"(X degrees to Y degrees) than angles of less than X result in an angle of\n"
"X being set and angles of more than Y degrees result in an angle of Y being\n"
"set.\n"
"\n"
":param angle: The angle in degrees to set the servo.")
  )
  
  
  
    
  .
def
("getAngle", &frc::Servo::GetAngle, release_gil(), py::doc(
    "Get the servo angle.\n"
"\n"
"This returns the commanded angle, not the angle that the servo is actually\n"
"at, as the servo does not report its own angle.\n"
"\n"
":returns: The angle in degrees to which the servo is set.")
  )
  
  
  
    
  .
def
("getMaxAngle", &frc::Servo::GetMaxAngle, release_gil(), py::doc(
    "Get the maximum angle of the servo.\n"
"\n"
":returns: The maximum angle of the servo in degrees.")
  )
  
  
  
    
  .
def
("getMinAngle", &frc::Servo::GetMinAngle, release_gil(), py::doc(
    "Get the minimum angle of the servo.\n"
"\n"
":returns: The minimum angle of the servo in degrees.")
  )
  
  
  
    
  .
def
("initSendable", &frc::Servo::InitSendable,
      py::arg("builder"), release_gil()
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_Servo_initializer

static std::unique_ptr<rpybuild_Servo_initializer> cls;

void begin_init_Servo(py::module &m) {
  cls = std::make_unique<rpybuild_Servo_initializer>(m);
}

void finish_init_Servo() {
  cls->finish();
  cls.reset();
}