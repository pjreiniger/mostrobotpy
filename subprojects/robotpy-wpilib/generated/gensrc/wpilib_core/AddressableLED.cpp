
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/AddressableLED.h>


#include <units_time_type_caster.h>

#include <wpi_span_type_caster.h>















#include <type_traits>


  using namespace frc;





struct rpybuild_AddressableLED_initializer {


  

  












  py::class_<typename frc::AddressableLED> cls_AddressableLED;

    

    
    
    py::class_<typename frc::AddressableLED::LEDData, ::HAL_AddressableLEDData> cls_LEDData;

    

    
    
    

  py::module &m;

  
  rpybuild_AddressableLED_initializer(py::module &m) :

  

  

  

  
    cls_AddressableLED(m, "AddressableLED"),

  

  
  
    cls_LEDData(cls_AddressableLED, "LEDData"),

  

  
  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  

    
    
  }

void finish() {





  {
  
  using LEDData [[maybe_unused]] = typename frc::AddressableLED::LEDData;
  
  
  


  

  cls_AddressableLED.doc() =
    "A class for driving addressable LEDs, such as WS2812Bs and NeoPixels.\n"
"\n"
"By default, the timing supports WS2812B LEDs, but is configurable using\n"
"SetBitTiming()\n"
"\n"
"Only 1 LED driver is currently supported by the roboRIO. However,\n"
"multiple LED strips can be connected in series and controlled from the\n"
"single driver.";

  cls_AddressableLED
  
    
  .def(py::init<int>(),
      py::arg("port"), release_gil(), py::doc(
    "Constructs a new driver for a specific port.\n"
"\n"
":param port: the output port to use (Must be a PWM header)")
  )
  
  
  
    
  .
def
("setLength", &frc::AddressableLED::SetLength,
      py::arg("length"), release_gil(), py::doc(
    "Sets the length of the LED strip.\n"
"\n"
"Calling this is an expensive call, so its best to call it once, then\n"
"just update data.\n"
"\n"
"The max length is 5460 LEDs.\n"
"\n"
":param length: the strip length")
  )
  
  
  
    
  .
def
("setData", static_cast<void(frc::AddressableLED::*)(std::span<const LEDData>)>(
        &frc::AddressableLED::SetData),
      py::arg("ledData"), release_gil(), py::doc(
    "Sets the led output data.\n"
"\n"
"If the output is enabled, this will start writing the next data cycle.\n"
"It is safe to call, even while output is enabled.\n"
"\n"
":param ledData: the buffer to write")
  )
  
  
  
    
  .
def
("setBitTiming", &frc::AddressableLED::SetBitTiming,
      py::arg("highTime0"), py::arg("lowTime0"), py::arg("highTime1"), py::arg("lowTime1"), release_gil(), py::doc(
    "Sets the bit timing.\n"
"\n"
"By default, the driver is set up to drive WS2812Bs, so nothing needs to\n"
"be set for those.\n"
"\n"
":param highTime0: high time for 0 bit (default 400ns)\n"
":param lowTime0:  low time for 0 bit (default 900ns)\n"
":param highTime1: high time for 1 bit (default 900ns)\n"
":param lowTime1:  low time for 1 bit (default 600ns)")
  )
  
  
  
    
  .
def
("setSyncTime", &frc::AddressableLED::SetSyncTime,
      py::arg("syncTime"), release_gil(), py::doc(
    "Sets the sync time.\n"
"\n"
"The sync time is the time to hold output so LEDs enable. Default set for\n"
"WS2812B.\n"
"\n"
":param syncTime: the sync time (default 280us)")
  )
  
  
  
    
  .
def
("start", &frc::AddressableLED::Start, release_gil(), py::doc(
    "Starts the output.\n"
"\n"
"The output writes continuously.")
  )
  
  
  
    
  .
def
("stop", &frc::AddressableLED::Stop, release_gil(), py::doc(
    "Stops the output.")
  )
  
  
  ;

  


  

  

  cls_LEDData
  
    
  .def(py::init<>(), release_gil()
  )
  
  
  
    
  .def(py::init<int, int, int>(),
      py::arg("r"), py::arg("g"), py::arg("b"), release_gil()
  )
  
  
  
    
  .
def
("setRGB", &frc::AddressableLED::LEDData::SetRGB,
      py::arg("r"), py::arg("g"), py::arg("b"), release_gil(), py::doc(
    "A helper method to set all values of the LED.\n"
"\n"
":param r: the r value [0-255]\n"
":param g: the g value [0-255]\n"
":param b: the b value [0-255]")
  )
  
  
  
    
  .
def
("setHSV", &frc::AddressableLED::LEDData::SetHSV,
      py::arg("h"), py::arg("s"), py::arg("v"), release_gil(), py::doc(
    "A helper method to set all values of the LED.\n"
"\n"
":param h: the h value [0-180]\n"
":param s: the s value [0-255]\n"
":param v: the v value [0-255]")
  )
  
  
  
    
  .
def
("setLED", static_cast<void(frc::AddressableLED::LEDData::*)(const Color&)>(
        &frc::AddressableLED::LEDData::SetLED),
      py::arg("color"), release_gil()
  )
  
  
  
    
  .
def
("setLED", static_cast<void(frc::AddressableLED::LEDData::*)(const Color8Bit&)>(
        &frc::AddressableLED::LEDData::SetLED),
      py::arg("color"), release_gil()
  )
  
  
  ;

  


  
  }






}

}; // struct rpybuild_AddressableLED_initializer

static std::unique_ptr<rpybuild_AddressableLED_initializer> cls;

void begin_init_AddressableLED(py::module &m) {
  cls = std::make_unique<rpybuild_AddressableLED_initializer>(m);
}

void finish_init_AddressableLED() {
  cls->finish();
  cls.reset();
}