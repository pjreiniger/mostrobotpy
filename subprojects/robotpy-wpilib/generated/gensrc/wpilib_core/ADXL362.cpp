
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/ADXL362.h>








#define RPYGEN_ENABLE_frc__ADXL362_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__ADXL362.hpp>







#include <networktables/NTSendableBuilder.h>

#include <frc/DigitalSource.h>



#include <type_traits>


  using namespace frc;



struct rpybuild_ADXL362_initializer {


  

  static constexpr auto kRange_2G = frc::ADXL362::Range::kRange_2G;
  












  
  using ADXL362_Trampoline = rpygen::PyTrampoline_frc__ADXL362<typename frc::ADXL362, typename rpygen::PyTrampolineCfg_frc__ADXL362<>>;
    static_assert(std::is_abstract<ADXL362_Trampoline>::value == false, "frc::ADXL362 " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::ADXL362, ADXL362_Trampoline, nt::NTSendable> cls_ADXL362;

    
    
  py::enum_<frc::ADXL362::Range> cls_ADXL362_enum1;
    
    
  py::enum_<frc::ADXL362::Axes> cls_ADXL362_enum2;
    

    
    
    py::class_<typename frc::ADXL362::AllAxes> cls_AllAxes;

    

    
    
    

  py::module &m;

  
  rpybuild_ADXL362_initializer(py::module &m) :

  

  

  

  
    cls_ADXL362(m, "ADXL362"),

  
    cls_ADXL362_enum1
  (cls_ADXL362, "Range"
  ,
    "Accelerometer range."),
  
    cls_ADXL362_enum2
  (cls_ADXL362, "Axes"
  ,
    "Accelerometer axes."),
  

  
  
    cls_AllAxes(cls_ADXL362, "AllAxes"),

  

  
  
  
  

    m(m)
  {
    
    

    
    
  
    cls_ADXL362_enum1
  
    .value("kRange_2G", frc::ADXL362::Range::kRange_2G,
      "2 Gs max.")
  
    .value("kRange_4G", frc::ADXL362::Range::kRange_4G,
      "4 Gs max.")
  
    .value("kRange_8G", frc::ADXL362::Range::kRange_8G,
      "8 Gs max.")
  ;

  
    cls_ADXL362_enum2
  
    .value("kAxis_X", frc::ADXL362::Axes::kAxis_X,
      "X axis.")
  
    .value("kAxis_Y", frc::ADXL362::Axes::kAxis_Y,
      "Y axis.")
  
    .value("kAxis_Z", frc::ADXL362::Axes::kAxis_Z,
      "Z axis.")
  ;

  

    
    
  

    
    
  }

void finish() {





  {
  
  using AllAxes [[maybe_unused]] = typename frc::ADXL362::AllAxes;
  
  
  using Range [[maybe_unused]] = typename frc::ADXL362::Range;
  
  using Axes [[maybe_unused]] = typename frc::ADXL362::Axes;
  
  


  

  cls_ADXL362.doc() =
    "ADXL362 SPI Accelerometer.\n"
"\n"
"This class allows access to an Analog Devices ADXL362 3-axis accelerometer.";

  cls_ADXL362
  
    
  .def(py::init<Range>(),
      py::arg("range") = kRange_2G, release_gil(), py::doc(
    "Constructor.  Uses the onboard CS1.\n"
"\n"
":param range: The range (+ or -) that the accelerometer will measure.")
  )
  
  
  
    
  .def(py::init<SPI::Port, Range>(),
      py::arg("port"), py::arg("range") = kRange_2G, release_gil(), py::doc(
    "Constructor.\n"
"\n"
":param port:  The SPI port the accelerometer is attached to\n"
":param range: The range (+ or -) that the accelerometer will measure.")
  )
  
  
  
    
  .
def
("getSpiPort", &frc::ADXL362::GetSpiPort, release_gil()
  )
  
  
  
    
  .
def
("setRange", &frc::ADXL362::SetRange,
      py::arg("range"), release_gil(), py::doc(
    "Set the measuring range of the accelerometer.\n"
"\n"
":param range: The maximum acceleration, positive or negative, that the\n"
"              accelerometer will measure.")
  )
  
  
  
    
  .
def
("getX", &frc::ADXL362::GetX, release_gil(), py::doc(
    "Returns the acceleration along the X axis in g-forces.\n"
"\n"
":returns: The acceleration along the X axis in g-forces.")
  )
  
  
  
    
  .
def
("getY", &frc::ADXL362::GetY, release_gil(), py::doc(
    "Returns the acceleration along the Y axis in g-forces.\n"
"\n"
":returns: The acceleration along the Y axis in g-forces.")
  )
  
  
  
    
  .
def
("getZ", &frc::ADXL362::GetZ, release_gil(), py::doc(
    "Returns the acceleration along the Z axis in g-forces.\n"
"\n"
":returns: The acceleration along the Z axis in g-forces.")
  )
  
  
  
    
  .
def
("getAcceleration", &frc::ADXL362::GetAcceleration,
      py::arg("axis"), release_gil(), py::doc(
    "Get the acceleration of one axis in Gs.\n"
"\n"
":param axis: The axis to read from.\n"
"\n"
":returns: Acceleration of the ADXL362 in Gs.")
  )
  
  
  
    
  .
def
("getAccelerations", &frc::ADXL362::GetAccelerations, release_gil(), py::doc(
    "Get the acceleration of all axes in Gs.\n"
"\n"
":returns: An object containing the acceleration measured on each axis of the\n"
"          ADXL362 in Gs.")
  )
  
  
  
    
  .
def
("initSendable", &frc::ADXL362::InitSendable,
      py::arg("builder"), release_gil()
  )
  
  
  ;

  


  

  cls_AllAxes.doc() =
    "Container type for accelerations from all axes.";

  cls_AllAxes
  
    .def(py::init<>(), release_gil())
  
    .def_readwrite("XAxis", &frc::ADXL362::AllAxes::XAxis, py::doc(
    "Acceleration along the X axis in g-forces."))
  
    .def_readwrite("YAxis", &frc::ADXL362::AllAxes::YAxis, py::doc(
    "Acceleration along the Y axis in g-forces."))
  
    .def_readwrite("ZAxis", &frc::ADXL362::AllAxes::ZAxis, py::doc(
    "Acceleration along the Z axis in g-forces."))
  ;

  


  
  }






}

}; // struct rpybuild_ADXL362_initializer

static std::unique_ptr<rpybuild_ADXL362_initializer> cls;

void begin_init_ADXL362(py::module &m) {
  cls = std::make_unique<rpybuild_ADXL362_initializer>(m);
}

void finish_init_ADXL362() {
  cls->finish();
  cls.reset();
}