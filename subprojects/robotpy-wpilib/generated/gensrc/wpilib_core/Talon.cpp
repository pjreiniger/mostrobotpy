
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/motorcontrol/Talon.h>








#define RPYGEN_ENABLE_frc__Talon_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__Talon.hpp>







#include <wpi/sendable/SendableBuilder.h>



#include <type_traits>


  using namespace frc;





struct rpybuild_Talon_initializer {


  

  












  
  using Talon_Trampoline = rpygen::PyTrampoline_frc__Talon<typename frc::Talon, typename rpygen::PyTrampolineCfg_frc__Talon<>>;
    static_assert(std::is_abstract<Talon_Trampoline>::value == false, "frc::Talon " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::Talon, Talon_Trampoline, frc::PWMMotorController> cls_Talon;

    

    
    

  py::module &m;

  
  rpybuild_Talon_initializer(py::module &m) :

  

  

  

  
    cls_Talon(m, "Talon"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_Talon.doc() =
    "Cross the Road Electronics (CTRE) %Talon and %Talon SR Motor %Controller.\n"
"\n"
"Note that the %Talon uses the following bounds for PWM values. These values\n"
"should work reasonably well for most controllers, but if users experience\n"
"issues such as asymmetric behavior around the deadband or inability to\n"
"saturate the controller in either direction, calibration is recommended.\n"
"The calibration procedure can be found in the %Talon User Manual available\n"
"from CTRE.\n"
"\n"
"- 2.037ms = full \"forward\"\n"
"- 1.539ms = the \"high end\" of the deadband range\n"
"- 1.513ms = center of the deadband range (off)\n"
"- 1.487ms = the \"low end\" of the deadband range\n"
"- 0.989ms = full \"reverse\"";

  cls_Talon
  
    
  .def(py::init<int>(),
      py::arg("channel"), release_gil(), py::doc(
    "Constructor for a %Talon (original or %Talon SR).\n"
"\n"
":param channel: The PWM channel number that the %Talon is attached to. 0-9\n"
"                are on-board, 10-19 are on the MXP port")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_Talon_initializer

static std::unique_ptr<rpybuild_Talon_initializer> cls;

void begin_init_Talon(py::module &m) {
  cls = std::make_unique<rpybuild_Talon_initializer>(m);
}

void finish_init_Talon() {
  cls->finish();
  cls.reset();
}