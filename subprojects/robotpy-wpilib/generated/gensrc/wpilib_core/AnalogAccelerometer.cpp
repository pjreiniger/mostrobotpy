
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/AnalogAccelerometer.h>








#define RPYGEN_ENABLE_frc__AnalogAccelerometer_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__AnalogAccelerometer.hpp>







#include <wpi/sendable/SendableBuilder.h>



#include <type_traits>


  using namespace frc;



struct rpybuild_AnalogAccelerometer_initializer {


  

  












  
  using AnalogAccelerometer_Trampoline = rpygen::PyTrampoline_frc__AnalogAccelerometer<typename frc::AnalogAccelerometer, typename rpygen::PyTrampolineCfg_frc__AnalogAccelerometer<>>;
    static_assert(std::is_abstract<AnalogAccelerometer_Trampoline>::value == false, "frc::AnalogAccelerometer " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::AnalogAccelerometer, AnalogAccelerometer_Trampoline, wpi::Sendable> cls_AnalogAccelerometer;

    

    
    

  py::module &m;

  
  rpybuild_AnalogAccelerometer_initializer(py::module &m) :

  

  

  

  
    cls_AnalogAccelerometer(m, "AnalogAccelerometer"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_AnalogAccelerometer.doc() =
    "Handle operation of an analog accelerometer.\n"
"\n"
"The accelerometer reads acceleration directly through the sensor. Many\n"
"sensors have multiple axis and can be treated as multiple devices. Each is\n"
"calibrated by finding the center value over a period of time.";

  cls_AnalogAccelerometer
  
    
  .def(py::init<int>(),
      py::arg("channel"), release_gil(), py::doc(
    "Create a new instance of an accelerometer.\n"
"\n"
"The constructor allocates desired analog input.\n"
"\n"
":param channel: The channel number for the analog input the accelerometer is\n"
"                connected to")
  )
  
  
  
    
  .def(py::init<std::shared_ptr<AnalogInput>>(),
      py::arg("channel"), release_gil(), py::doc(
    "Create a new instance of Accelerometer from an existing AnalogInput.\n"
"\n"
"Make a new instance of accelerometer given an AnalogInput. This is\n"
"particularly useful if the port is going to be read as an analog channel as\n"
"well as through the Accelerometer class.\n"
"\n"
":param channel: The existing AnalogInput object for the analog input the\n"
"                accelerometer is connected to")
  )
  
  
  
    
  .
def
("getAcceleration", &frc::AnalogAccelerometer::GetAcceleration, release_gil(), py::doc(
    "Return the acceleration in Gs.\n"
"\n"
"The acceleration is returned units of Gs.\n"
"\n"
":returns: The current acceleration of the sensor in Gs.")
  )
  
  
  
    
  .
def
("setSensitivity", &frc::AnalogAccelerometer::SetSensitivity,
      py::arg("sensitivity"), release_gil(), py::doc(
    "Set the accelerometer sensitivity.\n"
"\n"
"This sets the sensitivity of the accelerometer used for calculating the\n"
"acceleration. The sensitivity varies by accelerometer model. There are\n"
"constants defined for various models.\n"
"\n"
":param sensitivity: The sensitivity of accelerometer in Volts per G.")
  )
  
  
  
    
  .
def
("setZero", &frc::AnalogAccelerometer::SetZero,
      py::arg("zero"), release_gil(), py::doc(
    "Set the voltage that corresponds to 0 G.\n"
"\n"
"The zero G voltage varies by accelerometer model. There are constants\n"
"defined for various models.\n"
"\n"
":param zero: The zero G voltage.")
  )
  
  
  
    
  .
def
("initSendable", &frc::AnalogAccelerometer::InitSendable,
      py::arg("builder"), release_gil()
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_AnalogAccelerometer_initializer

static std::unique_ptr<rpybuild_AnalogAccelerometer_initializer> cls;

void begin_init_AnalogAccelerometer(py::module &m) {
  cls = std::make_unique<rpybuild_AnalogAccelerometer_initializer>(m);
}

void finish_init_AnalogAccelerometer() {
  cls->finish();
  cls.reset();
}