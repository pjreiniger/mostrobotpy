
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/AnalogInput.h>








#define RPYGEN_ENABLE_frc__AnalogInput_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__AnalogInput.hpp>







#include <wpi/sendable/SendableBuilder.h>

#include <frc/DMA.h>

#include <frc/DMASample.h>



#include <type_traits>


  using namespace frc;



struct rpybuild_AnalogInput_initializer {


  

  












  
  using AnalogInput_Trampoline = rpygen::PyTrampoline_frc__AnalogInput<typename frc::AnalogInput, typename rpygen::PyTrampolineCfg_frc__AnalogInput<>>;
    static_assert(std::is_abstract<AnalogInput_Trampoline>::value == false, "frc::AnalogInput " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::AnalogInput, AnalogInput_Trampoline, wpi::Sendable> cls_AnalogInput;

    

    
    

  py::module &m;

  
  rpybuild_AnalogInput_initializer(py::module &m) :

  

  

  

  
    cls_AnalogInput(m, "AnalogInput"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  
    static constexpr auto kAccumulatorModuleNumber [[maybe_unused]] = frc::AnalogInput::kAccumulatorModuleNumber;
  
    static constexpr auto kAccumulatorNumChannels [[maybe_unused]] = frc::AnalogInput::kAccumulatorNumChannels;
  
    static constexpr auto kAccumulatorChannels [[maybe_unused]] = frc::AnalogInput::kAccumulatorChannels;
  


  

  cls_AnalogInput.doc() =
    "Analog input class.\n"
"\n"
"Connected to each analog channel is an averaging and oversampling engine.\n"
"This engine accumulates the specified ( by SetAverageBits() and\n"
"SetOversampleBits() ) number of samples before returning a new value. This is\n"
"not a sliding window average. The only difference between the oversampled\n"
"samples and the averaged samples is that the oversampled samples are simply\n"
"accumulated effectively increasing the resolution, while the averaged samples\n"
"are divided by the number of samples to retain the resolution, but get more\n"
"stable values.";

  cls_AnalogInput
  
    
  .def(py::init<int>(),
      py::arg("channel"), release_gil(), py::doc(
    "Construct an analog input.\n"
"\n"
":param channel: The channel number on the roboRIO to represent. 0-3 are\n"
"                on-board 4-7 are on the MXP port.")
  )
  
  
  
    
  .
def
("getValue", &frc::AnalogInput::GetValue, release_gil(), py::doc(
    "Get a sample straight from this channel.\n"
"\n"
"The sample is a 12-bit value representing the 0V to 5V range of the A/D\n"
"converter in the module.  The units are in A/D converter codes.  Use\n"
"GetVoltage() to get the analog value in calibrated units.\n"
"\n"
":returns: A sample straight from this channel.")
  )
  
  
  
    
  .
def
("getAverageValue", &frc::AnalogInput::GetAverageValue, release_gil(), py::doc(
    "Get a sample from the output of the oversample and average engine for this\n"
"channel.\n"
"\n"
"The sample is 12-bit + the bits configured in SetOversampleBits().\n"
"The value configured in SetAverageBits() will cause this value to be\n"
"averaged 2**bits number of samples.\n"
"\n"
"This is not a sliding window. The sample will not change until\n"
"2**(OversampleBits + AverageBits) samples have been acquired from the\n"
"module on this channel.\n"
"\n"
"Use GetAverageVoltage() to get the analog value in calibrated units.\n"
"\n"
":returns: A sample from the oversample and average engine for this channel.")
  )
  
  
  
    
  .
def
("getVoltage", &frc::AnalogInput::GetVoltage, release_gil(), py::doc(
    "Get a scaled sample straight from this channel.\n"
"\n"
"The value is scaled to units of Volts using the calibrated scaling data\n"
"from GetLSBWeight() and GetOffset().\n"
"\n"
":returns: A scaled sample straight from this channel.")
  )
  
  
  
    
  .
def
("getAverageVoltage", &frc::AnalogInput::GetAverageVoltage, release_gil(), py::doc(
    "Get a scaled sample from the output of the oversample and average engine\n"
"for this channel.\n"
"\n"
"The value is scaled to units of Volts using the calibrated scaling data\n"
"from GetLSBWeight() and GetOffset().\n"
"\n"
"Using oversampling will cause this value to be higher resolution, but it\n"
"will update more slowly.\n"
"\n"
"Using averaging will cause this value to be more stable, but it will update\n"
"more slowly.\n"
"\n"
":returns: A scaled sample from the output of the oversample and average\n"
"          engine for this channel.")
  )
  
  
  
    
  .
def
("getChannel", &frc::AnalogInput::GetChannel, release_gil(), py::doc(
    "Get the channel number.\n"
"\n"
":returns: The channel number.")
  )
  
  
  
    
  .
def
("setAverageBits", &frc::AnalogInput::SetAverageBits,
      py::arg("bits"), release_gil(), py::doc(
    "Set the number of averaging bits.\n"
"\n"
"This sets the number of averaging bits. The actual number of averaged\n"
"samples is 2^bits.\n"
"\n"
"Use averaging to improve the stability of your measurement at the expense\n"
"of sampling rate. The averaging is done automatically in the FPGA.\n"
"\n"
":param bits: Number of bits of averaging.")
  )
  
  
  
    
  .
def
("getAverageBits", &frc::AnalogInput::GetAverageBits, release_gil(), py::doc(
    "Get the number of averaging bits previously configured.\n"
"\n"
"This gets the number of averaging bits from the FPGA. The actual number of\n"
"averaged samples is 2^bits. The averaging is done automatically in the\n"
"FPGA.\n"
"\n"
":returns: Number of bits of averaging previously configured.")
  )
  
  
  
    
  .
def
("setOversampleBits", &frc::AnalogInput::SetOversampleBits,
      py::arg("bits"), release_gil(), py::doc(
    "Set the number of oversample bits.\n"
"\n"
"This sets the number of oversample bits. The actual number of oversampled\n"
"values is 2^bits. Use oversampling to improve the resolution of your\n"
"measurements at the expense of sampling rate. The oversampling is done\n"
"automatically in the FPGA.\n"
"\n"
":param bits: Number of bits of oversampling.")
  )
  
  
  
    
  .
def
("getOversampleBits", &frc::AnalogInput::GetOversampleBits, release_gil(), py::doc(
    "Get the number of oversample bits previously configured.\n"
"\n"
"This gets the number of oversample bits from the FPGA. The actual number of\n"
"oversampled values is 2^bits. The oversampling is done automatically in the\n"
"FPGA.\n"
"\n"
":returns: Number of bits of oversampling previously configured.")
  )
  
  
  
    
  .
def
("getLSBWeight", &frc::AnalogInput::GetLSBWeight, release_gil(), py::doc(
    "Get the factory scaling least significant bit weight constant.\n"
"\n"
"Volts = ((LSB_Weight * 1e-9) * raw) - (Offset * 1e-9)\n"
"\n"
":returns: Least significant bit weight.")
  )
  
  
  
    
  .
def
("getOffset", &frc::AnalogInput::GetOffset, release_gil(), py::doc(
    "Get the factory scaling offset constant.\n"
"\n"
"Volts = ((LSB_Weight * 1e-9) * raw) - (Offset * 1e-9)\n"
"\n"
":returns: Offset constant.")
  )
  
  
  
    
  .
def
("isAccumulatorChannel", &frc::AnalogInput::IsAccumulatorChannel, release_gil(), py::doc(
    "Is the channel attached to an accumulator.\n"
"\n"
":returns: The analog input is attached to an accumulator.")
  )
  
  
  
    
  .
def
("initAccumulator", &frc::AnalogInput::InitAccumulator, release_gil(), py::doc(
    "Initialize the accumulator.")
  )
  
  
  
    
  .
def
("setAccumulatorInitialValue", &frc::AnalogInput::SetAccumulatorInitialValue,
      py::arg("value"), release_gil(), py::doc(
    "Set an initial value for the accumulator.\n"
"\n"
"This will be added to all values returned to the user.\n"
"\n"
":param value: The value that the accumulator should start from when reset.")
  )
  
  
  
    
  .
def
("resetAccumulator", &frc::AnalogInput::ResetAccumulator, release_gil(), py::doc(
    "Resets the accumulator to the initial value.")
  )
  
  
  
    
  .
def
("setAccumulatorCenter", &frc::AnalogInput::SetAccumulatorCenter,
      py::arg("center"), release_gil(), py::doc(
    "Set the center value of the accumulator.\n"
"\n"
"The center value is subtracted from each A/D value before it is added to\n"
"the accumulator. This is used for the center value of devices like gyros\n"
"and accelerometers to take the device offset into account when integrating.\n"
"\n"
"This center value is based on the output of the oversampled and averaged\n"
"source from the accumulator channel. Because of this, any non-zero\n"
"oversample bits will affect the size of the value for this field.")
  )
  
  
  
    
  .
def
("setAccumulatorDeadband", &frc::AnalogInput::SetAccumulatorDeadband,
      py::arg("deadband"), release_gil(), py::doc(
    "Set the accumulator's deadband.")
  )
  
  
  
    
  .
def
("getAccumulatorValue", &frc::AnalogInput::GetAccumulatorValue, release_gil(), py::doc(
    "Read the accumulated value.\n"
"\n"
"Read the value that has been accumulating.\n"
"The accumulator is attached after the oversample and average engine.\n"
"\n"
":returns: The 64-bit value accumulated since the last Reset().")
  )
  
  
  
    
  .
def
("getAccumulatorCount", &frc::AnalogInput::GetAccumulatorCount, release_gil(), py::doc(
    "Read the number of accumulated values.\n"
"\n"
"Read the count of the accumulated values since the accumulator was last\n"
"Reset().\n"
"\n"
":returns: The number of times samples from the channel were accumulated.")
  )
  
  
  
    
  .
def
("getAccumulatorOutput", [](frc::AnalogInput * __that) {
                    int64_t value;
          int64_t count;
          __that->GetAccumulatorOutput(value, count);
          return std::make_tuple(value,count);
        }, release_gil(), py::doc(
    "Read the accumulated value and the number of accumulated values atomically.\n"
"\n"
"This function reads the value and count from the FPGA atomically.\n"
"This can be used for averaging.\n"
"\n"
":param value: Reference to the 64-bit accumulated output.\n"
":param count: Reference to the number of accumulation cycles.")
  )
  
  
  
    
  .
def_static
("setSampleRate", &frc::AnalogInput::SetSampleRate,
      py::arg("samplesPerSecond"), release_gil(), py::doc(
    "Set the sample rate per channel for all analog channels.\n"
"\n"
"The maximum rate is 500kS/s divided by the number of channels in use.\n"
"This is 62500 samples/s per channel.\n"
"\n"
":param samplesPerSecond: The number of samples per second.")
  )
  
  
  
    
  .
def_static
("getSampleRate", &frc::AnalogInput::GetSampleRate, release_gil(), py::doc(
    "Get the current sample rate for all channels\n"
"\n"
":returns: Sample rate.")
  )
  
  
  
    
  .
def
("setSimDevice", &frc::AnalogInput::SetSimDevice,
      py::arg("device"), release_gil(), py::doc(
    "Indicates this input is used by a simulated device.\n"
"\n"
":param device: simulated device handle")
  )
  
  
  
    
  .
def
("initSendable", &frc::AnalogInput::InitSendable,
      py::arg("builder"), release_gil()
  )
  
  
  
    .def_readonly_static("kAccumulatorModuleNumber", &frc::AnalogInput::kAccumulatorModuleNumber)
  
    .def_readonly_static("kAccumulatorNumChannels", &frc::AnalogInput::kAccumulatorNumChannels)
  
    
  ;

  


  }







  cls_AnalogInput
  .def("__repr__", [](const AnalogInput &self) {
    return py::str("<AnalogInput {}>").format(self.GetChannel());
  });


}

}; // struct rpybuild_AnalogInput_initializer

static std::unique_ptr<rpybuild_AnalogInput_initializer> cls;

void begin_init_AnalogInput(py::module &m) {
  cls = std::make_unique<rpybuild_AnalogInput_initializer>(m);
}

void finish_init_AnalogInput() {
  cls->finish();
  cls.reset();
}