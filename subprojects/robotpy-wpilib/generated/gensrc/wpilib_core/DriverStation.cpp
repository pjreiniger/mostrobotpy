
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/DriverStation.h>


#include <pybind11/stl.h>

#include <units_time_type_caster.h>













#include <rpy/ControlWord.h>

#include <wpi/DataLog.h>



#include <type_traits>


  using namespace wpi::log;

  using namespace frc;





struct rpybuild_DriverStation_initializer {


  

  












  py::class_<typename frc::DriverStation> cls_DriverStation;

    
    
  py::enum_<frc::DriverStation::Alliance> cls_DriverStation_enum1;
    
    
  py::enum_<frc::DriverStation::MatchType> cls_DriverStation_enum2;
    

    
    

  py::module &m;

  
  rpybuild_DriverStation_initializer(py::module &m) :

  

  

  

  
    cls_DriverStation(m, "DriverStation", py::is_final()),

  
    cls_DriverStation_enum1
  (cls_DriverStation, "Alliance"
  ,
    "The robot alliance that the robot is a part of."),
  
    cls_DriverStation_enum2
  (cls_DriverStation, "MatchType"
  ,
    "The type of robot match that the robot is part of."),
  

  
  
  

    m(m)
  {
    
    

    
    
  
    cls_DriverStation_enum1
  
    .value("kRed", frc::DriverStation::Alliance::kRed,
      "Red alliance.")
  
    .value("kBlue", frc::DriverStation::Alliance::kBlue,
      "Blue alliance.")
  ;

  
    cls_DriverStation_enum2
  
    .value("kNone", frc::DriverStation::MatchType::kNone,
      "None.")
  
    .value("kPractice", frc::DriverStation::MatchType::kPractice,
      "Practice.")
  
    .value("kQualification", frc::DriverStation::MatchType::kQualification,
      "Qualification.")
  
    .value("kElimination", frc::DriverStation::MatchType::kElimination,
      "Elimination.")
  ;

  

    
    
  }

void finish() {





  {
  
  
  using Alliance [[maybe_unused]] = typename frc::DriverStation::Alliance;
  
  using MatchType [[maybe_unused]] = typename frc::DriverStation::MatchType;
  
  
    static constexpr auto kJoystickPorts [[maybe_unused]] = frc::DriverStation::kJoystickPorts;
  


  

  cls_DriverStation.doc() =
    "Provide access to the network communication data to / from the Driver\n"
"Station.";

  cls_DriverStation
  
    
  .
def_static
("getStickButton", &frc::DriverStation::GetStickButton,
      py::arg("stick"), py::arg("button"), release_gil(), py::doc(
    "The state of one joystick button. %Button indexes begin at 1.\n"
"\n"
":param stick:  The joystick to read.\n"
":param button: The button index, beginning at 1.\n"
"\n"
":returns: The state of the joystick button.")
  )
  
  
  
    
  .
def_static
("getStickButtonPressed", &frc::DriverStation::GetStickButtonPressed,
      py::arg("stick"), py::arg("button"), release_gil(), py::doc(
    "Whether one joystick button was pressed since the last check. %Button\n"
"indexes begin at 1.\n"
"\n"
":param stick:  The joystick to read.\n"
":param button: The button index, beginning at 1.\n"
"\n"
":returns: Whether the joystick button was pressed since the last check.")
  )
  
  
  
    
  .
def_static
("getStickButtonReleased", &frc::DriverStation::GetStickButtonReleased,
      py::arg("stick"), py::arg("button"), release_gil(), py::doc(
    "Whether one joystick button was released since the last check. %Button\n"
"indexes begin at 1.\n"
"\n"
":param stick:  The joystick to read.\n"
":param button: The button index, beginning at 1.\n"
"\n"
":returns: Whether the joystick button was released since the last check.")
  )
  
  
  
    
  .
def_static
("getStickAxis", &frc::DriverStation::GetStickAxis,
      py::arg("stick"), py::arg("axis"), release_gil(), py::doc(
    "Get the value of the axis on a joystick.\n"
"\n"
"This depends on the mapping of the joystick connected to the specified\n"
"port.\n"
"\n"
":param stick: The joystick to read.\n"
":param axis:  The analog axis value to read from the joystick.\n"
"\n"
":returns: The value of the axis on the joystick.")
  )
  
  
  
    
  .
def_static
("getStickPOV", &frc::DriverStation::GetStickPOV,
      py::arg("stick"), py::arg("pov"), release_gil(), py::doc(
    "Get the state of a POV on the joystick.\n"
"\n"
":returns: the angle of the POV in degrees, or -1 if the POV is not pressed.")
  )
  
  
  
    
  .
def_static
("getStickButtons", &frc::DriverStation::GetStickButtons,
      py::arg("stick"), release_gil(), py::doc(
    "The state of the buttons on the joystick.\n"
"\n"
":param stick: The joystick to read.\n"
"\n"
":returns: The state of the buttons on the joystick.")
  )
  
  
  
    
  .
def_static
("getStickAxisCount", &frc::DriverStation::GetStickAxisCount,
      py::arg("stick"), release_gil(), py::doc(
    "Returns the number of axes on a given joystick port.\n"
"\n"
":param stick: The joystick port number\n"
"\n"
":returns: The number of axes on the indicated joystick")
  )
  
  
  
    
  .
def_static
("getStickPOVCount", &frc::DriverStation::GetStickPOVCount,
      py::arg("stick"), release_gil(), py::doc(
    "Returns the number of POVs on a given joystick port.\n"
"\n"
":param stick: The joystick port number\n"
"\n"
":returns: The number of POVs on the indicated joystick")
  )
  
  
  
    
  .
def_static
("getStickButtonCount", &frc::DriverStation::GetStickButtonCount,
      py::arg("stick"), release_gil(), py::doc(
    "Returns the number of buttons on a given joystick port.\n"
"\n"
":param stick: The joystick port number\n"
"\n"
":returns: The number of buttons on the indicated joystick")
  )
  
  
  
    
  .
def_static
("getJoystickIsXbox", &frc::DriverStation::GetJoystickIsXbox,
      py::arg("stick"), release_gil(), py::doc(
    "Returns a boolean indicating if the controller is an xbox controller.\n"
"\n"
":param stick: The joystick port number\n"
"\n"
":returns: A boolean that is true if the controller is an xbox controller.")
  )
  
  
  
    
  .
def_static
("getJoystickType", &frc::DriverStation::GetJoystickType,
      py::arg("stick"), release_gil(), py::doc(
    "Returns the type of joystick at a given port.\n"
"\n"
":param stick: The joystick port number\n"
"\n"
":returns: The HID type of joystick at the given port")
  )
  
  
  
    
  .
def_static
("getJoystickName", &frc::DriverStation::GetJoystickName,
      py::arg("stick"), release_gil(), py::doc(
    "Returns the name of the joystick at the given port.\n"
"\n"
":param stick: The joystick port number\n"
"\n"
":returns: The name of the joystick at the given port")
  )
  
  
  
    
  .
def_static
("getJoystickAxisType", &frc::DriverStation::GetJoystickAxisType,
      py::arg("stick"), py::arg("axis"), release_gil(), py::doc(
    "Returns the types of Axes on a given joystick port.\n"
"\n"
":param stick: The joystick port number and the target axis\n"
":param axis:  The analog axis value to read from the joystick.\n"
"\n"
":returns: What type of axis the axis is reporting to be")
  )
  
  
  
    
  .
def_static
("isJoystickConnected", &frc::DriverStation::IsJoystickConnected,
      py::arg("stick"), release_gil(), py::doc(
    "Returns if a joystick is connected to the Driver Station.\n"
"\n"
"This makes a best effort guess by looking at the reported number of axis,\n"
"buttons, and POVs attached.\n"
"\n"
":param stick: The joystick port number\n"
"\n"
":returns: true if a joystick is connected")
  )
  
  
  
    
  .
def_static
("isEnabled", &frc::DriverStation::IsEnabled, release_gil(), py::doc(
    "Check if the DS has enabled the robot.\n"
"\n"
":returns: True if the robot is enabled and the DS is connected")
  )
  
  
  
    
  .
def_static
("isDisabled", &frc::DriverStation::IsDisabled, release_gil(), py::doc(
    "Check if the robot is disabled.\n"
"\n"
":returns: True if the robot is explicitly disabled or the DS is not connected")
  )
  
  
  
    
  .
def_static
("isEStopped", &frc::DriverStation::IsEStopped, release_gil(), py::doc(
    "Check if the robot is e-stopped.\n"
"\n"
":returns: True if the robot is e-stopped")
  )
  
  
  
    
  .
def_static
("isAutonomous", &frc::DriverStation::IsAutonomous, release_gil(), py::doc(
    "Check if the DS is commanding autonomous mode.\n"
"\n"
":returns: True if the robot is being commanded to be in autonomous mode")
  )
  
  
  
    
  .
def_static
("isAutonomousEnabled", &frc::DriverStation::IsAutonomousEnabled, release_gil(), py::doc(
    "Check if the DS is commanding autonomous mode and if it has enabled the\n"
"robot.\n"
"\n"
":returns: True if the robot is being commanded to be in autonomous mode and\n"
"          enabled.")
  )
  
  
  
    
  .
def_static
("isTeleop", &frc::DriverStation::IsTeleop, release_gil(), py::doc(
    "Check if the DS is commanding teleop mode.\n"
"\n"
":returns: True if the robot is being commanded to be in teleop mode")
  )
  
  
  
    
  .
def_static
("isTeleopEnabled", &frc::DriverStation::IsTeleopEnabled, release_gil(), py::doc(
    "Check if the DS is commanding teleop mode and if it has enabled the robot.\n"
"\n"
":returns: True if the robot is being commanded to be in teleop mode and\n"
"          enabled.")
  )
  
  
  
    
  .
def_static
("isTest", &frc::DriverStation::IsTest, release_gil(), py::doc(
    "Check if the DS is commanding test mode.\n"
"\n"
":returns: True if the robot is being commanded to be in test mode")
  )
  
  
  
    
  .
def_static
("isTestEnabled", &frc::DriverStation::IsTestEnabled, release_gil(), py::doc(
    "Check if the DS is commanding Test mode and if it has enabled the robot.\n"
"\n"
":returns: True if the robot is being commanded to be in Test mode and\n"
"          enabled.")
  )
  
  
  
    
  .
def_static
("isDSAttached", &frc::DriverStation::IsDSAttached, release_gil(), py::doc(
    "Check if the DS is attached.\n"
"\n"
":returns: True if the DS is connected to the robot")
  )
  
  
  
    
  .
def_static
("isFMSAttached", &frc::DriverStation::IsFMSAttached, release_gil(), py::doc(
    "Is the driver station attached to a Field Management System?\n"
"\n"
":returns: True if the robot is competing on a field being controlled by a\n"
"          Field Management System")
  )
  
  
  
    
  .
def_static
("getGameSpecificMessage", &frc::DriverStation::GetGameSpecificMessage, release_gil(), py::doc(
    "Returns the game specific message provided by the FMS.\n"
"\n"
"If the FMS is not connected, it is set from the game data setting on the\n"
"driver station.\n"
"\n"
":returns: A string containing the game specific message.")
  )
  
  
  
    
  .
def_static
("getEventName", &frc::DriverStation::GetEventName, release_gil(), py::doc(
    "Returns the name of the competition event provided by the FMS.\n"
"\n"
":returns: A string containing the event name")
  )
  
  
  
    
  .
def_static
("getMatchType", &frc::DriverStation::GetMatchType, release_gil(), py::doc(
    "Returns the type of match being played provided by the FMS.\n"
"\n"
":returns: The match type enum (kNone, kPractice, kQualification,\n"
"          kElimination)")
  )
  
  
  
    
  .
def_static
("getMatchNumber", &frc::DriverStation::GetMatchNumber, release_gil(), py::doc(
    "Returns the match number provided by the FMS.\n"
"\n"
":returns: The number of the match")
  )
  
  
  
    
  .
def_static
("getReplayNumber", &frc::DriverStation::GetReplayNumber, release_gil(), py::doc(
    "Returns the number of times the current match has been replayed from the\n"
"FMS.\n"
"\n"
":returns: The number of replays")
  )
  
  
  
    
  .
def_static
("getAlliance", &frc::DriverStation::GetAlliance, release_gil(), py::doc(
    "Get the current alliance from the FMS.\n"
"\n"
"If the FMS is not connected, it is set from the team alliance setting on\n"
"the driver station.\n"
"\n"
":returns: The alliance (red or blue) or an empty optional if the alliance is\n"
"          invalid")
  )
  
  
  
    
  .
def_static
("getLocation", &frc::DriverStation::GetLocation, release_gil(), py::doc(
    "Return the driver station location from the FMS.\n"
"\n"
"If the FMS is not connected, it is set from the team alliance setting on\n"
"the driver station.\n"
"\n"
"This could return 1, 2, or 3.\n"
"\n"
":returns: The location of the driver station (1-3, 0 for invalid)")
  )
  
  
  
    
  .
def_static
("waitForDsConnection", &frc::DriverStation::WaitForDsConnection,
      py::arg("timeout"), release_gil(), py::doc(
    "Wait for a DS connection.\n"
"\n"
":param timeout: timeout in seconds. 0 for infinite.\n"
"\n"
":returns: true if connected, false if timeout")
  )
  
  
  
    
  .
def_static
("getMatchTime", &frc::DriverStation::GetMatchTime, release_gil(), py::doc(
    "Return the approximate match time. The FMS does not send an official match\n"
"time to the robots, but does send an approximate match time. The value will\n"
"count down the time remaining in the current period (auto or teleop).\n"
"Warning: This is not an official time (so it cannot be used to dispute ref\n"
"calls or guarantee that a function will trigger before the match ends).\n"
"\n"
"When connected to the real field, this number only changes in full\n"
"integer increments, and always counts down.\n"
"\n"
"When the DS is in practice mode, this number is a floating point number,\n"
"and counts down.\n"
"\n"
"When the DS is in teleop or autonomous mode, this number is a floating\n"
"point number, and counts up.\n"
"\n"
"Simulation matches DS behavior without an FMS connected.\n"
"\n"
":returns: Time remaining in current match period (auto or teleop) in seconds")
  )
  
  
  
    
  .
def_static
("getBatteryVoltage", &frc::DriverStation::GetBatteryVoltage, release_gil(), py::doc(
    "Read the battery voltage.\n"
"\n"
":returns: The battery voltage in Volts.")
  )
  
  
  
    
  .
def_static
("refreshData", &frc::DriverStation::RefreshData, release_gil(), py::doc(
    "Copy data from the DS task for the user. If no new data exists, it will\n"
"just be returned, otherwise the data will be copied from the DS polling\n"
"loop.")
  )
  
  
  
    
  .
def_static
("provideRefreshedDataEventHandle", &frc::DriverStation::ProvideRefreshedDataEventHandle,
      py::arg("handle"), release_gil(), py::doc(
    "Registers the given handle for DS data refresh notifications.\n"
"\n"
":param handle: The event handle.")
  )
  
  
  
    
  .
def_static
("removeRefreshedDataEventHandle", &frc::DriverStation::RemoveRefreshedDataEventHandle,
      py::arg("handle"), release_gil(), py::doc(
    "Unregisters the given handle from DS data refresh notifications.\n"
"\n"
":param handle: The event handle.")
  )
  
  
  
    
  .
def_static
("silenceJoystickConnectionWarning", &frc::DriverStation::SilenceJoystickConnectionWarning,
      py::arg("silence"), release_gil(), py::doc(
    "Allows the user to specify whether they want joystick connection warnings\n"
"to be printed to the console. This setting is ignored when the FMS is\n"
"connected -- warnings will always be on in that scenario.\n"
"\n"
":param silence: Whether warning messages should be silenced.")
  )
  
  
  
    
  .
def_static
("isJoystickConnectionWarningSilenced", &frc::DriverStation::IsJoystickConnectionWarningSilenced, release_gil(), py::doc(
    "Returns whether joystick connection warnings are silenced. This will\n"
"always return false when connected to the FMS.\n"
"\n"
":returns: Whether joystick connection warnings are silenced.")
  )
  
  
  
    
  .
def_static
("startDataLog", &frc::DriverStation::StartDataLog,
      py::arg("log"), py::arg("logJoysticks") = true, release_gil(), py::doc(
    "Starts logging DriverStation data to data log. Repeated calls are ignored.\n"
"\n"
":param log:          data log\n"
":param logJoysticks: if true, log joystick data")
  )
  
  
  
    .def_readonly_static("kJoystickPorts", &frc::DriverStation::kJoystickPorts, py::doc(
    "Number of Joystick ports."))
  .def("getControlState",
  [](DriverStation *self) -> std::tuple<bool, bool, bool> {
    py::gil_scoped_release release;
    return rpy::GetControlState();
  },
  py::doc("More efficient way to determine what state the robot is in.\n"
          "\n"
          ":returns: booleans representing enabled, isautonomous, istest\n"
          "\n"
          ".. versionadded:: 2019.2.1\n"
          "\n"
          ".. note:: This function only exists in RobotPy\n"))
;

  


  }






}

}; // struct rpybuild_DriverStation_initializer

static std::unique_ptr<rpybuild_DriverStation_initializer> cls;

void begin_init_DriverStation(py::module &m) {
  cls = std::make_unique<rpybuild_DriverStation_initializer>(m);
}

void finish_init_DriverStation() {
  cls->finish();
  cls.reset();
}