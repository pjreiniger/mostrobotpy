
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/LEDPattern.h>


#include <pybind11/functional.h>

#include <units_frequency_type_caster.h>

#include <units_length_type_caster.h>

#include <units_time_type_caster.h>

#include <units_velocity_type_caster.h>

#include <wpi_span_type_caster.h>















#include <type_traits>


  using namespace frc;



struct rpybuild_LEDPattern_initializer {


  

  












  py::class_<typename frc::LEDPattern> cls_LEDPattern;

    
    
  py::enum_<frc::LEDPattern::GradientType> cls_LEDPattern_enum1;
    

    
    

  py::module &m;

  
  rpybuild_LEDPattern_initializer(py::module &m) :

  

  

  

  
    cls_LEDPattern(m, "LEDPattern"),

  
    cls_LEDPattern_enum1
  (cls_LEDPattern, "GradientType"
  ,
    "Types of gradients."),
  

  
  
  

    m(m)
  {
    
    

    
    
  
    cls_LEDPattern_enum1
  
    .value("kContinuous", frc::LEDPattern::GradientType::kContinuous,
      "A continuous gradient, where the gradient wraps around to allow for\n"
"seamless scrolling effects.")
  
    .value("kDiscontinuous", frc::LEDPattern::GradientType::kDiscontinuous,
      "A discontinuous gradient, where the first pixel is set to the first color\n"
"of the gradient and the final pixel is set to the last color of the\n"
"gradient. There is no wrapping effect, so scrolling effects will display\n"
"an obvious seam.")
  ;

  

    
    
  }

void finish() {





  {
  
  
  using GradientType [[maybe_unused]] = typename frc::LEDPattern::GradientType;
  
  


  

  

  cls_LEDPattern
  
    
  .def(py::init<LEDPatternFn>(),
      py::arg("impl"), release_gil()
  )
  
  
  
    
  .
def
("applyTo", static_cast<void(frc::LEDPattern::*)(std::span<frc::AddressableLED::LEDData>, LEDWriterFn) const>(
        &frc::LEDPattern::ApplyTo),
      py::arg("data"), py::arg("writer"), release_gil(), py::doc(
    "Writes the pattern to an LED buffer. Dynamic animations should be called\n"
"periodically (such as with a command or with a periodic method) to refresh\n"
"the buffer over time.\n"
"\n"
"This method is intentionally designed to use separate objects for reading\n"
"and writing data. By splitting them up, we can easily modify the behavior\n"
"of some base pattern to make it scroll, blink, or breathe by intercepting\n"
"the data writes to transform their behavior to whatever we like.\n"
"\n"
":param data:   the current data of the LED strip\n"
":param writer: data writer for setting new LED colors on the LED strip")
  )
  
  
  
    
  .
def
("applyTo", static_cast<void(frc::LEDPattern::*)(std::span<frc::AddressableLED::LEDData>) const>(
        &frc::LEDPattern::ApplyTo),
      py::arg("data"), release_gil(), py::doc(
    "Writes the pattern to an LED buffer. Dynamic animations should be called\n"
"periodically (such as with a command or with a periodic method) to refresh\n"
"the buffer over time.\n"
"\n"
"This method is intentionally designed to use separate objects for reading\n"
"and writing data. By splitting them up, we can easily modify the behavior\n"
"of some base pattern to make it scroll, blink, or breathe by intercepting\n"
"the data writes to transform their behavior to whatever we like.\n"
"\n"
":param data: the current data of the LED strip")
  )
  
  
  
    
  .
def
("reversed", &frc::LEDPattern::Reversed, release_gil(), py::doc(
    "Creates a pattern that displays this one in reverse. Scrolling patterns\n"
"will scroll in the opposite direction (but at the same speed). It will\n"
"treat the end of an LED strip as the start, and the start of the strip as\n"
"the end. This can be useful for making ping-pong patterns that travel from\n"
"one end of an LED strip to the other, then reverse direction and move back\n"
"to the start. This can also be useful when working with LED strips\n"
"connected in a serpentine pattern (where the start of one strip is\n"
"connected to the end of the previous one).\n"
"\n"
":returns: the reverse pattern")
  )
  
  
  
    
  .
def
("offsetBy", &frc::LEDPattern::OffsetBy,
      py::arg("offset"), release_gil(), py::doc(
    "Creates a pattern that displays this one, but offset by a certain number of\n"
"LEDs. The offset pattern will wrap around, if necessary.\n"
"\n"
":param offset: how many LEDs to offset by\n"
"\n"
":returns: the offset pattern")
  )
  
  
  
    
  .
def
("scrollAtRelativeSpeed", &frc::LEDPattern::ScrollAtRelativeSpeed,
      py::arg("velocity"), release_gil(), py::doc(
    "Creates a pattern that plays this one scrolling up the buffer. The velocity\n"
"controls how fast the pattern returns back to its original position, and is\n"
"in terms of the length of the LED strip; scrolling across a segment that is\n"
"10 LEDs long will travel twice as fast as on a segment that's only 5 LEDs\n"
"long (assuming equal LED density on both segments).")
  )
  
  
  
    
  .
def
("scrollAtAbsoluteSpeed", &frc::LEDPattern::ScrollAtAbsoluteSpeed,
      py::arg("velocity"), py::arg("ledSpacing"), release_gil(), py::doc(
    "Creates a pattern that plays this one scrolling up an LED strip. A negative\n"
"velocity makes the pattern play in reverse.\n"
"\n"
"For example, scrolling a pattern at 4 inches per second along an LED\n"
"strip with 60 LEDs per meter:\n"
"\n"
"::\n"
"\n"
"    // LEDs per meter, a known value taken from the spec sheet of our\n"
"  particular LED strip units::meter_t LED_SPACING = units::meter_t{1 /60.0};\n"
"  \n"
"    frc::LEDPattern rainbow = frc::LEDPattern::Rainbow();\n"
"    frc::LEDPattern scrollingRainbow =\n"
"      rainbow.ScrollAtAbsoluteSpeed(units::feet_per_second_t{1 / 3.0},\n"
"  LED_SPACING);\n"
"\n"
"Note that this pattern will scroll *faster* if applied to a less\n"
"dense LED strip (such as 30 LEDs per meter), or *slower* if applied to\n"
"a denser LED strip (such as 120 or 144 LEDs per meter).\n"
"\n"
":param velocity:   how fast the pattern should move along a physical LED strip\n"
":param ledSpacing: the distance between adjacent LEDs on the physical LED\n"
"                   strip\n"
"\n"
":returns: the scrolling pattern")
  )
  
  
  
    
  .
def
("blink", static_cast<LEDPattern(frc::LEDPattern::*)(units::second_t, units::second_t)>(
        &frc::LEDPattern::Blink),
      py::arg("onTime"), py::arg("offTime"), release_gil(), py::doc(
    "Creates a pattern that switches between playing this pattern and turning\n"
"the entire LED strip off.\n"
"\n"
":param onTime:  how long the pattern should play for, per cycle\n"
":param offTime: how long the pattern should be turned off for, per cycle\n"
"\n"
":returns: the blinking pattern")
  )
  
  
  
    
  .
def
("blink", static_cast<LEDPattern(frc::LEDPattern::*)(units::second_t)>(
        &frc::LEDPattern::Blink),
      py::arg("onTime"), release_gil(), py::doc(
    "Like {@link LEDPattern::Blink(units::second_t)}, but where the\n"
"\"off\" time is exactly equal to the \"on\" time.\n"
"\n"
":param onTime: how long the pattern should play for (and be turned off for),\n"
"               per cycle\n"
"\n"
":returns: the blinking pattern")
  )
  
  
  
    
  .
def
("synchronizedBlink", &frc::LEDPattern::SynchronizedBlink,
      py::arg("signal").none(false), release_gil(), py::doc(
    "Creates a pattern that blinks this one on and off in sync with a true/false\n"
"signal. The pattern will play while the signal outputs ``true``, and\n"
"will turn off while the signal outputs\n"
"``false``.\n"
"\n"
":param signal: the signal to synchronize with\n"
"\n"
":returns: the blinking pattern")
  )
  
  
  
    
  .
def
("breathe", &frc::LEDPattern::Breathe,
      py::arg("period"), release_gil(), py::doc(
    "Creates a pattern that brightens and dims this one over time. Brightness\n"
"follows a sinusoidal pattern.\n"
"\n"
":param period: how fast the breathing pattern should complete a single cycle\n"
"\n"
":returns: the breathing pattern")
  )
  
  
  
    
  .
def
("overlayOn", &frc::LEDPattern::OverlayOn,
      py::arg("base"), release_gil(), py::doc(
    "Creates a pattern that plays this pattern overlaid on another. Anywhere\n"
"this pattern sets an LED to off (or {@link frc::Color::kBlack}), the base\n"
"pattern will be displayed instead.\n"
"\n"
":param base: the base pattern to overlay on top of\n"
"\n"
":returns: the combined overlay pattern")
  )
  
  
  
    
  .
def
("blend", &frc::LEDPattern::Blend,
      py::arg("other"), release_gil(), py::doc(
    "Creates a pattern that displays outputs as a combination of this pattern\n"
"and another. Color values are calculated as the average color of both\n"
"patterns; if both patterns set the same LED to the same color, then it is\n"
"set to that color, but if one pattern sets to one color and the other\n"
"pattern sets it to off, then it will show the color of the first pattern\n"
"but at approximately half brightness. This is different from {@link\n"
"LEDPattern::OverlayOn(const LEDPattern&)}, which will show the base pattern\n"
"at full brightness if the overlay is set to off at that position.\n"
"\n"
":param other: the pattern to blend with\n"
"\n"
":returns: the blended pattern")
  )
  
  
  
    
  .
def
("mask", &frc::LEDPattern::Mask,
      py::arg("mask"), release_gil(), py::doc(
    "Similar to {@link LEDPattern::Blend(const LEDPattern&)}, but performs a\n"
"bitwise mask on each color channel rather than averaging the colors for\n"
"each LED. This can be helpful for displaying only a portion of the base\n"
"pattern by applying a mask that sets the desired area to white, and all\n"
"other areas to black. However, it can also be used to display only certain\n"
"color channels or hues; for example, masking with {@code\n"
"LEDPattern.color(Color.kRed)} will turn off the green and blue channels on\n"
"the output pattern, leaving only the red LEDs to be illuminated.\n"
"\n"
":param mask: the mask to apply\n"
"\n"
":returns: the masked pattern")
  )
  
  
  
    
  .
def
("atBrightness", &frc::LEDPattern::AtBrightness,
      py::arg("relativeBrightness"), release_gil(), py::doc(
    "Creates a pattern that plays this one, but at a different brightness.\n"
"Brightness multipliers are applied per-channel in the RGB space; no HSL or\n"
"HSV conversions are applied. Multipliers are also uncapped, which may\n"
"result in the original colors washing out and appearing less saturated or\n"
"even just a bright white.\n"
"\n"
"This method is predominantly intended for dimming LEDs to avoid\n"
"painfully bright or distracting patterns from playing (apologies to the\n"
"2024 NE Greater Boston field staff).\n"
"\n"
"For example, dimming can be done simply by adding a call to\n"
"`atBrightness` at the end of a pattern:\n"
"\n"
"::\n"
"\n"
"    // Solid red, but at 50% brightness\n"
"    frc::LEDPattern::Solid(frc::Color::kRed).AtBrightness(0.5);\n"
"  \n"
"    // Solid white, but at only 10% (i.e. ~0.5V)\n"
"    frc::LEDPattern::Solid(frc:Color::kWhite).AtBrightness(0.1);\n"
"\n"
":param relativeBrightness: the multiplier to apply to all channels to modify\n"
"                           brightness\n"
"\n"
":returns: the input pattern, displayed at")
  )
  
  
  
    
  .
def_static
("off", &frc::LEDPattern::Off, release_gil(), py::doc(
    "A pattern that turns off all LEDs.")
  )
  
  
  
    
  .
def_static
("solid", &frc::LEDPattern::Solid,
      py::arg("color"), release_gil(), py::doc(
    "Creates a pattern that displays a single static color along the entire\n"
"length of the LED strip.\n"
"\n"
":param color: the color to display\n"
"\n"
":returns: the pattern")
  )
  
  
  
    
  .
def_static
("progressMaskLayer", &frc::LEDPattern::ProgressMaskLayer,
      py::arg("progressFunction").none(false), release_gil(), py::doc(
    "Creates a pattern that works as a mask layer for {@link\n"
"LEDPattern::Mask(const LEDPattern&)} that illuminates only the portion of\n"
"the LED strip corresponding with some progress. The mask pattern will start\n"
"from the base and set LEDs to white at a proportion equal to the progress\n"
"returned by the function. Some usages for this could be for displaying\n"
"progress of a flywheel to its target velocity, progress of a complex\n"
"autonomous sequence, or the height of an elevator.\n"
"\n"
"For example, creating a mask for displaying a red-to-blue gradient,\n"
"starting from the red end, based on where an elevator is in its range of\n"
"travel.\n"
"\n"
"::\n"
"\n"
"  frc::LEDPattern basePattern =\n"
"    frc::LEDPattern::Gradient(frc::Color::kRed, frc::Color::kBlue);\n"
"  frc::LEDPattern progressPattern =\n"
"    basePattern.Mask(frc::LEDPattern::ProgressMaskLayer([&]() {\n"
"      return elevator.GetHeight() / elevator.MaxHeight();\n"
"    });\n"
"\n"
":param progressFunction: the function to call to determine the progress.\n"
"                         This should return values in the range [0, 1]; any values outside that\n"
"                         range will be clamped.\n"
"\n"
":returns: the mask pattern")
  )
  
  
  
    
  .
def_static
("steps", static_cast<LEDPattern(*)(std::span<const std::pair<double, Color>>)>(
        &frc::LEDPattern::Steps),
      py::arg("steps"), release_gil(), py::doc(
    "Display a set of colors in steps across the length of the LED strip. No\n"
"interpolation is done between colors. Colors are specified by the first LED\n"
"on the strip to show that color. The last color in the map will be\n"
"displayed all the way to the end of the strip. LEDs positioned before the\n"
"first specified step will be turned off (you can think of this as if\n"
"there's a 0 -> black step by default).\n"
"\n"
":param steps: a map of progress to the color to start displaying at that\n"
"              position along the LED strip\n"
"\n"
":returns: a motionless step pattern")
  )
  
  
  
    
  .
def_static
("gradient", static_cast<LEDPattern(*)(GradientType, std::span<const Color>)>(
        &frc::LEDPattern::Gradient),
      py::arg("type"), py::arg("colors"), release_gil(), py::doc(
    "Creates a pattern that displays a non-animated gradient of colors across\n"
"the entire length of the LED strip. Colors are evenly distributed along the\n"
"full length of the LED strip. The gradient type is configured with the\n"
"``type`` parameter, allowing the gradient to be either continuous (no\n"
"seams, good for scrolling effects) or discontinuous (a clear seam is\n"
"visible, but the gradient applies to the full length of the LED strip\n"
"without needing to use some space for wrapping).\n"
"\n"
":param type:   the type of gradient (continuous or discontinuous)\n"
":param colors: the colors to display in the gradient\n"
"\n"
":returns: a motionless gradient pattern")
  )
  
  
  
    
  .
def_static
("rainbow", &frc::LEDPattern::Rainbow,
      py::arg("saturation"), py::arg("value"), release_gil(), py::doc(
    "Creates an LED pattern that displays a rainbow across the color wheel. The\n"
"rainbow pattern will stretch across the entire length of the LED strip.\n"
"\n"
":param saturation: the saturation of the HSV colors, in [0, 255]\n"
":param value:      the value of the HSV colors, in [0, 255]\n"
"\n"
":returns: the rainbow pattern")
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_LEDPattern_initializer

static std::unique_ptr<rpybuild_LEDPattern_initializer> cls;

void begin_init_LEDPattern(py::module &m) {
  cls = std::make_unique<rpybuild_LEDPattern_initializer>(m);
}

void finish_init_LEDPattern() {
  cls->finish();
  cls.reset();
}