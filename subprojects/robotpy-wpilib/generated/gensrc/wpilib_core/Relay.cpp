
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/Relay.h>








#define RPYGEN_ENABLE_frc__Relay_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__Relay.hpp>







#include <wpi/sendable/SendableBuilder.h>

#include <wpi/SmallString.h>



#include <type_traits>


  using namespace frc;



struct rpybuild_Relay_initializer {


  

  












  
  using Relay_Trampoline = rpygen::PyTrampoline_frc__Relay<typename frc::Relay, typename rpygen::PyTrampolineCfg_frc__Relay<>>;
    static_assert(std::is_abstract<Relay_Trampoline>::value == false, "frc::Relay " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::Relay, Relay_Trampoline, frc::MotorSafety, wpi::Sendable> cls_Relay;

    
    
  py::enum_<frc::Relay::Value> cls_Relay_enum1;
    
    
  py::enum_<frc::Relay::Direction> cls_Relay_enum2;
    

    
    

  py::module &m;

  
  rpybuild_Relay_initializer(py::module &m) :

  

  

  

  
    cls_Relay(m, "Relay"),

  
    cls_Relay_enum1
  (cls_Relay, "Value"
  ,
    "The state to drive a Relay to."),
  
    cls_Relay_enum2
  (cls_Relay, "Direction"
  ,
    "The Direction(s) that a relay is configured to operate in."),
  

  
  
  

    m(m)
  {
    
    

    
    
  
    cls_Relay_enum1
  
    .value("kOff", frc::Relay::Value::kOff,
      "Off.")
  
    .value("kOn", frc::Relay::Value::kOn,
      "On.")
  
    .value("kForward", frc::Relay::Value::kForward,
      "Forward.")
  
    .value("kReverse", frc::Relay::Value::kReverse,
      "Reverse.")
  ;

  
    cls_Relay_enum2
  
    .value("kBothDirections", frc::Relay::Direction::kBothDirections,
      "Both directions are valid.")
  
    .value("kForwardOnly", frc::Relay::Direction::kForwardOnly,
      "Only forward is valid.")
  
    .value("kReverseOnly", frc::Relay::Direction::kReverseOnly,
      "Only reverse is valid.")
  ;

  

    
    
  }

void finish() {





  {
  
  
  using Value [[maybe_unused]] = typename frc::Relay::Value;
  
  using Direction [[maybe_unused]] = typename frc::Relay::Direction;
  
  


  

  cls_Relay.doc() =
    "Class for Spike style relay outputs.\n"
"\n"
"Relays are intended to be connected to spikes or similar relays. The relay\n"
"channels controls a pair of pins that are either both off, one on, the other\n"
"on, or both on. This translates into two spike outputs at 0v, one at 12v and\n"
"one at 0v, one at 0v and the other at 12v, or two spike outputs at 12V. This\n"
"allows off, full forward, or full reverse control of motors without variable\n"
"speed. It also allows the two channels (forward and reverse) to be used\n"
"independently for something that does not care about voltage polarity (like\n"
"a solenoid).";

  cls_Relay
  
    
  .def(py::init<int, Direction>(),
      py::arg("channel"), py::arg("direction") = frc::Relay::Direction::kBothDirections, release_gil(), py::doc(
    "Relay constructor given a channel.\n"
"\n"
"This code initializes the relay and reserves all resources that need to be\n"
"locked. Initially the relay is set to both lines at 0v.\n"
"\n"
":param channel:   The channel number (0-3).\n"
":param direction: The direction that the Relay object will control.")
  )
  
  
  
    
  .
def
("set", &frc::Relay::Set,
      py::arg("value"), release_gil(), py::doc(
    "Set the relay state.\n"
"\n"
"Valid values depend on which directions of the relay are controlled by the\n"
"object.\n"
"\n"
"When set to kBothDirections, the relay can be any of the four states:\n"
"0v-0v, 0v-12v, 12v-0v, 12v-12v\n"
"\n"
"When set to kForwardOnly or kReverseOnly, you can specify the constant for\n"
"the direction or you can simply specify kOff and kOn.  Using only kOff and\n"
"kOn is recommended.\n"
"\n"
":param value: The state to set the relay.")
  )
  
  
  
    
  .
def
("get", &frc::Relay::Get, release_gil(), py::doc(
    "Get the Relay State\n"
"\n"
"Gets the current state of the relay.\n"
"\n"
"When set to kForwardOnly or kReverseOnly, value is returned as kOn/kOff not\n"
"kForward/kReverse (per the recommendation in Set).\n"
"\n"
":returns: The current state of the relay as a Relay::Value")
  )
  
  
  
    
  .
def
("getChannel", &frc::Relay::GetChannel, release_gil()
  )
  
  
  
    
  .
def
("stopMotor", &frc::Relay::StopMotor, release_gil()
  )
  
  
  
    
  .
def
("getDescription", &frc::Relay::GetDescription, release_gil()
  )
  
  
  
    
  .
def
("initSendable", &frc::Relay::InitSendable,
      py::arg("builder"), release_gil()
  )
  
  
  ;

  


  }







  cls_Relay
  .def("__repr__", [](const Relay &self) {
    return py::str("<Relay {}>").format(self.GetChannel());
  });


}

}; // struct rpybuild_Relay_initializer

static std::unique_ptr<rpybuild_Relay_initializer> cls;

void begin_init_Relay(py::module &m) {
  cls = std::make_unique<rpybuild_Relay_initializer>(m);
}

void finish_init_Relay() {
  cls->finish();
  cls.reset();
}