
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/PneumaticsControlModule.h>


#include <units_current_type_caster.h>

#include <units_pressure_type_caster.h>

#include <units_time_type_caster.h>

#include <units_voltage_type_caster.h>







#define RPYGEN_ENABLE_frc__PneumaticsControlModule_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__PneumaticsControlModule.hpp>







#include <wpi/sendable/SendableBuilder.h>

#include <frc/Compressor.h>

#include <frc/Solenoid.h>

#include <frc/DoubleSolenoid.h>



#include <type_traits>


  using namespace frc;





struct rpybuild_PneumaticsControlModule_initializer {


  

  












  
  using PneumaticsControlModule_Trampoline = rpygen::PyTrampoline_frc__PneumaticsControlModule<typename frc::PneumaticsControlModule, typename rpygen::PyTrampolineCfg_frc__PneumaticsControlModule<>>;
    static_assert(std::is_abstract<PneumaticsControlModule_Trampoline>::value == false, "frc::PneumaticsControlModule " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::PneumaticsControlModule, PneumaticsControlModule_Trampoline, frc::PneumaticsBase> cls_PneumaticsControlModule;

    

    
    

  py::module &m;

  
  rpybuild_PneumaticsControlModule_initializer(py::module &m) :

  

  

  

  
    cls_PneumaticsControlModule(m, "PneumaticsControlModule"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_PneumaticsControlModule.doc() =
    "Module class for controlling a Cross The Road Electronics Pneumatics Control\n"
"Module.";

  cls_PneumaticsControlModule
  
    
  .def(py::init<>(), release_gil(), py::doc(
    "Constructs a PneumaticsControlModule with the default ID (0).")
  )
  
  
  
    
  .def(py::init<int>(),
      py::arg("module"), release_gil(), py::doc(
    "Constructs a PneumaticsControlModule.\n"
"\n"
":param module: module number to construct")
  )
  
  
  
    
  .
def
("getCompressor", &frc::PneumaticsControlModule::GetCompressor, release_gil()
  )
  
  
  
    
  .
def
("disableCompressor", &frc::PneumaticsControlModule::DisableCompressor, release_gil(), py::doc(
    "Disables the compressor. The compressor will not turn on until\n"
"EnableCompressorDigital() is called.")
  )
  
  
  
    
  .
def
("enableCompressorDigital", &frc::PneumaticsControlModule::EnableCompressorDigital, release_gil()
  )
  
  
  
    
  .
def
("enableCompressorAnalog", &frc::PneumaticsControlModule::EnableCompressorAnalog,
      py::arg("minPressure"), py::arg("maxPressure"), release_gil(), py::doc(
    "Enables the compressor in digital mode. Analog mode is unsupported by the\n"
"CTRE PCM.\n"
"\n"
":param minPressure: Unsupported.\n"
":param maxPressure: Unsupported.\n"
"                    @see EnableCompressorDigital()")
  )
  
  
  
    
  .
def
("enableCompressorHybrid", &frc::PneumaticsControlModule::EnableCompressorHybrid,
      py::arg("minPressure"), py::arg("maxPressure"), release_gil(), py::doc(
    "Enables the compressor in digital mode. Hybrid mode is unsupported by the\n"
"CTRE PCM.\n"
"\n"
":param minPressure: Unsupported.\n"
":param maxPressure: Unsupported.\n"
"                    @see EnableCompressorDigital()")
  )
  
  
  
    
  .
def
("getCompressorConfigType", &frc::PneumaticsControlModule::GetCompressorConfigType, release_gil()
  )
  
  
  
    
  .
def
("getPressureSwitch", &frc::PneumaticsControlModule::GetPressureSwitch, release_gil()
  )
  
  
  
    
  .
def
("getCompressorCurrent", &frc::PneumaticsControlModule::GetCompressorCurrent, release_gil()
  )
  
  
  
    
  .
def
("getCompressorCurrentTooHighFault", &frc::PneumaticsControlModule::GetCompressorCurrentTooHighFault, release_gil(), py::doc(
    "Return whether the compressor current is currently too high.\n"
"\n"
":returns: True if the compressor current is too high, otherwise false.\n"
"          @see GetCompressorCurrentTooHighStickyFault()")
  )
  
  
  
    
  .
def
("getCompressorCurrentTooHighStickyFault", &frc::PneumaticsControlModule::GetCompressorCurrentTooHighStickyFault, release_gil(), py::doc(
    "Returns whether the compressor current has been too high since sticky\n"
"faults were last cleared. This fault is persistent and can be cleared by\n"
"ClearAllStickyFaults()\n"
"\n"
":returns: True if the compressor current has been too high since sticky\n"
"          faults were last cleared.\n"
"          @see GetCompressorCurrentTooHighFault()")
  )
  
  
  
    
  .
def
("getCompressorShortedFault", &frc::PneumaticsControlModule::GetCompressorShortedFault, release_gil(), py::doc(
    "Returns whether the compressor is currently shorted.\n"
"\n"
":returns: True if the compressor is currently shorted, otherwise false.\n"
"          @see GetCompressorShortedStickyFault()")
  )
  
  
  
    
  .
def
("getCompressorShortedStickyFault", &frc::PneumaticsControlModule::GetCompressorShortedStickyFault, release_gil(), py::doc(
    "Returns whether the compressor has been shorted since sticky faults were\n"
"last cleared. This fault is persistent and can be cleared by\n"
"ClearAllStickyFaults()\n"
"\n"
":returns: True if the compressor has been shorted since sticky faults were\n"
"          last cleared, otherwise false.\n"
"          @see GetCompressorShortedFault()")
  )
  
  
  
    
  .
def
("getCompressorNotConnectedFault", &frc::PneumaticsControlModule::GetCompressorNotConnectedFault, release_gil(), py::doc(
    "Returns whether the compressor is currently disconnected.\n"
"\n"
":returns: True if compressor is currently disconnected, otherwise false.\n"
"          @see GetCompressorNotConnectedStickyFault()")
  )
  
  
  
    
  .
def
("getCompressorNotConnectedStickyFault", &frc::PneumaticsControlModule::GetCompressorNotConnectedStickyFault, release_gil(), py::doc(
    "Returns whether the compressor has been disconnected since sticky faults\n"
"were last cleared. This fault is persistent and can be cleared by\n"
"ClearAllStickyFaults()\n"
"\n"
":returns: True if the compressor has been disconnected since sticky faults\n"
"          were last cleared, otherwise false.\n"
"          @see GetCompressorNotConnectedFault()")
  )
  
  
  
    
  .
def
("getSolenoidVoltageFault", &frc::PneumaticsControlModule::GetSolenoidVoltageFault, release_gil(), py::doc(
    "Returns whether the solenoid is currently reporting a voltage fault.\n"
"\n"
":returns: True if solenoid is reporting a fault, otherwise false.\n"
"          @see GetSolenoidVoltageStickyFault()")
  )
  
  
  
    
  .
def
("getSolenoidVoltageStickyFault", &frc::PneumaticsControlModule::GetSolenoidVoltageStickyFault, release_gil(), py::doc(
    "Returns whether the solenoid has reported a voltage fault since sticky\n"
"faults were last cleared. This fault is persistent and can be cleared by\n"
"ClearAllStickyFaults()\n"
"\n"
":returns: True if solenoid is reporting a fault, otherwise false.\n"
"          @see GetSolenoidVoltageFault()")
  )
  
  
  
    
  .
def
("clearAllStickyFaults", &frc::PneumaticsControlModule::ClearAllStickyFaults, release_gil(), py::doc(
    "Clears all sticky faults on this device.")
  )
  
  
  
    
  .
def
("setSolenoids", &frc::PneumaticsControlModule::SetSolenoids,
      py::arg("mask"), py::arg("values"), release_gil()
  )
  
  
  
    
  .
def
("getSolenoids", &frc::PneumaticsControlModule::GetSolenoids, release_gil()
  )
  
  
  
    
  .
def
("getModuleNumber", &frc::PneumaticsControlModule::GetModuleNumber, release_gil()
  )
  
  
  
    
  .
def
("getSolenoidDisabledList", &frc::PneumaticsControlModule::GetSolenoidDisabledList, release_gil()
  )
  
  
  
    
  .
def
("fireOneShot", &frc::PneumaticsControlModule::FireOneShot,
      py::arg("index"), release_gil()
  )
  
  
  
    
  .
def
("setOneShotDuration", &frc::PneumaticsControlModule::SetOneShotDuration,
      py::arg("index"), py::arg("duration"), release_gil()
  )
  
  
  
    
  .
def
("checkSolenoidChannel", &frc::PneumaticsControlModule::CheckSolenoidChannel,
      py::arg("channel"), release_gil()
  )
  
  
  
    
  .
def
("checkAndReserveSolenoids", &frc::PneumaticsControlModule::CheckAndReserveSolenoids,
      py::arg("mask"), release_gil()
  )
  
  
  
    
  .
def
("unreserveSolenoids", &frc::PneumaticsControlModule::UnreserveSolenoids,
      py::arg("mask"), release_gil()
  )
  
  
  
    
  .
def
("reserveCompressor", &frc::PneumaticsControlModule::ReserveCompressor, release_gil()
  )
  
  
  
    
  .
def
("unreserveCompressor", &frc::PneumaticsControlModule::UnreserveCompressor, release_gil()
  )
  
  
  
    
  .
def
("getAnalogVoltage", &frc::PneumaticsControlModule::GetAnalogVoltage,
      py::arg("channel"), release_gil(), py::doc(
    "Unsupported by the CTRE PCM.\n"
"\n"
":param channel: Unsupported.\n"
"\n"
":returns: 0")
  )
  
  
  
    
  .
def
("getPressure", &frc::PneumaticsControlModule::GetPressure,
      py::arg("channel"), release_gil(), py::doc(
    "Unsupported by the CTRE PCM.\n"
"\n"
":param channel: Unsupported.\n"
"\n"
":returns: 0")
  )
  
  
  
    
  .
def
("makeSolenoid", &frc::PneumaticsControlModule::MakeSolenoid,
      py::arg("channel"), release_gil()
  )
  
  
  
    
  .
def
("makeDoubleSolenoid", &frc::PneumaticsControlModule::MakeDoubleSolenoid,
      py::arg("forwardChannel"), py::arg("reverseChannel"), release_gil()
  )
  
  
  
    
  .
def
("makeCompressor", &frc::PneumaticsControlModule::MakeCompressor, release_gil()
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_PneumaticsControlModule_initializer

static std::unique_ptr<rpybuild_PneumaticsControlModule_initializer> cls;

void begin_init_PneumaticsControlModule(py::module &m) {
  cls = std::make_unique<rpybuild_PneumaticsControlModule_initializer>(m);
}

void finish_init_PneumaticsControlModule() {
  cls->finish();
  cls.reset();
}