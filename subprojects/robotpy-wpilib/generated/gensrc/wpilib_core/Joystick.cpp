
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/Joystick.h>








#define RPYGEN_ENABLE_frc__Joystick_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__Joystick.hpp>







#include <frc/DriverStation.h>



#include <type_traits>


  using namespace frc;



struct rpybuild_Joystick_initializer {


  

  












  
  using Joystick_Trampoline = rpygen::PyTrampoline_frc__Joystick<typename frc::Joystick, typename rpygen::PyTrampolineCfg_frc__Joystick<>>;
    static_assert(std::is_abstract<Joystick_Trampoline>::value == false, "frc::Joystick " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::Joystick, Joystick_Trampoline, frc::GenericHID> cls_Joystick;

    
    
  py::enum_<frc::Joystick::AxisType> cls_Joystick_enum1;
    
    
  py::enum_<frc::Joystick::ButtonType> cls_Joystick_enum2;
    

    
    

  py::module &m;

  
  rpybuild_Joystick_initializer(py::module &m) :

  

  

  

  
    cls_Joystick(m, "Joystick"),

  
    cls_Joystick_enum1
  (cls_Joystick, "AxisType"
  ,
    "Represents an analog axis on a joystick."),
  
    cls_Joystick_enum2
  (cls_Joystick, "ButtonType"
  ,
    "Represents a digital button on a joystick."),
  

  
  
  

    m(m)
  {
    
    

    
    
  
    cls_Joystick_enum1
  
    .value("kXAxis", frc::Joystick::AxisType::kXAxis,
      "X axis.")
  
    .value("kYAxis", frc::Joystick::AxisType::kYAxis,
      "Y axis.")
  
    .value("kZAxis", frc::Joystick::AxisType::kZAxis,
      "Z axis.")
  
    .value("kTwistAxis", frc::Joystick::AxisType::kTwistAxis,
      "Twist axis.")
  
    .value("kThrottleAxis", frc::Joystick::AxisType::kThrottleAxis,
      "Throttle axis.")
  ;

  
    cls_Joystick_enum2
  
    .value("kTriggerButton", frc::Joystick::ButtonType::kTriggerButton,
      "kTrigger.")
  
    .value("kTopButton", frc::Joystick::ButtonType::kTopButton,
      "kTop.")
  ;

  

    
    
  }

void finish() {





  {
  
  
  using AxisType [[maybe_unused]] = typename frc::Joystick::AxisType;
  
  using ButtonType [[maybe_unused]] = typename frc::Joystick::ButtonType;
  
  
    static constexpr auto kDefaultXChannel [[maybe_unused]] = frc::Joystick::kDefaultXChannel;
  
    static constexpr auto kDefaultYChannel [[maybe_unused]] = frc::Joystick::kDefaultYChannel;
  
    static constexpr auto kDefaultZChannel [[maybe_unused]] = frc::Joystick::kDefaultZChannel;
  
    static constexpr auto kDefaultTwistChannel [[maybe_unused]] = frc::Joystick::kDefaultTwistChannel;
  
    static constexpr auto kDefaultThrottleChannel [[maybe_unused]] = frc::Joystick::kDefaultThrottleChannel;
  


  

  cls_Joystick.doc() =
    "Handle input from standard Joysticks connected to the Driver Station.\n"
"\n"
"This class handles standard input that comes from the Driver Station. Each\n"
"time a value is requested the most recent value is returned. There is a\n"
"single class instance for each joystick and the mapping of ports to hardware\n"
"buttons depends on the code in the Driver Station.";

  cls_Joystick
  
    
  .def(py::init<int>(),
      py::arg("port"), release_gil(), py::doc(
    "Construct an instance of a joystick.\n"
"\n"
"The joystick index is the USB port on the Driver Station.\n"
"\n"
":param port: The port on the Driver Station that the joystick is plugged\n"
"             into (0-5).")
  )
  
  
  
    
  .
def
("setXChannel", &frc::Joystick::SetXChannel,
      py::arg("channel"), release_gil(), py::doc(
    "Set the channel associated with the X axis.\n"
"\n"
":param channel: The channel to set the axis to.")
  )
  
  
  
    
  .
def
("setYChannel", &frc::Joystick::SetYChannel,
      py::arg("channel"), release_gil(), py::doc(
    "Set the channel associated with the Y axis.\n"
"\n"
":param channel: The channel to set the axis to.")
  )
  
  
  
    
  .
def
("setZChannel", &frc::Joystick::SetZChannel,
      py::arg("channel"), release_gil(), py::doc(
    "Set the channel associated with the Z axis.\n"
"\n"
":param channel: The channel to set the axis to.")
  )
  
  
  
    
  .
def
("setTwistChannel", &frc::Joystick::SetTwistChannel,
      py::arg("channel"), release_gil(), py::doc(
    "Set the channel associated with the twist axis.\n"
"\n"
":param channel: The channel to set the axis to.")
  )
  
  
  
    
  .
def
("setThrottleChannel", &frc::Joystick::SetThrottleChannel,
      py::arg("channel"), release_gil(), py::doc(
    "Set the channel associated with the throttle axis.\n"
"\n"
":param channel: The channel to set the axis to.")
  )
  
  
  
    
  .
def
("getXChannel", &frc::Joystick::GetXChannel, release_gil(), py::doc(
    "Get the channel currently associated with the X axis.\n"
"\n"
":returns: The channel for the axis.")
  )
  
  
  
    
  .
def
("getYChannel", &frc::Joystick::GetYChannel, release_gil(), py::doc(
    "Get the channel currently associated with the Y axis.\n"
"\n"
":returns: The channel for the axis.")
  )
  
  
  
    
  .
def
("getZChannel", &frc::Joystick::GetZChannel, release_gil(), py::doc(
    "Get the channel currently associated with the Z axis.\n"
"\n"
":returns: The channel for the axis.")
  )
  
  
  
    
  .
def
("getTwistChannel", &frc::Joystick::GetTwistChannel, release_gil(), py::doc(
    "Get the channel currently associated with the twist axis.\n"
"\n"
":returns: The channel for the axis.")
  )
  
  
  
    
  .
def
("getThrottleChannel", &frc::Joystick::GetThrottleChannel, release_gil(), py::doc(
    "Get the channel currently associated with the throttle axis.\n"
"\n"
":returns: The channel for the axis.")
  )
  
  
  
    
  .
def
("getX", &frc::Joystick::GetX, release_gil(), py::doc(
    "Get the X value of the current joystick.\n"
"\n"
"This depends on the mapping of the joystick connected to the current port.")
  )
  
  
  
    
  .
def
("getY", &frc::Joystick::GetY, release_gil(), py::doc(
    "Get the Y value of the current joystick.\n"
"\n"
"This depends on the mapping of the joystick connected to the current port.")
  )
  
  
  
    
  .
def
("getZ", &frc::Joystick::GetZ, release_gil(), py::doc(
    "Get the Z value of the current joystick.\n"
"\n"
"This depends on the mapping of the joystick connected to the current port.")
  )
  
  
  
    
  .
def
("getTwist", &frc::Joystick::GetTwist, release_gil(), py::doc(
    "Get the twist value of the current joystick.\n"
"\n"
"This depends on the mapping of the joystick connected to the current port.")
  )
  
  
  
    
  .
def
("getThrottle", &frc::Joystick::GetThrottle, release_gil(), py::doc(
    "Get the throttle value of the current joystick.\n"
"\n"
"This depends on the mapping of the joystick connected to the current port.")
  )
  
  
  
    
  .
def
("getTrigger", &frc::Joystick::GetTrigger, release_gil(), py::doc(
    "Read the state of the trigger on the joystick.\n"
"\n"
"Look up which button has been assigned to the trigger and read its state.\n"
"\n"
":returns: The state of the trigger.")
  )
  
  
  
    
  .
def
("getTriggerPressed", &frc::Joystick::GetTriggerPressed, release_gil(), py::doc(
    "Whether the trigger was pressed since the last check.\n"
"\n"
":returns: Whether the button was pressed since the last check.")
  )
  
  
  
    
  .
def
("getTriggerReleased", &frc::Joystick::GetTriggerReleased, release_gil(), py::doc(
    "Whether the trigger was released since the last check.\n"
"\n"
":returns: Whether the button was released since the last check.")
  )
  
  
  
    
  .
def
("trigger", &frc::Joystick::Trigger,
      py::arg("loop"), release_gil(), py::doc(
    "Constructs an event instance around the trigger button's digital signal.\n"
"\n"
":param loop: the event loop instance to attach the event to.\n"
"\n"
":returns: an event instance representing the trigger button's digital signal\n"
"          attached to the given loop.")
  )
  
  
  
    
  .
def
("getTop", &frc::Joystick::GetTop, release_gil(), py::doc(
    "Read the state of the top button on the joystick.\n"
"\n"
"Look up which button has been assigned to the top and read its state.\n"
"\n"
":returns: The state of the top button.")
  )
  
  
  
    
  .
def
("getTopPressed", &frc::Joystick::GetTopPressed, release_gil(), py::doc(
    "Whether the top button was pressed since the last check.\n"
"\n"
":returns: Whether the button was pressed since the last check.")
  )
  
  
  
    
  .
def
("getTopReleased", &frc::Joystick::GetTopReleased, release_gil(), py::doc(
    "Whether the top button was released since the last check.\n"
"\n"
":returns: Whether the button was released since the last check.")
  )
  
  
  
    
  .
def
("top", &frc::Joystick::Top,
      py::arg("loop"), release_gil(), py::doc(
    "Constructs an event instance around the top button's digital signal.\n"
"\n"
":param loop: the event loop instance to attach the event to.\n"
"\n"
":returns: an event instance representing the top button's digital signal\n"
"          attached to the given loop.")
  )
  
  
  
    
  .
def
("getMagnitude", &frc::Joystick::GetMagnitude, release_gil(), py::doc(
    "Get the magnitude of the direction vector formed by the joystick's\n"
"current position relative to its origin.\n"
"\n"
":returns: The magnitude of the direction vector")
  )
  
  
  
    .def_readonly_static("kDefaultXChannel", &frc::Joystick::kDefaultXChannel, py::doc(
    "Default X axis channel."))
  
    .def_readonly_static("kDefaultYChannel", &frc::Joystick::kDefaultYChannel, py::doc(
    "Default Y axis channel."))
  
    .def_readonly_static("kDefaultZChannel", &frc::Joystick::kDefaultZChannel, py::doc(
    "Default Z axis channel."))
  
    .def_readonly_static("kDefaultTwistChannel", &frc::Joystick::kDefaultTwistChannel, py::doc(
    "Default twist axis channel."))
  
    .def_readonly_static("kDefaultThrottleChannel", &frc::Joystick::kDefaultThrottleChannel, py::doc(
    "Default throttle axis channel."))
  ;

  


  }






}

}; // struct rpybuild_Joystick_initializer

static std::unique_ptr<rpybuild_Joystick_initializer> cls;

void begin_init_Joystick(py::module &m) {
  cls = std::make_unique<rpybuild_Joystick_initializer>(m);
}

void finish_init_Joystick() {
  cls->finish();
  cls.reset();
}