
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/AnalogEncoder.h>


#include <units_angle_type_caster.h>







#define RPYGEN_ENABLE_frc__AnalogEncoder_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__AnalogEncoder.hpp>







#include <wpi/sendable/SendableBuilder.h>

#include <frc/AnalogInput.h>



#include <type_traits>


  using namespace frc;





struct rpybuild_AnalogEncoder_initializer {


  

  












  
  using AnalogEncoder_Trampoline = rpygen::PyTrampoline_frc__AnalogEncoder<typename frc::AnalogEncoder, typename rpygen::PyTrampolineCfg_frc__AnalogEncoder<>>;
    static_assert(std::is_abstract<AnalogEncoder_Trampoline>::value == false, "frc::AnalogEncoder " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::AnalogEncoder, AnalogEncoder_Trampoline, wpi::Sendable> cls_AnalogEncoder;

    

    
    

  py::module &m;

  
  rpybuild_AnalogEncoder_initializer(py::module &m) :

  

  

  

  
    cls_AnalogEncoder(m, "AnalogEncoder"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_AnalogEncoder.doc() =
    "Class for supporting continuous analog encoders, such as the US Digital MA3.";

  cls_AnalogEncoder
  
    
  .def(py::init<int>(),
      py::arg("channel"), release_gil(), py::doc(
    "Construct a new AnalogEncoder attached to a specific AnalogIn channel.\n"
"\n"
":param channel: the analog input channel to attach to")
  )
  
  
  
    
  .def(py::init<std::shared_ptr<AnalogInput>>(),
      py::arg("analogInput"), release_gil(), py::doc(
    "Construct a new AnalogEncoder attached to a specific AnalogInput.\n"
"\n"
":param analogInput: the analog input to attach to")
  )
  
  
  
    
  .
def
("reset", &frc::AnalogEncoder::Reset, release_gil(), py::doc(
    "Reset the Encoder distance to zero.")
  )
  
  
  
    
  .
def
("get", &frc::AnalogEncoder::Get, release_gil(), py::doc(
    "Get the encoder value since the last reset.\n"
"\n"
"This is reported in rotations since the last reset.\n"
"\n"
":returns: the encoder value in rotations")
  )
  
  
  
    
  .
def
("getAbsolutePosition", &frc::AnalogEncoder::GetAbsolutePosition, release_gil(), py::doc(
    "Get the absolute position of the analog encoder.\n"
"\n"
"GetAbsolutePosition() - GetPositionOffset() will give an encoder\n"
"absolute position relative to the last reset. This could potentially be\n"
"negative, which needs to be accounted for.\n"
"\n"
"This will not account for rollovers, and will always be just the raw\n"
"absolute position.\n"
"\n"
":returns: the absolute position")
  )
  
  
  
    
  .
def
("getPositionOffset", &frc::AnalogEncoder::GetPositionOffset, release_gil(), py::doc(
    "Get the offset of position relative to the last reset.\n"
"\n"
"GetAbsolutePosition() - GetPositionOffset() will give an encoder absolute\n"
"position relative to the last reset. This could potentially be negative,\n"
"which needs to be accounted for.\n"
"\n"
":returns: the position offset")
  )
  
  
  
    
  .
def
("setPositionOffset", &frc::AnalogEncoder::SetPositionOffset,
      py::arg("offset"), release_gil(), py::doc(
    "Set the position offset.\n"
"\n"
"This must be in the range of 0-1.\n"
"\n"
":param offset: the offset")
  )
  
  
  
    
  .
def
("setDistancePerRotation", &frc::AnalogEncoder::SetDistancePerRotation,
      py::arg("distancePerRotation"), release_gil(), py::doc(
    "Set the distance per rotation of the encoder. This sets the multiplier used\n"
"to determine the distance driven based on the rotation value from the\n"
"encoder. Set this value based on the how far the mechanism travels in 1\n"
"rotation of the encoder, and factor in gearing reductions following the\n"
"encoder shaft. This distance can be in any units you like, linear or\n"
"angular.\n"
"\n"
":param distancePerRotation: the distance per rotation of the encoder")
  )
  
  
  
    
  .
def
("getDistancePerRotation", &frc::AnalogEncoder::GetDistancePerRotation, release_gil(), py::doc(
    "Get the distance per rotation for this encoder.\n"
"\n"
":returns: The scale factor that will be used to convert rotation to useful\n"
"          units.")
  )
  
  
  
    
  .
def
("getDistance", &frc::AnalogEncoder::GetDistance, release_gil(), py::doc(
    "Get the distance the sensor has driven since the last reset as scaled by\n"
"the value from SetDistancePerRotation.\n"
"\n"
":returns: The distance driven since the last reset")
  )
  
  
  
    
  .
def
("getChannel", &frc::AnalogEncoder::GetChannel, release_gil(), py::doc(
    "Get the channel number.\n"
"\n"
":returns: The channel number.")
  )
  
  
  
    
  .
def
("initSendable", &frc::AnalogEncoder::InitSendable,
      py::arg("builder"), release_gil()
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_AnalogEncoder_initializer

static std::unique_ptr<rpybuild_AnalogEncoder_initializer> cls;

void begin_init_AnalogEncoder(py::module &m) {
  cls = std::make_unique<rpybuild_AnalogEncoder_initializer>(m);
}

void finish_init_AnalogEncoder() {
  cls->finish();
  cls.reset();
}