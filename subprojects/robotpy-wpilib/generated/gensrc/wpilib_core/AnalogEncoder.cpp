
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/AnalogEncoder.h>








#define RPYGEN_ENABLE_frc__AnalogEncoder_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__AnalogEncoder.hpp>







#include <wpi/sendable/SendableBuilder.h>

#include <frc/AnalogInput.h>



#include <type_traits>


  using namespace frc;



struct rpybuild_AnalogEncoder_initializer {


  

  












  
  using AnalogEncoder_Trampoline = rpygen::PyTrampoline_frc__AnalogEncoder<typename frc::AnalogEncoder, typename rpygen::PyTrampolineCfg_frc__AnalogEncoder<>>;
    static_assert(std::is_abstract<AnalogEncoder_Trampoline>::value == false, "frc::AnalogEncoder " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::AnalogEncoder, AnalogEncoder_Trampoline, wpi::Sendable> cls_AnalogEncoder;

    

    
    

  py::module &m;

  
  rpybuild_AnalogEncoder_initializer(py::module &m) :

  

  

  

  
    cls_AnalogEncoder(m, "AnalogEncoder"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_AnalogEncoder.doc() =
    "Class for supporting continuous analog encoders, such as the US Digital MA3.";

  cls_AnalogEncoder
  
    
  .def(py::init<int>(),
      py::arg("channel"), release_gil(), py::doc(
    "Construct a new AnalogEncoder attached to a specific AnalogIn channel.\n"
"\n"
"This has a fullRange of 1 and an expectedZero of 0.\n"
"\n"
":param channel: the analog input channel to attach to")
  )
  
  
  
    
  .def(py::init<std::shared_ptr<AnalogInput>>(),
      py::arg("analogInput"), release_gil(), py::doc(
    "Construct a new AnalogEncoder attached to a specific AnalogInput.\n"
"\n"
"This has a fullRange of 1 and an expectedZero of 0.\n"
"\n"
":param analogInput: the analog input to attach to")
  )
  
  
  
    
  .def(py::init<int, double, double>(),
      py::arg("channel"), py::arg("fullRange"), py::arg("expectedZero"), release_gil(), py::doc(
    "Construct a new AnalogEncoder attached to a specific AnalogIn channel.\n"
"\n"
":param channel:      the analog input channel to attach to\n"
":param fullRange:    the value to report at maximum travel\n"
":param expectedZero: the reading where you would expect a 0 from get()")
  )
  
  
  
    
  .def(py::init<std::shared_ptr<AnalogInput>, double, double>(),
      py::arg("analogInput"), py::arg("fullRange"), py::arg("expectedZero"), release_gil(), py::doc(
    "Construct a new AnalogEncoder attached to a specific AnalogInput.\n"
"\n"
":param analogInput:  the analog input to attach to\n"
":param fullRange:    the value to report at maximum travel\n"
":param expectedZero: the reading where you would expect a 0 from get()")
  )
  
  
  
    
  .
def
("get", &frc::AnalogEncoder::Get, release_gil(), py::doc(
    "Get the encoder value.\n"
"\n"
":returns: the encoder value scaled by the full range input")
  )
  
  
  
    
  .
def
("setVoltagePercentageRange", &frc::AnalogEncoder::SetVoltagePercentageRange,
      py::arg("min"), py::arg("max"), release_gil(), py::doc(
    "Set the encoder voltage percentage range. Analog sensors are not always\n"
"fully stable at the end of their travel ranges. Shrinking this range down\n"
"can help mitigate issues with that.\n"
"\n"
":param min: minimum voltage percentage (0-1 range)\n"
":param max: maximum voltage percentage (0-1 range)")
  )
  
  
  
    
  .
def
("setInverted", &frc::AnalogEncoder::SetInverted,
      py::arg("inverted"), release_gil(), py::doc(
    "Set if this encoder is inverted.\n"
"\n"
":param inverted: true to invert the encoder, false otherwise")
  )
  
  
  
    
  .
def
("getChannel", &frc::AnalogEncoder::GetChannel, release_gil(), py::doc(
    "Get the channel number.\n"
"\n"
":returns: The channel number.")
  )
  
  
  
    
  .
def
("initSendable", &frc::AnalogEncoder::InitSendable,
      py::arg("builder"), release_gil()
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_AnalogEncoder_initializer

static std::unique_ptr<rpybuild_AnalogEncoder_initializer> cls;

void begin_init_AnalogEncoder(py::module &m) {
  cls = std::make_unique<rpybuild_AnalogEncoder_initializer>(m);
}

void finish_init_AnalogEncoder() {
  cls->finish();
  cls.reset();
}