
// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>




#include <frc/ADXRS450_Gyro.h>








#define RPYGEN_ENABLE_frc__ADXRS450_Gyro_PROTECTED_CONSTRUCTORS
#include <rpygen/frc__ADXRS450_Gyro.hpp>







#include <wpi/sendable/SendableBuilder.h>

#include <frc/DigitalSource.h>



#include <type_traits>


  using namespace frc;



struct rpybuild_ADXRS450_Gyro_initializer {


  

  












  
  using ADXRS450_Gyro_Trampoline = rpygen::PyTrampoline_frc__ADXRS450_Gyro<typename frc::ADXRS450_Gyro, typename rpygen::PyTrampolineCfg_frc__ADXRS450_Gyro<>>;
    static_assert(std::is_abstract<ADXRS450_Gyro_Trampoline>::value == false, "frc::ADXRS450_Gyro " RPYBUILD_BAD_TRAMPOLINE);
  py::class_<typename frc::ADXRS450_Gyro, ADXRS450_Gyro_Trampoline, wpi::Sendable> cls_ADXRS450_Gyro;

    

    
    

  py::module &m;

  
  rpybuild_ADXRS450_Gyro_initializer(py::module &m) :

  

  

  

  
    cls_ADXRS450_Gyro(m, "ADXRS450_Gyro"),

  

  
  
  

    m(m)
  {
    
    

    
    
  

    
    
  }

void finish() {





  {
  
  
  


  

  cls_ADXRS450_Gyro.doc() =
    "Use a rate gyro to return the robots heading relative to a starting position.\n"
"\n"
"The %Gyro class tracks the robots heading based on the starting position. As\n"
"the robot rotates the new heading is computed by integrating the rate of\n"
"rotation returned by the sensor. When the class is instantiated, it does a\n"
"short calibration routine where it samples the gyro while at rest to\n"
"determine the default offset. This is subtracted from each sample to\n"
"determine the heading.\n"
"\n"
"This class is for the digital ADXRS450 gyro sensor that connects via SPI.\n"
"Only one instance of an ADXRS %Gyro is supported.";

  cls_ADXRS450_Gyro
  
    
  .def(py::init<>(), release_gil(), py::doc(
    "%Gyro constructor on onboard CS0.")
  )
  
  
  
    
  .def(py::init<SPI::Port>(),
      py::arg("port"), release_gil(), py::doc(
    "%Gyro constructor on the specified SPI port.\n"
"\n"
":param port: The SPI port the gyro is attached to.")
  )
  
  
  
    
  .
def
("isConnected", &frc::ADXRS450_Gyro::IsConnected, release_gil()
  )
  
  
  
    
  .
def
("getAngle", &frc::ADXRS450_Gyro::GetAngle, release_gil(), py::doc(
    "Return the actual angle in degrees that the robot is currently facing.\n"
"\n"
"The angle is based on integration of the returned rate from the gyro.\n"
"The angle is continuous, that is it will continue from 360->361 degrees.\n"
"This allows algorithms that wouldn't want to see a discontinuity in the\n"
"gyro output as it sweeps from 360 to 0 on the second time around.\n"
"\n"
":returns: the current heading of the robot in degrees.")
  )
  
  
  
    
  .
def
("getRate", &frc::ADXRS450_Gyro::GetRate, release_gil(), py::doc(
    "Return the rate of rotation of the gyro\n"
"\n"
"The rate is based on the most recent reading of the gyro.\n"
"\n"
":returns: the current rate in degrees per second")
  )
  
  
  
    
  .
def
("reset", &frc::ADXRS450_Gyro::Reset, release_gil(), py::doc(
    "Reset the gyro.\n"
"\n"
"Resets the gyro to a heading of zero. This can be used if there is\n"
"significant drift in the gyro and it needs to be recalibrated after it has\n"
"been running.")
  )
  
  
  
    
  .
def
("calibrate", &frc::ADXRS450_Gyro::Calibrate, release_gil(), py::doc(
    "Calibrate the gyro by running for a number of samples and computing the\n"
"center value. Then use the center value as the Accumulator center value for\n"
"subsequent measurements.\n"
"\n"
"It's important to make sure that the robot is not moving while the\n"
"centering calculations are in progress, this is typically done when the\n"
"robot is first turned on while it's sitting at rest before the competition\n"
"starts.")
  )
  
  
  
    
  .
def
("getRotation2d", &frc::ADXRS450_Gyro::GetRotation2d, release_gil(), py::doc(
    "Return the heading of the robot as a Rotation2d.\n"
"\n"
"The angle is continuous, that is it will continue from 360 to 361 degrees.\n"
"This allows algorithms that wouldn't want to see a discontinuity in the\n"
"gyro output as it sweeps past from 360 to 0 on the second time around.\n"
"\n"
"The angle is expected to increase as the gyro turns counterclockwise when\n"
"looked at from the top. It needs to follow the NWU axis convention.\n"
"\n"
":returns: the current heading of the robot as a Rotation2d. This heading is\n"
"          based on integration of the returned rate from the gyro.")
  )
  
  
  
    
  .
def
("getPort", &frc::ADXRS450_Gyro::GetPort, release_gil(), py::doc(
    "Get the SPI port number.\n"
"\n"
":returns: The SPI port number.")
  )
  
  
  
    
  .
def
("initSendable", &frc::ADXRS450_Gyro::InitSendable,
      py::arg("builder"), release_gil()
  )
  
  
  ;

  


  }






}

}; // struct rpybuild_ADXRS450_Gyro_initializer

static std::unique_ptr<rpybuild_ADXRS450_Gyro_initializer> cls;

void begin_init_ADXRS450_Gyro(py::module &m) {
  cls = std::make_unique<rpybuild_ADXRS450_Gyro_initializer>(m);
}

void finish_init_ADXRS450_Gyro() {
  cls->finish();
  cls.reset();
}